\documentclass[10pt,onecolumn,a4paper,fleqn]{article}
%\documentclass[10pt,twocolumn,a4paper,fleqn]{article}

%%%%% AUTHORS - PLACE YOUR OWN PACKAGES HERE %%%%%
\usepackage[x11names,table]{xcolor}
\usepackage{moresize}
\usepackage{minted}
\usepackage{mdframed}
\usepackage{caption}

%%% minted setting %%%
\setminted{fontsize=\ssmall,baselinestretch=1}
%\setminted{fontsize=\fontsize{6.25}{7.25}\selectfont,baselinestretch=1}

%%% Page size setting %%%
\topmargin=0mm
\oddsidemargin=-5mm
\evensidemargin=-5mm
%\textheight=222mm
\textheight=180mm
%\textheight=130mm
\textwidth=165mm

% Beginning of document
\begin{document}
\pagenumbering{gobble}

%TODO: コードが1ページ以内に収まるように最低限の部分だけを残す。
\definecolor{bg}{rgb}{0.95,0.95,0.95}
\begin{mdframed}[
    backgroundcolor=bg,
    topline=false,
    bottomline=false,
    leftline=false,
    rightline=false]
  \begin{minted}[fontfamily=courier,linenos=true, breaklines]{cpp}
PS::S32 DispatchKernelStream(const PS::S32 tag,
                             const PS::S32 n_walk,
                             const EPI *epi[],
                             const PS::S32 n_epi[],
                             const EPJ *epj[],
                             const PS::S32 n_epj[],
                             const PS::SPJMonopole *spj[],
                             const PS::S32 n_spj[]){
  const int n_walk_ave = n_walk/N_STREAM;
  for(int id_stream=0; id_stream<N_STREAM; id_stream++){
    const int n_walk_in_stream = n_walk_ave + ((id_stream < n_walk%N_STREAM) ? 1 : 0);
    const int id_walk_head = n_walk_ave*id_stream + std::min(id_stream, n_walk%N_STREAM);
    const int id_walk_end  = id_walk_head + n_walk_in_stream;
    ij_disp_h[id_stream][0].x = ij_disp_h[id_stream][0].y = 0;
    for(int iw=0; iw<n_walk_in_stream; iw++){
      const int iw_src = iw+id_walk_head;
      ij_disp_h[id_stream][iw+1].x = ij_disp_h[id_stream][iw].x + n_epi[iw_src];
      ij_disp_h[id_stream][iw+1].y = ij_disp_h[id_stream][iw].y + (n_epj[iw_src]+n_spj[iw_src]);
    }
    ij_disp_h[id_stream][n_walk_in_stream+1] = ij_disp_h[id_stream][n_walk_in_stream];
    cudaMemcpyAsync(ij_disp_d[id_stream], ij_disp_h[id_stream], (n_walk_in_stream+2)*sizeof(int), cudaMemcpyHostToDevice, stream[id_stream]);        
    int ni_tot_reg = ij_disp_h[id_stream][n_walk_in_stream].x;
    ni_tot_reg = ((ni_tot_reg-1)/N_THREAD_GPU + 1)*N_THREAD_GPU;
    for(int iw=id_walk_head; iw<id_walk_end; iw++){
      const int iw_tmp = iw - id_walk_head;
      const int n_epi_tmp = n_epi[iw];
      int i_dst = ij_disp_h[id_stream][iw_tmp].x;
      for(int i=0; i<n_epi_tmp; i++, i_dst++){
        epi_h[id_stream][i_dst].pos.x   = epi[iw][i].pos.x;
        epi_h[id_stream][i_dst].pos.y   = epi[iw][i].pos.y;
        epi_h[id_stream][i_dst].pos.z   = epi[iw][i].pos.z;
        epi_h[id_stream][i_dst].id_walk = iw_tmp;
      }
      int j_dst = ij_disp_h[id_stream][iw_tmp].y;
      const int n_epj_tmp = n_epj[iw];
      for(int j=0; j<n_epj_tmp; j++, j_dst++){
        epj_h[id_stream][j_dst].posm.x = epj[iw][j].pos.x;
        epj_h[id_stream][j_dst].posm.y = epj[iw][j].pos.y;
        epj_h[id_stream][j_dst].posm.z = epj[iw][j].pos.z;
        epj_h[id_stream][j_dst].posm.w = epj[iw][j].mass;
      }
      const int n_spj_tmp = n_spj[iw];
      for(int j=0; j<n_spj_tmp; j++, j_dst++){
        epj_h[id_stream][j_dst].posm.x = spj[iw][j].pos.x;
        epj_h[id_stream][j_dst].posm.y = spj[iw][j].pos.y;
        epj_h[id_stream][j_dst].posm.z = spj[iw][j].pos.z;
        epj_h[id_stream][j_dst].posm.w = spj[iw][j].mass;
      }
    }
    const int ni_tot = ij_disp_h[id_stream][n_walk_in_stream].x;
    const int nj_tot = ij_disp_h[id_stream][n_walk_in_stream].y;
    for(int i=ni_tot; i<ni_tot_reg; i++){
      epi_h[id_stream][i].id_walk = n_walk_in_stream;
    }
    cudaMemcpyAsync(epi_d[id_stream], epi_h[id_stream], ni_tot_reg*sizeof(EPI_GPU), cudaMemcpyHostToDevice, stream[id_stream]);
    cudaMemcpyAsync(epj_d[id_stream], epj_h[id_stream], nj_tot*sizeof(EPJ_GPU), cudaMemcpyHostToDevice, stream[id_stream]);
    int nblocks  = ni_tot_reg / N_THREAD_GPU;
    int nthreads = N_THREAD_GPU;
    const float eps2 = FPGrav::eps * FPGrav::eps;
    ForceKernel <<<nblocks, nthreads, 0, stream[id_stream]>>> (ij_disp_d[id_stream], epi_d[id_stream], epj_d[id_stream], force_d[id_stream], eps2);
  }
  return 0;
}
  \end{minted}
\end{mdframed}

% End of Document

\end{document}
