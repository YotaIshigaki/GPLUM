#include<pzc_builtin.h>
#include"../class_device.hpp"
#include"../../../../inc/water_params.h"

void pzc_ForceKernel(const int * j_disp,
		     const EpiDev * epi,
		     const EpjDev * epj,
		     ForceDev * force,
		     const int n_total,
		     ForceDev *buf,
		     const float rc_cl,
		     const float rc_lj){
  // LIPS constant
  const float alpha2 = 0.19578f*0.19578f;
  const float au[9] = {
       0.0125143224110408f,
      -0.603493863454666f,
      11.7355819865242f,
     -96.296895305654f,
     216.649868508398f,
    -197.409191110696f,
      59.9544311773618f,
      13.9564907382725f,
      -8.66620089071555f
  };
  const float af[9] = {
     2.f*au[0],
     4.f*au[1],
     6.f*au[2],
     8.f*au[3],
    10.f*au[4],
    12.f*au[5],
    14.f*au[6],
    16.f*au[7],
    18.f*au[8]
  };
  const float rc_inv = 1.f / rc_cl;
  const float rc2i = rc_inv*rc_inv;
  const float rc3i = rc2i*rc2i*rc_cl;
  const float bound_ele_pot = rc_cl*rc2i*1.296557;
  // LJ constant
  const float s3 = SIGMA_OXY*SIGMA_OXY*SIGMA_OXY;
  const float s6 = s3*s3;
  const float ce12 = 4.f*EPSILON_OXY*s6*s6;
  const float ce06 = 4.f*EPSILON_OXY*s6;
  const float cf12 = 12.f*ce12;
  const float cf06 =  6.f*ce06;

  const float rc_cl_sq = rc_cl*rc_cl;
  const float rc_lj_sq = rc_lj*rc_lj;

  const int tid = get_tid();
  const int pid = get_pid();
  const int index_offset = get_maxtid()*pid + tid;
  const int index_base = get_maxtid()*get_maxpid();

  for(int index=index_offset; index<n_total; index += index_base){
    const float3 ri   = epi[index].pos;
    const int    idi  = epi[index].id;
    const int    walk = epi[index].walk;
    double3 fi = make_double3(0.0);
    double  ui = 0.0;
    for(int j=j_disp[walk]; j<j_disp[walk+1]; j++){
      const float3 rij = ri - epj[j].pos;
      const float  r2  = rij.x*rij.x + rij.y*rij.y + rij.z*rij.z;
      if((idi/3) == (epj[j].id/3)) continue;
      const float r2_inv = 1.0/r2;
      if (r2 <= rc_cl_sq){
	__asm volatile("// Coulomb");
	const float r = sqrt(r2);
	const float r_inv = r2_inv * r;
	const float q = epj[j].charge;
	const float rc = r * rc_inv;
	const float r2c2 = rc*rc;
	const float coef = (r2c2 - alpha2);
	const float coef2 = coef*coef;
	const float utmp = r2c2 * (au[0] + r2c2*
				   (au[1] + r2c2*
				    (au[2] + r2c2*
				     (au[3] + r2c2*
				      (au[4] + r2c2*
				       (au[5] + r2c2*
					(au[6] + r2c2*
					 (au[7] + (au[8] * r2c2)))))))));
	const float ftmp = (af[0] + r2c2*
			    (af[1] + r2c2*
			     (af[2] + r2c2*
			      (af[3] + r2c2*
			       (af[4] + r2c2*
				(af[5] + r2c2*
				 (af[6] + r2c2*
				  (af[7] + (af[8] * r2c2)))))))));
	ui += (double) (q * (r_inv - 0.5*rc_inv * coef * coef2 * utmp - bound_ele_pot));
	const float fs = q * (r2_inv*r_inv + 0.5*rc3i*coef2*(6.0*utmp + coef*ftmp));
	fi.x += (double)(fs * rij.x);
	fi.y += (double)(fs * rij.y);
	fi.z += (double)(fs * rij.z);
	__asm volatile("// end Coulomb");
      }
      if (r2 <= rc_lj_sq) {
	__asm volatile("// LJ");
	const float r6_inv  = r2_inv * r2_inv * r2_inv;
	const float r12_inv = r6_inv * r6_inv;
	ui += (double)(ce12*r12_inv - ce06*r6_inv);
	const float fs = (cf12*r12_inv - cf06*r6_inv) * r2_inv;
	fi.x += (double)(fs * rij.x);
	fi.y += (double)(fs * rij.y);
	fi.z += (double)(fs * rij.z);
	__asm volatile("// end LJ");
      }
    }
    buf[index].f.x = fi.x;
    buf[index].f.y = fi.y;
    buf[index].f.z = fi.z;
    buf[index].u   = ui;
  }
  flush();
}
