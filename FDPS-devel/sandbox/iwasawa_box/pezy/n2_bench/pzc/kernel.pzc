#include<pzc_builtin.h>
#include"../class_device.hpp"

#if 1
void pzc_ForceKernel(const EpiDev * epi,
                     const EpjDev * epj,
                     ForceDev * force,
                     const float eps2,
                     const int n_total){
		     
}

#elif 0
void pzc_ForceKernel(const EpiDev * epi,
                     const EpjDev * epj,
                     ForceDev * force,
                     const float eps2,
                     const int n_total){
    const int tid = get_tid();
    const int pid = get_pid();
    const int index_offset = pid * get_maxtid() + tid;
    const int index_base = get_maxtid()*get_maxpid();
    for(int index=index_offset; index<n_total/2; index += index_base){
        float2 ax, ay, az, pot;
        ax = ay = az = pot = 0.0;
        const EpiDev & ip0 = epi[index*2+0];
        const EpiDev & ip1 = epi[index*2+1];
        register float2 xi = make_float2(ip0.px, ip1.px); 
        register float2 yi = make_float2(ip0.py, ip1.py);
        register float2 zi = make_float2(ip0.pz, ip1.pz);
        float2 eps22 = make_float2(eps2, eps2);
        for(int j=0; j<n_total; j++){
            const EpjDev & jp = epj[j];
            const float2 mj = make_float2(epj[j].mass, epj[j].mass); 
            const float2 xj = make_float2(epj[j].px, epj[j].px); 
            const float2 yj = make_float2(epj[j].py, epj[j].py);
            const float2 zj = make_float2(epj[j].pz, epj[j].pz);
            const float2 dx = xj - xi;
            const float2 dy = yj - yi;
            const float2 dz = zj - zi;
            const float2 r2 = ((eps2 + dx*dx) + dy*dy) + dz*dz;
            const float2 r_inv = rsqrt(r2);
            const float2 pij = mj * r_inv;
            const float2 r2_inv = r_inv * r_inv; 
            const float2 pij_r3_inv = pij * r2_inv; 
            pot -= pij;
            ax += pij_r3_inv * dx;
            ay += pij_r3_inv * dy; 
            az += pij_r3_inv * dz;
        }
        force[index*2+0].pot = pot.x;
        force[index*2+0].ax  = ax.x;
        force[index*2+0].ay  = ay.x;
        force[index*2+0].az  = az.x;
        force[index*2+1].pot = pot.y;
        force[index*2+1].ax  = ax.y;
        force[index*2+1].ay  = ay.y;
        force[index*2+1].az  = az.y;
    }
    flush();
}
#elif 0
void pzc_ForceKernel(const EpiDev * epi,
                     const EpjDev * epj,
                     ForceDev * force,
                     const float eps2,
                     const int n_total){
    const int tid = get_tid();
    const int pid = get_pid();
    const int index_offset = pid * get_maxtid() + tid;
    const int index_base = get_maxtid()*get_maxpid();
    for(int index=index_offset; index<n_total; index += index_base){
        float ax, ay, az, pot;
        ax = ay = az = pot = 0.0;
        const EpiDev & ip = epi[index];
        for(int j=0; j<n_total; j++){
            const EpjDev & jp = epj[j];
            const float dx = jp.px - ip.px;
            const float dy = jp.py - ip.py;
            const float dz = jp.pz - ip.pz;
            const float r2 = ((eps2 + dx*dx) + dy*dy) + dz*dz;
            const float r_inv = rsqrt(r2);
            const float pij = jp.mass * r_inv;
            const float r2_inv = r_inv * r_inv; 
            const float pij_r3_inv = pij * r2_inv; 
            pot -= pij;
            ax += pij_r3_inv * dx;
            ay += pij_r3_inv * dy; 
            az += pij_r3_inv * dz;
        }
        force[index].pot = pot;
        force[index].ax = ax;
        force[index].ay = ay;
        force[index].az = az;

    }
    flush();
}
#else 
// original for tree
void pzc_ForceKernel(const int * j_disp,
                     const EpiDev * epi,
                     const EpjDev * epj,
                     ForceDev * force,
                     const float eps2,
                     const int n_total){
    const int tid = get_tid();
    const int pid = get_pid();
    const int index_offset = pid * get_maxtid() + tid;
    const int index_base = get_maxtid()*get_maxpid();
    for(int index=index_offset; index<n_total; index += index_base){
        float ax, ay, az, pot;
        ax = ay = az = pot = 0.0;
        const EpiDev & ip = epi[index];
        const int id_walk = ip.id_walk;
        const int j_head = j_disp[id_walk];
        const int j_tail = j_disp[id_walk+1];
        for(int j=j_head; j<j_tail; j++){
            const EpjDev & jp = epj[j];
            const float dx = jp.px - ip.px;
            const float dy = jp.py - ip.py;
            const float dz = jp.pz - ip.pz;
            const float r2 = ((eps2 + dx*dx) + dy*dy) + dz*dz;
            const float r_inv = rsqrt(r2);
            const float pij = jp.mass * r_inv;
            const float r2_inv = r_inv * r_inv; 
            const float pij_r3_inv = pij * r2_inv; 
            pot -= pij;
            ax += pij_r3_inv * dx;
            ay += pij_r3_inv * dy; 
            az += pij_r3_inv * dz;
        }
        force[index].pot = pot;
        force[index].ax = ax;
        force[index].ay = ay;
        force[index].az = az;
    }
    flush();
}
#endif
