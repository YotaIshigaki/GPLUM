#include<pzc_builtin.h>
#include"../class_device.hpp"

#if 0
// unroll 2

/*
 Register map
 | d0  | f0  | f1  | : xj, yj
 | d1  | f2  | f3  | : zj, mj
 | d2  | f4  | f5  | : xi[2]
 | d3  | f6  | f7  | : yi[2]
 | d4  | f8  | f9  | : zi[2]
 | d5  | f10 | f11 | : dx[2]
 | d6  | f12 | f13 | : dy[2]
 | d7  | f14 | f15 | : dz[2]
 | d8  | f16 | f17 | : eps2, 1.0f
 | d9  | f18 | f19 | : 0.5f, 0.375f
 | d10 | f20 | f21 | : r2[2] -> ri2[2]
 | d11 | f22 | f23 | : ri[2] -> mri[2] -> mri3[2]
 | d12 | f24 | f25 | : work0
 | d13 | f26 | f27 | : work1
 | d14 | f28 | f29 | : work2
 | d15 | f30 | f31 | : work3

 | a0  | as0 | as1 | : ax[2]
 | a1  | as2 | as3 | : ay[2]
 | a2  | as4 | as5 | : az[2]
 | a3  | as6 | as7 | : pot[2]
*/

void pzc_ForceKernel(const int * j_disp,
                     const EpiDev * epi,
                     const EpjDev * epj,
                     ForceDev * force,
                     const float eps2,
                     const int n_total){
    const int tid = get_tid();
    const int pid = get_pid();
    const int index_offset = pid * get_maxtid() + tid;
    const int index_base = get_maxtid()*get_maxpid();
    // move eps2
    __asm__ volatile(
                     "f.mov f16 %0;\n\t"
                     :
                     : "w"(eps2)
                     : );
    for(int index=index_offset; index<n_total/2; index += index_base){
        // clear accumulators
#if 0
        __asm__ volatile(
                         "d.mov a0 %0;\n\t"
                         "d.mov a1 %0;\n\t"
                         "d.mov a2 %0;\n\t"
                         "d.mov a3 %0;\n\t"
                         :
                         : "w"(0.0)
                         : );
#else
        __asm__ volatile(
                         "d.sub d0 d0 d0;\n\t"
                         "d.mov a0 d0;\n\t"
                         "d.mov a1 d0;\n\t"
                         "d.mov a2 d0;\n\t"
                         "d.mov a3 d0;\n\t"
                         );
#endif
        // set i-particles
        const EpiDev *ip0 = &epi[index*2+0];
        const EpiDev *ip1 = &epi[index*2+1];
        const int id_walk = ip0->id_walk;
        const int j_head = j_disp[id_walk];
        const int j_tail = j_disp[id_walk+1];
        __asm__ volatile(
                         "f.eld f4 %0 0;\n\t"
                         "f.eld f5 %1 0;\n\t"
                         "f.eld f6 %0 4;\n\t"
                         "f.eld f7 %1 4;\n\t"
                         "f.eld f8 %0 8;\n\t"
                         "f.eld f9 %1 8;\n\t"
                         :
                         : "r"(ip0), "r"(ip1)
                         : );
        // set constants
        __asm__ volatile(
                         "f.movhi f17 16256; \n\t" // 1.0f
                         "f.movhi f18 16128; \n\t" // 0.5f
                         "f.movhi f19 16064; \n\t" // 0.375f
                         );
        int ifuck = 0x5f3759df;
        // Loop body
        __asm__ volatile(
                         "d.eldd  d0 %0 0; \n\t"
                         "d.eldd  d1 %0 8; \n\t"
                         :
                         : "r"(&epj[j_head])
                         : );

        for(int j=j_head; j<j_tail; j++){
            int i0, i1;
            __asm__ volatile(
                             // load jp
                             // "d.eldd  d0 %2 0; \n\t"
                             // "d.eldd  d1 %2 8; \n\t"
                             // "c.chgthread; \n\t"
                             // calc relative pos
                             "f.sub f10 f0 f4; \n\t"
                             "f.sub f11 f0 f5; \n\t" // dx = xj - xi
                             "f.sub f12 f1 f6; \n\t"
                             "f.sub f13 f1 f7; \n\t" // dy = yj - yi
                             //"d.eldd  d0 %2 16; \n\t"
                             "f.sub f14 f2 f8; \n\t"
                             "f.eld f0 %2 16;\n\t"
                             "f.sub f15 f2 f9; \n\t" // dz = zj - zi
                             "f.eld f1 %2 20;\n\t"
                             // calc r^2
                             "f.mul f24 f10 f10; \n\t"
                             "f.mul f25 f11 f11; \n\t" // t = dx * dx
                             "f.add f20 f16 f24; \n\t"
                             "f.add f21 f16 f25; \n\t" // r2 = eps2 + t
                             "f.mul f24 f12 f12; \n\t"
                             "f.mul f25 f13 f13; \n\t" // t = dy * dy
                             "f.add f20 f20 f24; \n\t"
                             "f.add f21 f21 f25; \n\t" // r2 = r2 + t
                             "f.mul f24 f14 f14; \n\t"
                             "f.mul f25 f15 f15; \n\t" // t = dz * dz
                             "f.add f20 f20 f24; \n\t"
                             "f.add f21 f21 f25; \n\t" // r2 = r2 + t
                             // fast inverse square root
                             /*
                             "f.rsqrt f22 f20; \n\t"
                             "f.rsqrt f23 f21; \n\t"
                             */
                             "f.ftoimv %0 f20; \n\t"
                             "f.ftoimv %1 f21; \n\t"
                             "i.srai %0 %0 1; \n\t"
                             "i.srai %1 %1 1; \n\t"
                             "i.sub %0 %3 %0; \n\t"
                             "i.sub %1 %3 %1; \n\t"
                             "f.itofmv f22 %0; \n\t"
                             "f.itofmv f23 %1; \n\t"   // ri = rsqrta(r2)
                             // convergence
                             "f.mul f24 f22 f22; \n\t"
                             "f.mul f25 f23 f23; \n\t" // t = ri*ri
                             "f.mul f24 f24 f20; \n\t"
                             "f.mul f25 f25 f21; \n\t" // t = t * r2
                             "f.sub f24 f17 f24; \n\t"
                             "f.sub f25 f17 f25; \n\t" // h = 1.0f - t
                             "f.mul f26 f19 f24; \n\t"
                             "f.mul f27 f19 f25; \n\t" // p = 0.375 * h
                             "f.add f26 f18 f26; \n\t"
                             "f.add f27 f18 f27; \n\t" // p = 0.5f + p
                             "f.mul f26 f24 f26; \n\t"
                             "f.mul f27 f25 f27; \n\t" // p = h * p
                             "f.add f26 f17 f26; \n\t"
                             "f.add f27 f17 f27; \n\t" // p = 1.0f + p
                             "f.mul f22 f26 f22; \n\t"
                             "f.mul f23 f27 f23; \n\t" // ri = p * ri
                             // force
                             "f.mul f20 f22 f22; \n\t"
                             "f.mul f21 f23 f23; \n\t" // ri2 = ri * ri
                             "f.mul f22 f3 f22; \n\t"
                             "f.mul f23 f3 f23; \n\t" // mri = mj * ri
                             "f.mad as6 f17 f22 as6 ;\n\t"
                             "f.eld f2 %2 24; \n\t"
                             "f.mad as7 f17 f23 as7 ;\n\t" // pot = 1.0f * mri + pot
                             "f.mul f22 f20 f22; \n\t"
                             "f.eld f3 %2 28; \n\t"
                             "f.mul f23 f21 f23; \n\t" // mri3 = ri2 * mri
                             // accumulate

                             "f.mad as0 f22 f10 as0 ; \n\t"
                             "f.mad as1 f23 f11 as1 ; \n\t" // ax += mri3 * dx
                             "f.mad as2 f22 f12 as2 ; \n\t"
                             "f.mad as3 f23 f13 as3 ; \n\t" // ay += mri3 * dy
                             "f.mad as4 f22 f14 as4 ; \n\t"
                             "f.mad as5 f23 f15 as5 ; \n\t" // az += mri3 * dz

                             : "=r"(i0),  "=r"(i1)
                             : "r"(&epj[j]), "r"(ifuck)
                             : );
            chgthread();
        } // for(j)
        __asm__ volatile(
                         "f.movhi f17 0;\n\t" // 0.0f
                         "f.msub as6 f17 f17 as6 ;\n\t"
                         "f.msub as7 f17 f17 as7 ;\n\t" // pot = 0.0f * 0.0f - pot
                         "d.mov d0 a0;\n\t"
                         "d.mov d1 a1;\n\t"
                         "d.mov d2 a2;\n\t"
                         "d.mov d3 a3;\n\t"
                         //"f.mov f7 f17;\n\t" // debug
                         "f.esw %0  0 f0\n\t"
                         "f.esw %0  4 f2\n\t"
                         "f.esw %0  8 f4\n\t"
                         "f.esw %0 12 f6\n\t"
                         "f.esw %1  0 f1\n\t"
                         "f.esw %1  4 f3\n\t"
                         "f.esw %1  8 f5\n\t"
                         "f.esw %1 12 f7\n\t"
                         :
                         : "r"(&force[index*2+0]), "r"(&force[index*2+1])
                         : );
    } // for(i)
    flush();
}

#elif 1
// // unroll 4
/*
 * This version avoids to call d.eldd
 */

/*
 Register map
 | d0  | f0  | f1  | : xj, yj
 | d1  | f2  | f3  | : zj, mj
 | d2  | f4  | f5  | : xi[2]
 | d3  | f6  | f7  | : yi[2]
 | d4  | f8  | f9  | : zi[2]
 | d5  | f10 | f11 | : dx[2]
 | d6  | f12 | f13 | : dy[2]
 | d7  | f14 | f15 | : dz[2]
 | d8  | f16 | f17 | : eps2, 1.0f
 | d9  | f18 | f19 | : 0.5f, 0.375f
 | d10 | f20 | f21 | : r2[2] -> h[2] -> ri2[2]
 | d11 | f22 | f23 | : ri[2] -> mri[2] -> mri3[2]
 | d12 | f24 | f25 | : work0
 | d13 | f26 | f27 | : xi'[2]
 | d14 | f28 | f29 | : yi'[2]
 | d15 | f30 | f31 | : zi'[2]
 | a0  | as0  | as1  | : ax[2]
 | a1  | as2  | as3  | : ay[2]
 | a2  | as4  | as5  | : az[2]
 | a3  | as6  | as7  | : pot[2]
 | a4  | as8  | as9  | : ax'[2]
 | a5  | as10 | as11 | : ay'[2]
 | a6  | as12 | as13 | : az'[2]
 | a7  | as14 | as15 | : pot'[2]
*/

void pzc_ForceKernel(const int * j_disp,
                     const EpiDev * epi,
                     const EpjDev * epj,
                     ForceDev * force,
                     const float eps2,
                     const int n_total){
    const int tid = get_tid();
    const int pid = get_pid();
    const int index_offset = pid * get_maxtid() + tid;
    const int index_base = get_maxtid()*get_maxpid();
    __asm__ volatile(
                     "f.mov f16 %0;\n\t"
                     :
                     : "w"(eps2)
                     : );
    for(int index=index_offset; index<n_total/4; index += index_base){
        //for(int index=index_offset; index<index_tail; index += index_base){
        // clear accumulators
        __asm__ volatile(
                         "f.movhi f0 0; \n\t"
                         "f.movhi f1 0; \n\t"
                         // "d.sub d0 d0 d0;\n\t"
                         "d.mov a0 d0;\n\t"
                         "d.mov a1 d0;\n\t"
                         "d.mov a2 d0;\n\t"
                         "d.mov a3 d0;\n\t"
                         "d.mov a4 d0;\n\t"
                         "d.mov a5 d0;\n\t"
                         "d.mov a6 d0;\n\t"
                         "d.mov a7 d0;\n\t");
        // set i-particles
        const EpiDev *ip0 = &epi[index*4+0];
        const EpiDev *ip1 = &epi[index*4+1];
        const EpiDev *ip2 = &epi[index*4+2];
        const EpiDev *ip3 = &epi[index*4+3];
        const int id_walk = ip0->id_walk;
        const int j_head = j_disp[id_walk];
        const int j_tail = j_disp[id_walk+1];
        __asm__ volatile(
                         "f.eld f4  %0 0;\n\t"
                         "f.eld f5  %1 0;\n\t"
                         "f.eld f26 %2 0;\n\t"
                         "f.eld f27 %3 0;\n\t"
                         "f.eld f6  %0 4;\n\t"
                         "f.eld f7  %1 4;\n\t"
                         "f.eld f28 %2 4;\n\t"
                         "f.eld f29 %3 4;\n\t"
                         "f.eld f8  %0 8;\n\t"
                         "f.eld f9  %1 8;\n\t"
                         "f.eld f30 %2 8;\n\t"
                         "f.eld f31 %3 8;\n\t"
                         :
                         : "r"(ip0), "r"(ip1), "r"(ip2), "r"(ip3)
                         : );
        // set constants
        __asm__ volatile(
                         "f.movhi f17 16256; \n\t" // 1.0f
                         "f.movhi f18 16128; \n\t" // 0.5f
                         "f.movhi f19 16064; \n\t" // 0.375f
                         );
        int ifuck = 0x5f3759df;
        // Loop body
        __asm__ volatile(
                         "d.eldd    d0 %0 0; \n\t"
                         "d.eldd    d1 %0 8; \n\t"
                         :
                         : "r"(&epj[j_head])
                         : );


        for(int j=j_head; j<j_tail; j++){
            /*
            int i0, i1;
            __asm__ volatile(
                             "i.mov r23 %0; \n \t"
                             "i.mov r24 %0; \n \t"
                             :
                             : "r"(i0), "r"(i1)
                             : );
            */
            __asm__ volatile(
                             // load jp
                             // "d.eldd  d0 %2 0; \n\t"
                             // "d.eldd  d1 %2 8; \n\t"
                             // "c.chgthread; \n\t"
                             // calc relative pos
                             "f.sub f10 f0 f4; \n\t"
                             "f.sub f11 f0 f5; \n\t" // dx = xj - xi
                             "f.sub f12 f1 f6; \n\t"
                             "f.sub f13 f1 f7; \n\t" // dy = yj - yi
                             "f.sub f14 f2 f8; \n\t"
                             "f.sub f15 f2 f9; \n\t" // dz = zj - zi
                             // "d.eldd  d0 %2 16; \n\t"
                             // calc r^2
                             "f.mul f24 f10 f10; \n\t"
                             "f.mul f25 f11 f11; \n\t" // t = dx * dx
                             "f.add f20 f16 f24; \n\t"
                             "f.add f21 f16 f25; \n\t" // r2 = eps2 + t
                             "f.mul f24 f12 f12; \n\t"
                             "f.mul f25 f13 f13; \n\t" // t = dy * dy
                             "f.add f20 f20 f24; \n\t"
                             "f.add f21 f21 f25; \n\t" // r2 = r2 + t
                             "f.mul f24 f14 f14; \n\t"
                             "f.mul f25 f15 f15; \n\t" // t = dz * dz
                             "f.add f20 f20 f24; \n\t"
                             "f.add f21 f21 f25; \n\t" // r2 = r2 + t
                             // fast inverse square root
                             /*
                             "f.rsqrt f22 f20; \n\t"
                             "f.rsqrt f23 f21; \n\t"
                             */
                             /*
                             "f.ftoimv %0 f20; \n\t"
                             "f.ftoimv %1 f21; \n\t"
                             "i.srai %0 %0 1; \n\t"
                             "i.srai %1 %1 1; \n\t"
                             "i.sub %0 %3 %0; \n\t"
                             "i.sub %1 %3 %1; \n\t"
                             "f.itofmv f22 %0; \n\t"
                             "f.itofmv f23 %1; \n\t"   // ri = rsqrta(r2)
                             */
                             "f.ftoimv r23 f20; \n\t"
                             "f.ftoimv r24 f21; \n\t"
                             "i.srai r23 r23 1; \n\t"
                             "i.srai r24 r24 1; \n\t"
                             "i.sub r23 %1 r23; \n\t"
                             "i.sub r24 %1 r24; \n\t"
                             "f.itofmv f22 r23; \n\t"
                             "f.itofmv f23 r24; \n\t"   // ri = rsqrta(r2)

                             // convergence
                             "f.mul f24 f22 f22; \n\t"
                             "f.mul f25 f23 f23; \n\t" // t = ri*ri
                             "f.mul f20 f24 f20; \n\t"
                             "f.mul f21 f25 f21; \n\t" // t = t * r2
                             "f.sub f20 f17 f20; \n\t"
                             "f.sub f21 f17 f21; \n\t" // h = 1.0f - t
                             "f.mul f24 f19 f20; \n\t"
                             "f.mul f25 f19 f21; \n\t" // p = 0.375 * h
                             "f.add f24 f18 f24; \n\t"
                             "f.add f25 f18 f25; \n\t" // p = 0.5f + p
                             "f.mul f24 f20 f24; \n\t"
                             "f.mul f25 f21 f25; \n\t" // p = h * p
                             "f.add f24 f17 f24; \n\t"
                             "f.add f25 f17 f25; \n\t" // p = 1.0f + p
                             "f.mul f22 f24 f22; \n\t"
                             "f.mul f23 f25 f23; \n\t" // ri = p * ri

                             // force
                             "f.mul f20 f22 f22; \n\t"
                             "f.mul f21 f23 f23; \n\t" // ri2 = ri * ri
                             "f.mul f22 f3 f22; \n\t"
                             "f.mul f23 f3 f23; \n\t" // mri = mj * ri
                             // "d.eldd  d1 %2 24; \n\t"
                             "f.mad as6 f17 f22 as6 ;\n\t"
                             "f.mad as7 f17 f23 as7 ;\n\t" // pot = 1.0f * mri + pot
                             "f.mul f22 f20 f22; \n\t"
                             "f.mul f23 f21 f23; \n\t" // mri3 = ri2 * mri
                             // accumulate

                             "f.mad as0 f22 f10 as0 ; \n\t"
                             "f.mad as1 f23 f11 as1 ; \n\t" // ax += mri3 * dx
                             "f.mad as2 f22 f12 as2 ; \n\t"
                             "f.mad as3 f23 f13 as3 ; \n\t" // ay += mri3 * dy
                             "f.mad as4 f22 f14 as4 ; \n\t"
                             "f.mad as5 f23 f15 as5 ; \n\t" // az += mri3 * dz

                             // calc relative pos
                             "f.sub f10 f0 f26; \n\t"
                             "f.sub f11 f0 f27; \n\t" // dx' = xj - xi'
                               "f.eld  f0 %0 16; \n\t" // read next jp
                             "f.sub f12 f1 f28; \n\t"
                             "f.sub f13 f1 f29; \n\t" // dy' = yj - yi'
                               "f.eld  f1 %0 20; \n\t"
                             "f.sub f14 f2 f30; \n\t"
                             "f.sub f15 f2 f31; \n\t" // dz' = zj - zi'
                               "f.eld  f2 %0 24; \n\t"
                             // calc r^2
                             "f.mul f24 f10 f10; \n\t"
                             "f.mul f25 f11 f11; \n\t" // t = dx * dx
                             "f.add f20 f16 f24; \n\t"
                             "f.add f21 f16 f25; \n\t" // r2 = eps2 + t
                             "f.mul f24 f12 f12; \n\t"
                             "f.mul f25 f13 f13; \n\t" // t = dy * dy
                             "f.add f20 f20 f24; \n\t"
                             "f.add f21 f21 f25; \n\t" // r2 = r2 + t
                             "f.mul f24 f14 f14; \n\t"
                             "f.mul f25 f15 f15; \n\t" // t = dz * dz
                             "f.add f20 f20 f24; \n\t"
                             "f.add f21 f21 f25; \n\t" // r2 = r2 + t
                             // fast inverse square root
                             /*
                             "f.rsqrt f22 f20; \n\t"
                             "f.rsqrt f23 f21; \n\t"
                             */
                             /*
                             "f.ftoimv %0 f20; \n\t"
                             "f.ftoimv %1 f21; \n\t"
                             "i.srai %0 %0 1; \n\t"
                             "i.srai %1 %1 1; \n\t"
                             "i.sub %0 %3 %0; \n\t"
                             "i.sub %1 %3 %1; \n\t"
                             "f.itofmv f22 %0; \n\t"
                             "f.itofmv f23 %1; \n\t"   // ri = rsqrta(r2)
                             */
                             "f.ftoimv r23 f20; \n\t"
                             "f.ftoimv r24 f21; \n\t"
                             "i.srai r23 r23 1; \n\t"
                             "i.srai r24 r24 1; \n\t"
                             "i.sub r23 %1 r23; \n\t"
                             "i.sub r24 %1 r24; \n\t"
                             "f.itofmv f22 r23; \n\t"
                             "f.itofmv f23 r24; \n\t"   // ri = rsqrta(r2)

                             // convergence
                             "f.mul f24 f22 f22; \n\t"
                             "f.mul f25 f23 f23; \n\t" // t = ri*ri
                             "f.mul f20 f24 f20; \n\t"
                             "f.mul f21 f25 f21; \n\t" // t = t * r2
                             "f.sub f20 f17 f20; \n\t"
                             "f.sub f21 f17 f21; \n\t" // h = 1.0f - t
                             "f.mul f24 f19 f20; \n\t"
                             "f.mul f25 f19 f21; \n\t" // p = 0.375 * h
                             "f.add f24 f18 f24; \n\t"
                             "f.add f25 f18 f25; \n\t" // p = 0.5f + p
                             "f.mul f24 f20 f24; \n\t"
                             "f.mul f25 f21 f25; \n\t" // p = h * p
                             "f.add f24 f17 f24; \n\t"
                             "f.add f25 f17 f25; \n\t" // p = 1.0f + p
                             "f.mul f22 f24 f22; \n\t"
                             "f.mul f23 f25 f23; \n\t" // ri = p * ri

                             // force
                             "f.mul f20 f22 f22; \n\t"
                             "f.mul f21 f23 f23; \n\t" // ri2 = ri * ri
                             "f.mul f22 f3 f22; \n\t"
                             "f.mul f23 f3 f23; \n\t" // mri = mj * ri
                               "f.eld  f3 %0 28; \n\t"
                             "f.mad as14 f17 f22 as14 ;\n\t"
                             "f.mad as15 f17 f23 as15 ;\n\t" // pot = 1.0f * mri + pot
                             "f.mul f22 f20 f22; \n\t"
                             "f.mul f23 f21 f23; \n\t" // mri3 = ri2 * mri
                             // accumulate

                             "f.mad as8  f22 f10 as8  ; \n\t"
                             "f.mad as9  f23 f11 as9  ; \n\t" // ax' += mri3 * dx'
                             "f.mad as10 f22 f12 as10 ; \n\t"
                             "f.mad as11 f23 f13 as11 ; \n\t" // ay '+= mri3 * dy'
                             "f.mad as12 f22 f14 as12 ; \n\t"
                             "f.mad as13 f23 f15 as13 ; \n\t" // az' += mri3 * dz'
                             : 
                             : "r"(&epj[j]), "r"(ifuck)
                             : );
            chgthread();
            //}
        } // for(j)

        __asm__ volatile(
                         "f.movhi f17 0;\n\t" // 0.0f
                         "f.msub as6 f17 f17 as6 ;\n\t"
                         "f.msub as7 f17 f17 as7 ;\n\t" // pot = 0.0f * 0.0f - pot
                         "f.msub as14 f17 f17 as14 ;\n\t"
                         "f.msub as15 f17 f17 as15 ;\n\t" // pot' = 0.0f * 0.0f - pot

                         "d.mov d0 a0;\n\t"
                         "d.mov d1 a1;\n\t"
                         "d.mov d2 a2;\n\t"
                         "d.mov d3 a3;\n\t"
                         "d.mov d4 a4;\n\t"
                         "d.mov d5 a5;\n\t"
                         "d.mov d6 a6;\n\t"
                         "d.mov d7 a7;\n\t"

                         /*
                           "f.movhi f0 16128; \n\t" // debug
                           "f.movhi f2 16256; \n\t" // debug
                           "f.movhi f4 16384; \n\t" // debug
                           "f.movhi f6 16512; \n\t" // debug
                         */
                         "f.esw %0  0 f0; \n\t"
                         "f.esw %0  4 f2; \n\t"
                         "f.esw %0  8 f4; \n\t"
                         "f.esw %0 12 f6; \n\t"
                         "f.esw %1  0 f1; \n\t"
                         "f.esw %1  4 f3; \n\t"
                         "f.esw %1  8 f5; \n\t"
                         "f.esw %1 12 f7; \n\t"
                         "f.esw %2  0 f8;  \n\t"
                         "f.esw %2  4 f10; \n\t"
                         "f.esw %2  8 f12; \n\t"
                         "f.esw %2 12 f14; \n\t"
                         "f.esw %3  0 f9;  \n\t"
                         "f.esw %3  4 f11; \n\t"
                         "f.esw %3  8 f13; \n\t"
                         "f.esw %3 12 f15; \n\t"
                         :
                         : "r"(&force[index*4+0]), "r"(&force[index*4+1])
                           , "r"(&force[index*4+2]), "r"(&force[index*4+3])
                         : );
    } // for(i)
    flush();
}

#elif 1

static inline 
float fast_app(float x){
    union{
        float f;
        int   i;
    } u;
    u.f = x;
    u.i = 0x5f3759df - (u.i >> 1);
    return u.f;
}

static inline 
float err_rsqrt(float x, float y){
    return 1.0f - x*(y*y);
}

static inline 
float conv_2nd(float x, float y){
    float h = err_rsqrt(x, y);
    float p = 1.0f + h * 0.5f;
    return y * p;
}

static inline 
float conv_3rd(float x, float y){
	float h = err_rsqrt(x, y);
#if 1
	float p = 1.0f + h * (0.5f + h * 0.375f);
	return y * p;
#else
	float p = float(3./8.) * h * (float(7./3.) - x*(y*y));
	return y + p*y;
#endif
}

float pzc_rsqrt(float x){
    float y = fast_app(x); // 1sfhift + 1add
    y = conv_3rd(x,y); // 1sfhift + 1add + 2mul + 3mad
    return y; 
}

/*
// i*2
void pzc_ForceKernel(const int * j_disp,
                     const EpiDev * epi,
                     const EpjDev * epj,
                     ForceDev * force,
                     const float eps2,
                     const int n_total){
    const int tid = get_tid();
    const int pid = get_pid();
    const int index_offset = pid * get_maxtid() + tid;
    const int index_base = get_maxtid()*get_maxpid();
    for(int index=index_offset; index<n_total/2; index += index_base){
        float2 ax, ay, az, pot;
        ax = ay = az = pot = 0.0;
        const EpiDev & ip0 = epi[index*2+0];
        const EpiDev & ip1 = epi[index*2+1];
        const int id_walk = ip0.id_walk;
        const int j_head = j_disp[id_walk];
        const int j_tail = j_disp[id_walk+1];
        register float2 xi = make_float2(ip0.px, ip1.px); 
        register float2 yi = make_float2(ip0.py, ip1.py);
        register float2 zi = make_float2(ip0.pz, ip1.pz);
        float2 eps22 = make_float2(eps2, eps2);
        for(int j=j_head; j<j_tail; j++){
            const EpjDev & jp = epj[j];
            const float2 mj = make_float2(epj[j].mass, epj[j].mass);
            const float2 xj = make_float2(epj[j].px, epj[j].px); 
            const float2 yj = make_float2(epj[j].py, epj[j].py);
            const float2 zj = make_float2(epj[j].pz, epj[j].pz);
            const float2 dx = xj - xi;
            const float2 dy = yj - yi;
            const float2 dz = zj - zi; // 3add
            const float2 r2 = ((eps2 + dx*dx) + dy*dy) + dz*dz;
#if 1
            const float2 r_inv = make_float2( pzc_rsqrt(r2.x), pzc_rsqrt(r2.y)); // 3add + 3madd + 1rsqrt
#else
            const float2 r_inv = rsqrt(r2); // 3add + 3madd + 1rsqrt
#endif
            const float2 pij = mj * r_inv;
            const float2 r2_inv = r_inv * r_inv; 
            const float2 pij_r3_inv = pij * r2_inv; // 3add + 3madd + 1rsqrt + 3mul
            pot -= pij;
            ax += pij_r3_inv * dx;
            ay += pij_r3_inv * dy; 
            az += pij_r3_inv * dz;  // 4add + 6madd + 1rsqrt + 3mul (rsqrt=10: op=29)
        }
        force[index*2+0].pot = pot.x;
        force[index*2+0].ax  = ax.x;
        force[index*2+0].ay  = ay.x;
        force[index*2+0].az  = az.x;
        force[index*2+1].pot = pot.y;
        force[index*2+1].ax  = ax.y;
        force[index*2+1].ay  = ay.y;
        force[index*2+1].az  = az.y;
    }
    flush();
}
*/

// i*4
void pzc_ForceKernel(const int * j_disp,
                     const EpiDev * epi,
                     const EpjDev * epj,
                     ForceDev * force,
                     const float eps2,
                     const int n_total){
    const int tid = get_tid();
    const int pid = get_pid();
    const int index_offset = pid * get_maxtid() + tid;
    const int index_base = get_maxtid()*get_maxpid();
    for(int index=index_offset; index<n_total/4; index += index_base){
        float2 ax0, ay0, az0, pot0, ax1, ay1, az1, pot1;
        ax0 = ay0 = az0 = pot0 = ax1 = ay1 = az1 = pot1 = 0.0;
        const EpiDev & ip0 = epi[index*4+0];
        const EpiDev & ip1 = epi[index*4+1];
        const EpiDev & ip2 = epi[index*4+2];
        const EpiDev & ip3 = epi[index*4+3];
        const int id_walk = ip0.id_walk;
        const int j_head = j_disp[id_walk];
        const int j_tail = j_disp[id_walk+1];
        register float2 xi0 = make_float2(ip0.px, ip1.px); 
        register float2 yi0 = make_float2(ip0.py, ip1.py);
        register float2 zi0 = make_float2(ip0.pz, ip1.pz);
        register float2 xi1 = make_float2(ip2.px, ip3.px); 
        register float2 yi1 = make_float2(ip2.py, ip3.py);
        register float2 zi1 = make_float2(ip2.pz, ip3.pz);
        float2 eps22 = make_float2(eps2, eps2);
        for(int j=j_head; j<j_tail; j++){
            const EpjDev & jp = epj[j];
            const float2 mj = make_float2(epj[j].mass, epj[j].mass);
            const float2 xj = make_float2(epj[j].px, epj[j].px); 
            const float2 yj = make_float2(epj[j].py, epj[j].py);
            const float2 zj = make_float2(epj[j].pz, epj[j].pz);
            const float2 dx0 = xj - xi0;
            const float2 dy0 = yj - yi0;
            const float2 dz0 = zj - zi0; // 3add
            const float2 r20 = ((eps2 + dx0*dx0) + dy0*dy0) + dz0*dz0;
            const float2 dx1 = xj - xi1;
            const float2 dy1 = yj - yi1;
            const float2 dz1 = zj - zi1; // 3add
            const float2 r21 = ((eps2 + dx1*dx1) + dy1*dy1) + dz1*dz1;
#if 0
            const float2 r_inv0 = make_float2( pzc_rsqrt(r20.x), pzc_rsqrt(r20.y)); // 3add + 3madd + 1rsqrt
            const float2 r_inv1 = make_float2( pzc_rsqrt(r21.x), pzc_rsqrt(r21.y)); // 3add + 3madd + 1rsqrt
#else
            const float2 r_inv0 = rsqrt(r20); // 3add + 3madd + 1rsqrt
            const float2 r_inv1 = rsqrt(r21); // 3add + 3madd + 1rsqrt
#endif
            const float2 pij0 = mj * r_inv0;
            const float2 r2_inv0 = r_inv0 * r_inv0; 
            const float2 pij_r3_inv0 = pij0 * r2_inv0; // 3add + 3madd + 1rsqrt + 3mul
            pot0 -= pij0;
            ax0 += pij_r3_inv0 * dx0;
            ay0 += pij_r3_inv0 * dy0; 
            az0 += pij_r3_inv0 * dz0;  // 4add + 6madd + 1rsqrt + 3mul (rsqrt=10: op=29)
            const float2 pij1 = mj * r_inv1;
            const float2 r2_inv1 = r_inv1 * r_inv1; 
            const float2 pij_r3_inv1 = pij1 * r2_inv1; // 3add + 3madd + 1rsqrt + 3mul
            pot1 -= pij1;
            ax1 += pij_r3_inv1 * dx1;
            ay1 += pij_r3_inv1 * dy1; 
            az1 += pij_r3_inv1 * dz1;  // 4add + 6madd + 1rsqrt + 3mul (rsqrt=10: op=29)
        }
        force[index*4+0].pot = pot0.x;
        force[index*4+0].ax  = ax0.x;
        force[index*4+0].ay  = ay0.x;
        force[index*4+0].az  = az0.x;
        force[index*4+1].pot = pot0.y;
        force[index*4+1].ax  = ax0.y;
        force[index*4+1].ay  = ay0.y;
        force[index*4+1].az  = az0.y;
        force[index*4+2].pot = pot1.x;
        force[index*4+2].ax  = ax1.x;
        force[index*4+2].ay  = ay1.x;
        force[index*4+2].az  = az1.x;
        force[index*4+3].pot = pot1.y;
        force[index*4+3].ax  = ax1.y;
        force[index*4+3].ay  = ay1.y;
        force[index*4+3].az  = az1.y;
    }
    flush();
}


/*
void pzc_ForceKernel(const EpiDev * epi,
                     const EpjDev * epj,
                     ForceDev * force,
                     const float eps2,
                     const int n_total){
    const int tid = get_tid();
    const int pid = get_pid();
    const int index_offset = pid * get_maxtid() + tid;
    const int index_base = get_maxtid()*get_maxpid();
    for(int index=index_offset; index<n_total/2; index += index_base){
        float2 ax, ay, az, pot;
        ax = ay = az = pot = 0.0;
        const EpiDev & ip0 = epi[index*2+0];
        const EpiDev & ip1 = epi[index*2+1];
        register float2 xi = make_float2(ip0.px, ip1.px); 
        register float2 yi = make_float2(ip0.py, ip1.py);
        register float2 zi = make_float2(ip0.pz, ip1.pz);
        float2 eps22 = make_float2(eps2, eps2);
        for(int j=0; j<n_total; j++){
            const EpjDev & jp = epj[j];
            const float2 mj = make_float2(epj[j].mass, epj[j].mass);
            const float2 xj = make_float2(epj[j].px, epj[j].px); 
            const float2 yj = make_float2(epj[j].py, epj[j].py);
            const float2 zj = make_float2(epj[j].pz, epj[j].pz);
            const float2 dx = xj - xi;
            const float2 dy = yj - yi;
            const float2 dz = zj - zi; // 3add
            const float2 r2 = ((eps2 + dx*dx) + dy*dy) + dz*dz;
#if 1
            const float2 r_inv = make_float2( pzc_rsqrt(r2.x), pzc_rsqrt(r2.y)); // 3add + 3madd + 1rsqrt
#else
            const float2 r_inv = rsqrt(r2); // 3add + 3madd + 1rsqrt
#endif
            const float2 pij = mj * r_inv;
            const float2 r2_inv = r_inv * r_inv; 
            const float2 pij_r3_inv = pij * r2_inv; // 3add + 3madd + 1rsqrt + 3mul
            pot -= pij;
            ax += pij_r3_inv * dx;
            ay += pij_r3_inv * dy; 
            az += pij_r3_inv * dz;  // 4add + 6madd + 1rsqrt + 3mul (rsqrt=10: op=29)
        }
        force[index*2+0].pot = pot.x;
        force[index*2+0].ax  = ax.x;
        force[index*2+0].ay  = ay.x;
        force[index*2+0].az  = az.x;
        force[index*2+1].pot = pot.y;
        force[index*2+1].ax  = ax.y;
        force[index*2+1].ay  = ay.y;
        force[index*2+1].az  = az.y;
    }
    flush();
}
*/

#else

void pzc_ForceKernel(const int * j_disp,
                     const EpiDev * epi,
                     const EpjDev * epj,
                     ForceDev * force,
                     const float eps2,
                     const int n_total){
    const int tid = get_tid();
    const int pid = get_pid();
    const int index_offset = pid * get_maxtid() + tid;
    const int index_base = get_maxtid()*get_maxpid();
    for(int index=index_offset; index<n_total; index += index_base){
        float ax, ay, az, pot;
        ax = ay = az = pot = 0.0;
        const EpiDev & ip = epi[index];
        const int id_walk = ip.id_walk;
        const int j_head = j_disp[id_walk];
        const int j_tail = j_disp[id_walk+1];
        for(int j=j_head; j<j_tail; j++){
            const EpjDev & jp = epj[j];
            const float dx = jp.px - ip.px;
            const float dy = jp.py - ip.py;
            const float dz = jp.pz - ip.pz;
            const float r2 = ((eps2 + dx*dx) + dy*dy) + dz*dz;
            const float r_inv = rsqrt(r2);
            const float pij = jp.mass * r_inv;
            const float r2_inv = r_inv * r_inv; 
            const float pij_r3_inv = pij * r2_inv; 
            pot -= pij;
            ax += pij_r3_inv * dx;
            ay += pij_r3_inv * dy; 
            az += pij_r3_inv * dz;
        }
        force[index].pot = pot;
        force[index].ax = ax;
        force[index].ay = ay;
        force[index].az = az;
    }
    flush();
}
#endif
