In this section, we present a complete user code for the gravitational
$N$-body problem with the open boundary condition, to illustrate how a
user write an application program using FDPS.  The gravitational
interaction is handled as ``long-range'' type in FDPS. Therefore, we
need to provide the data type and interaction calculation functions
for superparticles. In order to keep the sample code short, we use the
center-of-mass approximation and use the same data class and
interaction function for real particles and superparticles.


For the gravitational
$N$-body problem, the physical quantity vector $\myvec{u}_i$ and interaction functions
$\myvec{f}$, $\myvec{f'}$, and $\myvec{g}$ are given by:
%\begin{align}
\begin{eqnarray}
  \myvec{u}_i &=& (\myvec{r}_i,
  \myvec{v}_i,m_i), \label{eq:PhysicalVectorNbody} \\
%%  
  \myvec{f} (\myvec{u}_i, \myvec{u}_j) &=& \frac{Gm_j \left(
    \myvec{r}_j - \myvec{r}_i \right)}{ \left( |\myvec{r}_j -
    \myvec{r}_i|^2 + \epsilon_i^2
    \right)^{3/2}}, \label{eq:ParticleParticleNbody} \\
%%
  \myvec{f'} (\myvec{u}_i, \myvec{u'}_j) &=& \frac{Gm_j' \left(
    \myvec{r}_j - \myvec{r'}_i \right)}{ \left( |\myvec{r}_j -
    \myvec{r'}_i|^2 + \epsilon_i^2
    \right)^{3/2}}, \label{eq:ParticleSuperparticleNbody} \\
%%
  \myvec{g}(\myvec{F},\myvec{u}_i)  &=& (\myvec{v}_i,\myvec{F},0), \\
  \myvec{F} &=& \sum_j^{N_{\mathrm{J},i}}
  \myvec{f}(\myvec{u}_i,\myvec{u}_j) + \sum_{j'}^{N_{\mathrm{S},i}}
  \myvec{f'}(\myvec{u}_i,\myvec{u'}_{j'}), \myvec{u}_i,
\label{eq:ConversionNbody}
%\end{align}
\end{eqnarray}
where $m_i$, $\myvec{r}_i$, $\myvec{v}_i$, and $\epsilon_i$ are, the
mass, position, velocity, and gravitational softening of particle $i$,
$m_j'$ and $\myvec{r'}_j$ are, the mass and position of a
superparticle $j$, and $G$ is the gravitational constant.  Note that
the shapes of the functions $\myvec{f}$ and $\myvec{f'}$ are the same.

Listing~\ref{code:samplecode} shows the complete code which can be
compiled and run, not only on a single-core machine but also
massively-parallel, distributed-memory machines such as the  K
computer. The total number of lines is 117.

\input{sample_src.tex}

In the following we describe how this sample code works.  It consists
of four parts: the declaration to use FDPS (lines 1 and 2), the
definition of the particle (the vector $\myvec{u}_i$) (lines 4 to 35),
the definition of the gravitational force (the functions $\myvec{f}$
and $\myvec{f'}$) (lines 37 to 61), and the actual user program.  The
actual user program consists of a main routine and functions which
call library functions of FDPS (lines 63 to line 117). In the
following, we discuss each of them.



In order to use FDPS, the user program should
include the header file ``particle\_simulator.hpp''.
All functionalities of  the standard FDPS library are
implemented  as the header source library, since they are 
template libraries which need to receive particle class and
interaction functions.  FDPS data types and functions are in  the namespace
``PS''. In this sample program, we declare ``PS''  as the default
namespace to simplify the code. In this sample, however, we did not
omit ``PS'' for FDPS functions and class templates to show that they
come from FDPS.

FDPS defines several data types. \texttt{F32/F64} are data types of
32-bit and 64-bit floating points. \texttt{S32} is the data type of
32-bit signed integer.
\texttt{F64vec} is the class of a vector consisting of three 64-bit
floating points. This class provides several operators, such as the
addition, subtraction and the inner product indicated by ``$*$''.  It
is not necessary to use these data types in the user program, but some
of the functions the user should provide these data types for the
return value.


In the second part, the particle data type, ({\it i.e.} the vector
$\myvec{u}_i$) is defined as class \texttt{Nbody}. It has the
following member variables: \texttt{mass} ($m_i$), \texttt{eps}
($\epsilon_i$), \texttt{pos} ($\myvec{r}_i$), \texttt{vel}
($\myvec{v}_i$), and \texttt{acc} ($d\myvec{v}_i/dt$). Although the
member variable \texttt{acc} does not appear in
equation~(\ref{eq:PhysicalVectorNbody}) -- (\ref{eq:ConversionNbody}),
we need this variable to store the result of the gravitational force
calculation. A particle class for FDPS must provide public member
functions \texttt{getPos}, \texttt{copyFromFP},
\texttt{copyFromForce} and \texttt{clear} in these names, so that the internal functions
of FDPS can access the data within the particle class.  For the name
of the particle class itself and the names of the member variables, a
user can use whatever names allowed by the C++ syntax.  The member
functions \texttt{predict} and \texttt{correct} are used to integrate
the orbits of particles. These are not related to FDPS.  Since the
interaction is pure $1/r$ type, the construction method for
superparticles provided by FDPS can be used and they are not shown
here.

In the third part, the interaction functions $\myvec{f}$ and
$\myvec{f'}$ are defined. In this example, actually they are the same,
except for the class definition for $j$-particles. Therefore, this
argument is given as an argument with the template data
type \texttt{TPJ}, so that a single source code can be used to
generate two functions.  The interaction function used in FDPS should
have the following five arguments. The first argument \texttt{ip} is
the pointer to the array of $i$-particles which receive the
interaction. The second argument \texttt{ni} is the number of
$i$-particles. The third argument \texttt{jp} is the pointer to the
array of $j$-particles or superparticles which exert the
interaction. The fourth argument \texttt{nj} is the number of
$j$-particles or super-particles. The fifth argument \texttt{force} is
the pointer to the array of variables of a user-defined class to which
the calculated interactions on $i$-particles can be stored. In this
example, we used the particle class itself, but this can be another
class or a simple array.

In this example, the interaction function is a function object
declared as a \texttt{struct}, with the only member
function \texttt{operator ()}. FDPS can also accept a function pointer
for the interaction function, which would look a bit more familiar to
most readers.  In this example, the interaction is calculated through
a simple double loop. In order to achieve high efficiency, this part
should be replaced by a code optimized for specific architectures. In
other words, a user needs to optimize just this single function to
achieve very high efficiency.


In the fourth part, the main routine and user-defined functions are
defined.  In the following, we describe the main routine in detail,
and briefly discuss other functions. The main routine consists of the
following seven steps:
\begin{enumerate}
\item Initialize FDPS (line 92). \label{proc:init}
\item Set simulation time and timestep (lines 93 to 95). \label{proc:literal}
\item Create and initialize objects of FDPS classes (lines 96 to 102). \label{proc:construct}
\item Read in particle data from a file (line 103). \label{proc:input}
\item Calculate the gravitational forces on all the particles at the
  initial time (lines 104 to 106). \label{proc:calcinteraction}
\item Integrate the orbits of all the particles with Leap-Frog method
  (lines 107 to 114). \label{proc:integration}
\item Finish the use of  FDPS (line 115). \label{proc:fin}
\end{enumerate}

In the following, we describe  steps~\ref{proc:init},
\ref{proc:construct}, \ref{proc:input}, \ref{proc:calcinteraction},
and \ref{proc:fin}, and skip steps~\ref{proc:literal}
and \ref{proc:integration}.  In step~\ref{proc:literal}, we do not
call FDPS libraries.  Although we call FDPS libraries in
step~\ref{proc:integration}, the usage is the same as in
step~\ref{proc:calcinteraction}.

In step~\ref{proc:init}, the FDPS function \texttt{Initialize} is
called. In this function, MPI and OpenMP libraries are initialized. If
neither of them are used, this function does nothing.  All functions
of FDPS must be called between this function and the
function \texttt{Finalize}.

In step~\ref{proc:construct}, we create and initialize three objects
of the FDPS classes:
\begin{itemize}
\item \texttt{dinfo}: An object of class \texttt{DomainInfo}. It is
  used for domain decomposition.

\item \texttt{ptcl}: An object of class template \texttt{ParticleSystem}.
It takes the user-defined particle class (in this
example, \texttt{Nbody}) as the template argument. From the user
program, this object looks as an array of $i$-particles.

\item \texttt{grav}: An object of  data type \texttt{Monopole} defined in
class template \texttt{TreeForForceLong}. This object is used for the
calculation of long-range interaction using the tree algorithm.  It
receives three user-defined classes as template arguments: the class
to store the calculated interaction, the class for $i$-particles and
the class for $j$-particles. In this example, all these three classes
are the same as the original class of particles.  It is possible to
define classes with minimal data for these purposes and use them here,
in order to optimize the cache usage. The data type \texttt{Monopole}
indicates that the center-of-mass approximation is used for
superparticles.
\end{itemize}

In step~\ref{proc:input}, the data of particles are read from a file
into the object \texttt{ptcl}, using  FDPS
function \texttt{readParticleAscii}. In this function, a member
function of class \texttt{Nbody}, \texttt{readAscii}, is called. Note
that the user can write and use his/her own I/O functions. In this case,
\texttt{readParticleAscii} is unnecessary.

In step~\ref{proc:calcinteraction}, the forces on all particles are
calculated through the function \texttt{calcGravAllAndWriteBack},
which is defined in lines 79 to 89. In this function,
steps~\ref{proc:decompose} to
\ref{proc:interaction} in section~\ref{sec:view} are performed. In
other words, all of the actual work of FDPS libraries to calculate
interaction between particles takes place here. For
step~\ref{proc:decompose}, \texttt{decomposeDomainAll}, a member
function of class \texttt{DomainInfo} is called. This function takes
the object
\texttt{ptcl} as an argument to use the positions of particles to
determine the domain decomposition.  Step~\ref{proc:exchange} is
performed in \texttt{exchangeParticle}, a member function of
class \texttt{ParticleSystem}. This function takes the
object \texttt{dinfo} as an argument and redistributes particles among
MPI processes.  Steps \ref{proc:interactionexchange}
and \ref{proc:interaction} are performed
in \texttt{calcForceAllAndWriteBack}, a member function of
class \texttt{TreeForForceLong}. This function takes the user-defined
function object \texttt{CalcGrav} as the first and second arguments,
and calculates particle-particle and particle-superparticle
interactions using them.

In step~\ref{proc:fin}, the FDPS function \texttt{Finalize} is
called. It calls the \texttt{MPI\_Finalize} function.

In this section, we have described in detail how a user program
written using FDPS looks like. As we stated earlier, this program can
be compiled with or without parallelization using MPI and/or OpenMP,
without any change in the user program. The executable parallelized
with MPI is generated by using an appropriate compiler with MPI
support and a compile-time flag.  Thus, a user need not worry about
complicated bookkeeping necessary for parallelization using MPI.
%
In the next section, we describe how FDPS provides a generic
framework which takes care of parallelization
and bookkeeping for particle-based simulations. 

% LocalWords:  monopole superparticle FDPS hpp namespace nd th vec Nbody eps dt
% LocalWords:  pos vel acc getPos getCharge copyFromFP copyFromForce readAscii
% LocalWords:  ip const ni jp TPJ nj MPI OpenMP DomainInfo dinfo subdomains
% LocalWords:  subdomain ParticleSystem ptcl TreeForForceLong readParticleAscii
% LocalWords:  calcGravAllAndWriteBack decomposeDomainAll exchangeParticle SIMD
% LocalWords:  calcForceAllAndWriteBack CalcGrav superparticles struct grav
% LocalWords:  parallelization parallelized timestep
