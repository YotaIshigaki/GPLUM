%================================
%   About this section ...
%================================
In this section, we describe the sample codes used in previous section (\S~\ref{sec:getting_started}) in more detail. Especially, the explanation will focus mainly on derived data types that users must define (hereafter, \textbf{user-defined types}) and how to use APIs of \describeForIF{\progLangName interface to} FDPS. \Eul{In order to avoid duplication of explanation, some matters are explained in \S~{\ref{subsec:how_to_use_Nbody_code}} only, where we explain the $N$-body sample code}. Therefore, we recommend users who are interested in SPH simulation only to read \S~\ref{subsec:how_to_use_Nbody_code}.

%======================
%   N-body code
%======================
\subsection{$N$-body simulation code}
\label{subsec:how_to_use_Nbody_code}

\subsubsection{Location of source files and file structure}
The source files of the sample code are in the directory \dirNameNbodySample.
\describeForEach{% for C++
The sample code consists of \path{user-defined.hpp} where user-defined types and interaction function are described, and \path{nbody.cpp} where the other parts of $N$-body simulation code are implemented. In addition to these, there is a Makefile for GCC, \path{Makefile}.  
}{% for Fortran
The sample code consists of \path{user_defined.F90} where user-defined types are described, and \path{f_main.F90} where the other parts of $N$-body simulation code are implemented. In addition to these, there are two Makefiles: \path{Makefile} (for GCC) and \path{Makefile.intel} (for Intel compilers).  
 }{% for C
 The sample code consists of \path{user_defined.h} where user-defined types are described, \path{user_defined.c} where interaction functions are described, and \path{c_main.c} where the other parts of $N$-body simulation code are implemented. In addition to these, there is a Makefile for GCC,  \path{Makefile}.  
 }

\subsubsection{User-defined types and user-defined functions}
In this section, we describe the details of \structures and \procedures that users must define when performing an $N$-body simulation with FDPS.

%-----------------------
%   FullParticle type
%-----------------------
\subsubsubsection{FullParticle type}
You must define a \textsf{FullParticle} type. \textsf{FullParticle} type should contain all physical quantities necessary for an $N$-body simulation. Listing~\ref{nbody_FP} shows the implementation of \textsf{FullParticle} type in our sample code (see \describeForEach{\texttt{user-defined.hpp}}{\texttt{user\_defined.F90}}{\texttt{user\_defined.h}}).

\ifCpp % for C++
\lstinputlisting[linerange={17-65},caption=FullParticle type,label=nbody_FP]{../../../../sample/c++/nbody/user-defined.hpp}
\endifCpp
\ifFtn % for Fortran
\lstinputlisting[linerange={14-24},caption=FullParticle type,label=nbody_FP]{../../../../sample/fortran/nbody/user_defined.F90}
\endifFtn
\ifC % for C
\lstinputlisting[linerange={7-18},caption=FullParticle type,label=nbody_FP]{../../../../sample/c/nbody/user_defined.h}
\endifC

\ifCpp % for C++
Note that \textsf{FullParticle} type is used as \textsf{EssentialParticleI} type, \textsf{EssentialParticleJ} type, and \textsf{Force} type in this sample code. \textsf{FullParticle} type must have member functions \texttt{copyfromFP()} and \texttt{copyFromForce()} to copy data. It should have member functions \texttt{getCharge()} (returns the particle mass),  \texttt{getPos()} (returns the particle position), and \texttt{setPos()} (sets the particle position). In this code, we also define member functions \texttt{writeAscii()} and \texttt{readAscii()}, which are necessary to use file I/O functions of FDPS. The member function \texttt{clear()} is also necessary, which zero-clear the acceleration and potential.
\endifCpp
\ifIF % for Fortran and C
When developing a simulation code with FDPS \progLangName interface, users must specify which user-defined type (\textsf{FullParticle}, \textsf{EssentialParticleI}, \textsf{EssentialParticleJ}, and \textsf{Force} types) a \structure corresponds to. In FDPS \progLangName interface, this is done by adding a \textbf{FDPS directive}, which is a \progLangName's comment text with a special format, to a \structure. Because \textsf{FullParticle} type is used as \textsf{EssentialParticleI} type, \textsf{EssentialParticleJ} type, and \textsf{Force type} in this sample code, a FDPS directive specifying that the \structure acts as any types of user-defined types is described:
\endifIF
\ifFtn % for Fortran
\begin{screen}
\begin{spverbatim}
type, public, bind(c) :: full_particle !$fdps FP,EPI,EPJ,Force
\end{spverbatim}
\end{screen}
\endifFtn
\ifC % for C
\begin{screen}
\begin{spverbatim}
typedef struct full_particle { //$fdps FP,EPI,EPJ,Force
\end{spverbatim}
\end{screen}
\endifC

\describeForIF{ % for Fortran and C
FDPS must know which member variable of \textsf{FullParticle} type corresponds to which necessary quantity, where \textbf{necessary quantities} are defined as the quantities that are necessary in any types of particle simulations (e.g. mass (or charge) and position of a particle), or that are necessary in particular types of particle simulations (e.g. size of a particle). This designation is also done by adding a comment text with a special format to each member variable. In this sample code, in order to specify that member variables \texttt{mass}, \texttt{pos}, \texttt{vel} correspond to mass, position, velocity of a particle, the following directives are described:
}
\ifFtn % for Fortran
\begin{screen}
\begin{spverbatim}
real(kind=c_double) :: mass !$fdps charge
type(fdps_f64vec) :: pos !$fdps position
type(fdps_f64vec) :: vel !$fdps velocity
\end{spverbatim}  
\end{screen}
Note that \texttt{velocity} in the directive \texttt{!\$fdps velocity} is a just reserved keyword and it does not alter the operation of FDPS at the present moment (hence, the designation is arbitrary).
\endifFtn
\ifC % for C
\begin{screen}
\begin{spverbatim}
double mass; //$fdps charge
fdps_f64vec pos; //$fdps position
fdps_f64vec vel; //$fdps velocity
\end{spverbatim}  
\end{screen}
Note that \texttt{velocity} in the directive \texttt{//\$fdps velocity} is a just reserved keyword and it does not alter the operation of FDPS at the present moment (hence, the designation is arbitrary).
\endifC
\describeForIF{ % for Fortran and C

FDPS copies data from \textsf{FullParticle} type to\textsf{EssentialParticleI} type and \textsf{EssentialParticleJ} type, or from \textsf{Force} type to \textsf{FullParticle} type. Users must describe FDPS directives that specify how to copy data. In this sample code, the following directives are described:
}
\ifFtn % for Fortran
\begin{screen}
\begin{spverbatim}
!$fdps copyFromForce full_particle (pot,pot) (acc,acc)
!$fdps copyFromFP full_particle (id,id) (mass,mass) (pos,pos)
\end{spverbatim}  
\end{screen}
\endifFtn
\ifC % for C
\begin{screen}
\begin{spverbatim}
//$fdps copyFromForce full_particle (pot,pot) (acc,acc)
//$fdps copyFromFP full_particle (id,id) (mass,mass) (pos,pos)
\end{spverbatim}  
\end{screen}
\endifC
\describeForIF{ % for Fortran and C
where the FDPS directive with the keyword \texttt{copyFromForce} specifies which member variable of \textsf{Force} type is copied to which member variable of \textsf{FullParticle} type. Users \Eul{\textbf{always have to}} describe this directive in \textsf{FullParticle} type. The other directive with the keyword \texttt{copyFromFP} specifies how to copy data from \textsf{FullParticle} type to \textsf{EssentialParticleI} type and \textsf{EssentialParticleJ} type. This directive \Eul{\textbf{must always}} be described in \textsf{EssentialParticleI} type and \textsf{EssentialParticleJ} type. It is described here because \textsf{FullParticle} type in this sample code acts as \textsf{EssentialParticleI} type and \textsf{EssentialParticleJ} type.

\textsf{FullParticle} type also acts as \textsf{Force} type in this code. There is a FDPS directive that users must describe in \textsf{Force} type. It is the directive that specifies how to reset or initialize member variables of \textsf{Force} type before the calculation of interactions. In this code, the following directive is described to direct FDPS to zero-clear member variables corresponding to acceleration and potential only.
}
\ifFtn % for Fortran
\begin{screen}
\begin{spverbatim}
!$fdps clear id=keep, mass=keep, pos=keep, vel=keep
\end{spverbatim}
\end{screen}
\endifFtn
\ifC % for C
\begin{screen}
\begin{spverbatim}
//$fdps clear id=keep, mass=keep, pos=keep, vel=keep
\end{spverbatim}
\end{screen}
\endifC
\describeForIF{ % for Fortran and C
where the syntax \texttt{\textit{mbr}=keep} to the right of the keyword \texttt{clear} is the syntax to direct FDPS not to change the value of member variable \textit{\texttt{mbr}}.

Further details about the format of FDPS directive can be found in the specification document of FDPS Fortran/C interface, \path{doc_specs_ftn_en.pdf}.
}

%-------------------
%   calcForceEpEp
%-------------------
\subsubsubsection{calcForceEpEp}
You must define an interaction function \textsf{calcForceEpEp} as \procedure in \progLangName. It should contain actual code for the calculation of interaction between particles. Listing~\ref{nbody_calcForceEpEp} shows the implementation of \textsf{calcForceEpEp} (see \describeForEach{\texttt{user-defined.hpp}}{\texttt{user\_defined.F90}}{\texttt{user\_defined.h}}).

\ifCpp % for C++
\lstinputlisting[linerange={162-186},caption=Function \textsf{calcForceEpEp},label=nbody_calcForceEpEp]{../../../../sample/c++/nbody/user-defined.hpp}
\endifCpp
\ifFtn % for Fortran
\lstinputlisting[linerange={245-292},caption=Function  \textsf{calcForceEpEp},label=nbody_calcForceEpEp]{../../../../sample/fortran/nbody/user_defined.F90}
\endifFtn
\ifC % for C
\lstinputlisting[linerange={85-120},caption=Function  \textsf{calcForceEpEp},label=nbody_calcForceEpEp]{../../../../sample/c/nbody/user_defined.c}
\endifC
\ifCpp % for C++
Here, we show the implementation for the case that the code is executed on CPUs without the Phantom-GRAPE library.

In this sample, we implemented \textsf{calcForceEpEp} using function template\footnote{Function template is, as the name suggests, template of function, in which we can use variables of general data types listed in the angle brackets of \texttt{templete <...>} to define function. This characteristic is very different from normal functions in which we must use variables of specific data types such as \texttt{int}, \texttt{double}, \texttt{struct foo}, etc. All of general data types used in a function template is replaced by specific data types at the compile-time because function template must be called with the template argument in which we must describe a list of specific data types.}. Its dummy arguments are an array of \textsf{EssentialParticleI} type, the number of \textsf{EssentialParticleI} type variables, an array of \textsf{EssentialParticleJ} type, the number of \textsf{EssentialParticleJ} type variables, an array of \textsf{Force} type.
\endifCpp
\ifIF % for Fortran and C
In this sample code, it is implemented as the \procedure \texttt{calc\_gravity\_ep\_ep}. Its dummy arguments are an array of \textsf{EssentialParticleI} type, the number of \textsf{EssentialParticleI} type variables, an array of \textsf{EssentialParticleJ} type, the number of \textsf{EssentialParticleJ} type variables, an array of \textsf{Force} type. Note that all the data types of the dummy arguments corresponding to user-defined types are \texttt{full\_particle} type because \textsf{FullParticle} type acts as the other types of user-defined types in this sample code.
\endifIF

%-------------------
%   calcForceEpSp
%-------------------
\ifIF % for Fortran and C
\subsubsubsection{calcForceEpSp}
You must defined an interaction function \textsf{calcForceEpSp} as \procedure in \progLangName. It should contain actual code for the calculation of interaction between a particle and a superparticle. Listing~\ref{nbody_calcForceEpSp} shows the implementation of \textsf{calcForceEpSp} (see \texttt{user\_defined.F90}).

\ifFtn % for Fortran
\lstinputlisting[linerange={295-332},caption=calcForceEpSp,label=nbody_calcForceEpSp]{../../../../sample/fortran/nbody/user_defined.F90}
\endifFtn
\ifC % for C
\lstinputlisting[linerange={122-157},caption= calcForceEpSp,label=nbody_calcForceEpSp]{../../../../sample/c/nbody/user_defined.c}
\endifC

In this sample code, it is implemented as the \procedure \texttt{calc\_gravity\_ep\_sp}. Its dummy arguments are an array of \textsf{EssentialParticleI} type, the number of \textsf{EssentialParticleI} type variables, an array of superparticle type, the number of superparticle type variables, an array of \textsf{Force} type. Note that the data types of \textsf{EssentialParticleI} type and \textsf{Force type} are \texttt{full\_particle} type because \textsf{FullParticle} type acts as these user-defined types in this sample code. Also note that the data type of superparticle type must be consistent with the type of a \textsf{Tree} object used in the calculation of interactions.
\endifIF

\subsubsection{The main body of the user program}
\label{subsubsec:nbody_sample_main_part}
\describeForCpp{% for C++
In this section, we describe the functions a user should write to implement gravitational $N$-body calculation using FDPS. The main function is described in the file \texttt{nbody.cpp}.
}
\describeForIF{% for Fortran and C
In this section, we describe the functions a user should write in a kind of \mainFunc, \mainFuncName, to implement gravitational $N$-body calculation using the FDPS \progLangName interface. The reason why we do not use the term \mainFunc\ clearly is as follows: If users use FDPS \progLangName interface, the user code must be written in the {\setnoko\Euc{\procedure}} \mainFuncName. Thus the user code dose not include the \mainFunc \describeForFtn{ or main program}. However, in practice, the \mainFuncName plays the same role as a \mainFunc. Thus here we use the term a kind of \mainFunc. The term \mainFunc is suitable for indicating the top level function of the user code. Hereafter, we call \mainFuncName the \mainFunc. The \mainFunc of this sample is written in \fileNameOfMainFunc.
}

\ifCpp % for C++
\subsubsubsection{Including the header file of FDPS}
To make the standard features of FDPS available, we must include header file  \texttt{particle\_simulator.hpp}.
\begin{lstlisting}[caption=Including header file \texttt{particle\_simulator.hpp}]
#include <particle_simulator.hpp>
\end{lstlisting}
\endifCpp
\ifFtn % for Fortran
\subsubsubsection{Creation of an object of type \texttt{fdps\_controller}}
In the FDPS Fortran interface, all APIs of FDPS are provided as member functions in the class \texttt{FDPS\_controller}. This class is defined in the module \texttt{fdps\_module} in \texttt{FDPS\_module.F90}. Thus, in order to use APIs, the user must create an object of type \texttt{FDPS\_controller}. In this sample, the object of type \texttt{FDPS\_controller},  \texttt{fdps\_ctrl}, is created in the main routine. Thus, in the following examples, APIs of FDPS are called as a member function of this object.

\begin{lstlisting}[caption=Creation of an object of type \texttt{fdps\_controller}]
subroutine f_main()
   use fdps_module
   implicit none
   !* Local variables
   type(fdps_controller) :: fdps_ctrl
    
   ! Do something
   
end subroutine f_main    
\end{lstlisting}

Note that the code shown above is an only necessary part from the sample code. 
\endifFtn
\ifC % for C
\subsubsubsection{Including the header file of FDPS C interface}
To make the standard features of FDPS available, we must include header file  \texttt{FDPS\_c\_if.h}.
\begin{lstlisting}[caption=Including header file \texttt{FDPS\_c\_if.h}]
#include "FDPS_c_if.h"
\end{lstlisting}
\endifC


\subsubsubsection{Initialization and Termination of FDPS}
First, users must initialize FDPS by the following code.
\ifCpp % for C++
\begin{lstlisting}[caption=Initialization of FDPS]
PS::Initialize(argc, argv);
\end{lstlisting}
\endifCpp
\ifFtn % for Fortran
\begin{lstlisting}[caption=Initialization of FDPS]
call fdps_ctrl%PS_Initialize()
\end{lstlisting}
\endifFtn
\ifC % for C
\begin{lstlisting}[caption=Initialization of FDPS]
fdps_initialize();
\end{lstlisting}
\endifC


Once started, FDPS should be terminated explicitly. In the sample code, FDPS should be terminated just before the termination of the program. To achieve this, user should write the following code at the end of the \mainFunc.
\ifCpp % for C++
\begin{lstlisting}[caption=Termination of FDPS]
PS::Finalize();
\end{lstlisting}
\endifCpp
\ifFtn % for Fortran
\begin{lstlisting}[caption=Termination of FDPS]
call fdps_ctrl%ps_finalize()
\end{lstlisting}
\endifFtn
\ifC % for C
\begin{lstlisting}[caption=Termination of FDPS]
fdps_finalize();
\end{lstlisting}
\endifC


\subsubsubsection{Creation and initialization of FDPS objects}
Once succeed the initialization, the user needs to create objects used to talk to FDPS. In this section, we describe how to create and initialize these objects.

\subsubsubsubsection{Creation of FDPS objects}
\ifCpp % for C++
In an $N$-body simulation, one needs to create objects of \textsf{ParticleSystem} type, \textsf{DomainInfo} type, and \textsf{TreeForForceLong} type (hereinafter, we call it \textsf{Tree} type for simplicity). The following is the code to create them (see the \mainFunc in \texttt{nbody.cpp}).
\begin{lstlisting}[caption=Creation of FDPS objects]
PS::DomainInfo dinfo;
PS::ParticleSystem<FPGrav> system_grav;
PS::TreeForForceLong<FPGrav, FPGrav, FPGrav>::Monopole tree_grav;
\end{lstlisting}
\endifCpp
\ifIF % for Fortran and C
In an $N$-body simulation, one needs to create objects of \textsf{ParticleSystem} type, \textsf{DomainInfo} type, and \textsf{Tree} type. In the \progLangName\ interface, these objects can be handled by using identification number contained in integral type variables. Thus, at the beginning, you should prepare integral type variables to contain the identification numbers. We will show an example bellow. These are written in the \mainFunc\ \fileNameOfMainFunc\ in the sample code.
\endifIF
\ifFtn % for Fortran
\begin{lstlisting}[caption=Creation of FDPS objects]
subroutine f_main()
   use fdps_module
   use user_defined_types
   implicit none
   !* Local variables
   integer :: psys_num,dinfo_num,tree_num
   
   !* Create FDPS objects
   call fdps_ctrl%create_dinfo(dinfo_num)
   call fdps_ctrl%create_psys(psys_num,'full_particle')
   call fdps_ctrl%create_tree(tree_num, &
                              "Long,full_particle,full_particle,full_particle,Monopole")

end subroutine f_main
\end{lstlisting}
\endifFtn
\ifC % for C
\begin{lstlisting}[caption=Creation of FDPS objects]
void c_main() {
   
    // Create and initialize dinfo object
    int dinfo_num;
    fdps_create_dinfo(&dinfo_num);
    // Create and initialize psys object
    int psys_num;
    fdps_create_psys(&psys_num,"full_particle");
    // Create and initialize tree object
    int tree_num;
    fdps_create_tree(&tree_num,
                     "Long,full_particle,full_particle,full_particle,Monopole");

}
\end{lstlisting}
\endifC
\describeForIF{% for Fortran and C
Here, the code shown is just a corresponding part of the sample code. As we can see above, to create the object of type \textsf{ParticleSystem}, you must give the string of the name of the derived data type corresponding to the type FullParticle. As in the case of type \textsf{ParticleSystem}, to create the object of type \textsf{Tree}, you must give the string which indicates the type of tree as an argument of the API. Note that, in both APIs, the name of the derived data type must be written in lower case.
}

\subsubsubsubsection{Initialization of \textsf{DomainInfo} object}
Once create the objects, user must initialize these objects. In this sample code, since the boundary condition is not periodic, users have only to call the API \describeForEach{initialize}{\texttt{init\_dinfo}}{\texttt{fdps\_init\_dinfo}} to initialize the objects.

\ifCpp % for C++
\begin{lstlisting}[caption=Initialization of \textsf{DomainInfo} object]
const PS::F32 coef_ema = 0.3;
dinfo.initialize(coef_ema);
\end{lstlisting}
\endifCpp
\ifFtn % for Fortran
\begin{lstlisting}[caption=Initialization of \textsf{DomainInfo} object]
call fdps_ctrl%init_dinfo(dinfo_num,coef_ema)
\end{lstlisting}
\endifFtn
\ifC % for C
\begin{lstlisting}[caption=Initialization of \textsf{DomainInfo} object]
fdps_init_dinfo(dinfo_num,coef_ema);
\end{lstlisting}
\endifC
Note that the \describeForEach{first}{second}{second} argument of API \describeForEach{\texttt{initialize}}{\texttt{init\_dinfo}}{\texttt{fdps\_init\_dinfo}} is a smoothing factor of an exponential moving average operation that is performed in the domain decomposition procedure. The definition of this factor is described in the specification of FDPS (see \S~9.1.2 in \path{doc_spec_cpp_en.pdf}).


\subsubsubsubsection{Initialization of \textsf{ParticleSystem} object}
Next, you must initialize a \textsf{ParticleSystem} object. This is done by calling the API \describeForEach{\texttt{initialize}}{\texttt{init\_psys}}{\texttt{fdps\_init\_psys}}.

\ifCpp % for C++
\begin{lstlisting}[caption=Initialization of \textsf{ParticleSystem} object]
system_grav.initialize();
\end{lstlisting}
\endifCpp
\ifFtn % for Fortran
\begin{lstlisting}[caption=Initialization of \textsf{ParticleSystem} object]
call fdps_ctrl%init_psys(psys_num)
\end{lstlisting}
\endifFtn
\ifC % for C
\begin{lstlisting}[caption=Initialization of \textsf{ParticleSystem} object]
fdps_init_psys(psys_num);
\end{lstlisting}
\endifC


\subsubsubsubsection{Initialization of \textsf{Tree} object}
Next, we must initialize a \textsf{Tree} object. The initialization of a \textsf{Tree} object is done by calling the API \initTree . This API should be given an integer for determining the initial sizes of internally-used arrays. A number comparable to the number of local particles is enough. In this sample, we set the number of local particles (\texttt{n\_loc}):

\ifCpp % for C++
\begin{lstlisting}[caption=Initialization of \textsf{Tree} object]
tree_grav.initialize(n_loc, theta, n_leaf_limit, n_group_limit);
\end{lstlisting}
\endifCpp
\ifFtn % for Fortran
\begin{lstlisting}[caption=Initialization of \textsf{Tree} object]
call fdps_ctrl%init_tree(tree_num,n_loc,theta, &
                         n_leaf_limit,n_group_limit)
\end{lstlisting}
\endifFtn
\ifC % for C
\begin{lstlisting}[caption=Initialization of \textsf{Tree} object]
fdps_init_tree(tree_num,n_loc,theta,
               n_leaf_limit,n_group_limit);
\end{lstlisting}
\endifC

\describeForEach{% for C++
The \texttt{initialize} method has three optional arguments. Here, we pass these arguments explicitly.
}{% for Fortran
The \texttt{initialize} method has three optional arguments. Here, we pass these arguments explicitly.
}{% for C
The definitions of the 3rd or later arguments are as follows.
}
\begin{itemize}[leftmargin=*,topsep=-1ex,parsep=-1ex]
\item \texttt{theta} --- the so-called opening angle criterion for the tree method.
\item \texttt{n\_leaf\_limit} --- the upper limit for the number of particles in the leaf nodes.
\item \texttt{n\_group\_limit} --- the upper limit for the number of particles with which the particles use the same interaction list for the force calculation.
\end{itemize}


\ifIF % for Fortran and C
\subsubsubsection{Initialization of particle data}
\label{s3sec:nbody_initialize_ptcl_data}
To initialize particle data, users must give the particle data to the \textsf{ParticleSystem} object. This can be done by using APIs \describeForEach{}{\texttt{set\_nptcl\_loc}}{\texttt{fdps\_set\_nptcl\_loc}} and \describeForEach{}{\texttt{get\_psys\_fptr}}{\texttt{get\_psys\_cptr}} as follows:

\ifFtn % for Fortran
\begin{lstlisting}[caption=Initialization of particle data]
subroutine foo(fdps_ctrl,psys_num)
   use fdps_vector
   use fdps_module
   use user_defined_types
   implicit none
   type(fdps_controller), intent(IN) :: fdps_ctrl
   integer, intent(IN) :: psys_num
   !* Local variables
   integer :: i,nptcl_loc
   type(full_particle), dimension(:), pointer :: ptcl

   !* Set # of local particles
   call fdps_ctrl%set_nptcl_loc(psys_num,nptcl_loc)

   !* Get the pointer to full particle data
   call fdps_ctrl%get_psys_fptr(psys_num,ptcl)
   
   !* Initialize particle data
   do i=1,nptcl_loc
      ptcl(i)%pos = ! Do something
   end do
   
   !* Release the pointer
   nullify(ptcl)

end subroutine foo
\end{lstlisting}
\endifFtn
\ifC % for C
\begin{lstlisting}[caption=Initialization of particle data]
void foo(psys_num) {
   // Set # of local particles
   nptcl_loc = 1024; 
   fdps_set_nptcl_loc(psys_num,nptcl_loc);

   // Get the pointer to full particle data
   Full_particle *ptcl = (Full_particle *)  fdps_get_psys_cptr(psys_num);
   
   // Initialize particle data
   int i;
   for (i = 0; i < nptcl_loc; i++) {
      ptcl[i].pos.x = /* Do something */ ;
   }
   
}
\end{lstlisting}
\endifC

First, you must allocate the memory to store the particle data. To do so, you have only to call API \describeForEach{}{\texttt{set\_nptcl\_loc}}{\texttt{fdps\_set\_nptcl\_loc}}. This API sets the number of local particles (the number of particles assigned to the local process) and allocates enough memory to store the particles. To initialize particle data, the beginning address of the allocated memory is needed. Users can obtain the beginning address by using the API \describeForEach{}{\texttt{get\_psys\_fptr}}{\texttt{get\_psys\_cptr}}. 
\ifFtn % for Fortran
Users must receive the beginning address by a Fortran pointer. In the example above, the pointer is prepared as follows:
\begin{screen}
\begin{spverbatim}
type(full_particle), dimension(:), pointer :: ptcl
\end{spverbatim}  
\end{screen}
Once you sets the pointer by the API \texttt{get\_psys\_fptr}, you can use the pointer as an array. In the above example, after initialize particle data, the pointer is freed by the built-in function \texttt{nullify}.
\endifFtn
\ifC % for C
Note that we need to cast the returned value to \texttt{Full\_particle *} type because API \texttt{fdps\_get\_psys\_cptr} returns the address of \texttt{void *} type. After setting the pointer \texttt{ptcl}, we can use it  as array.
\endifC
\endifIF


\subsubsubsection{Time integration loop}
In this section we describe the structure of the time integration loop.


\subsubsubsubsection{Domain Decomposition}
First, the computational domain is decomposed, using the current distribution of particles. In the sample, this is done by API \describeForEach{decomposeDomainAll}{\texttt{decompose\_domain\_all}}{\texttt{fdps\_decompose\_domain\_all}} of the \textsf{DomainInfo} object:

\ifCpp % for C++
\begin{lstlisting}[caption=Domain Decomposition]
if (n_loop % 4 == 0){
    dinfo.decomposeDomainAll(system_grav);
}
\end{lstlisting}
\endifCpp
\ifFtn % for Fortran
\begin{lstlisting}[caption=Domain Decomposition]
if (mod(num_loop,4) == 0) then
   call fdps_ctrl%decompose_domain_all(dinfo_num,psys_num)
end if
\end{lstlisting}
\endifFtn
\ifC % for C
\begin{lstlisting}[caption=Domain Decomposition]
if (num_loop % 4 == 0) {
    fdps_decompose_domain_all(dinfo_num,psys_num);
}
\end{lstlisting}
\endifC

In this sample code, we perform domain decomposition once in 4 main loops in order to reduce the computational cost.


\subsubsubsubsection{Particle Exchange}
Then, particles are exchanged between processes so that they belong to the process for the domain of their coordinates. To do so, users can use API \describeForEach{\texttt{exchangeParticle}}{\texttt{exchange\_particle}}{\texttt{fdps\_exchange\_particle}} of \textsf{ParticleSystem} object.

\ifCpp % for C++
\begin{lstlisting}[caption=Particle Exchange]
system_grav.exchangeParticle(dinfo);
\end{lstlisting}
\endifCpp
\ifFtn % for Fortran
\begin{lstlisting}[caption=Particle Exchange]
call fdps_ctrl%exchange_particle(psys_num,dinfo_num)
\end{lstlisting}
\endifFtn
\ifC % for C
\begin{lstlisting}[caption=Particle Exchange]
fdps_exchange_particle(psys_num,dinfo_num);
\end{lstlisting}
\endifC


\subsubsubsubsection{Interaction Calculation}
After the domain decomposition and the particle exchange, an interaction calculation is done. To do so, users can use API \describeForEach{\texttt{calcForceAllAndWriteBack}}{\texttt{calc\_force\_all\_and\_write\_back}}{\texttt{calc\_force\_all\_and\_write\_back}} of \textsf{Tree} object.

\ifCpp % for C++
\begin{lstlisting}[caption=Interaction Calculation]
tree_grav.calcForceAllAndWriteBack(CalcGravity<FPGrav>,
                                   CalcGravity<PS::SPJMonopole>,
                                   system_grav,
                                   dinfo);
\end{lstlisting}
Note that the content of the description \texttt{<...>} in the arguments of this method represents a template argument.
\endifCpp
\ifFtn % for Fortran
\begin{lstlisting}[caption=Interaction Calculation]
subroutien f_main()
   use, intrinsic :: iso_c_binding
   use user_defined_types
   implicit none
   !* Local variables
   type(c_funptr) :: pfunc_ep_ep,pfunc_ep_sp
   
   ! Do somehting
   
   pfunc_ep_ep = c_funloc(calc_gravity_pp)
   pfunc_ep_sp = c_funloc(calc_gravity_psp)
   call fdps_ctrl%calc_force_all_and_write_back(tree_num,    &
                                                pfunc_ep_ep, &
                                                pfunc_ep_sp, &
                                                psys_num,    &
                                                dinfo_num)

   ! Do something

end subroutine f_main
\end{lstlisting}
Here, the second and the third arguments are functions pointers of \textsf{calcForceEpEp} and \textsf{calcForceEpSp}. The address of the function in C can be obtained using the built-in function \texttt{c\_funloc}, which is introduced in Fortran 2003. This built-in function is provided by the module \texttt{iso\_c\_binding} and we use \texttt{use} statement to use this module. To store the address in C, we need the variables of derived data type \texttt{c\_funptr}, which is also introduced in Fortran 2003. In this sample, we use variables of type \texttt{c\_funptr}, \texttt{pfunc\_ep\_ep} and \texttt{pfunc\_ep\_sp}, to store the address in C of \texttt{calc\_gravity\_pp} and \texttt{calc\_gravity\_psp} and give them to the API.
\endifFtn
\ifC % for C
\begin{lstlisting}[caption=Interaction Calculation]
void c_main() {
   
   // Do somehting
   
   fdps_calc_force_all_and_write_back(tree_num,
                                      calc_gravity_ep_ep,
                                      calc_gravity_ep_sp,
                                      psys_num,
                                      dinfo_num,
                                      true,
                                      FDPS_MAKE_LIST);

   // Do something

}
\end{lstlisting}
Here, the second and third arguments are the function pointers of \textsf{calcForceEpEp} and \textsf{calcForceEpSp}. The sixth argument is a flag to specify whether or not to clear the result of previous interaction calculation. The seventh argument is a flag to specify the re-using feature of interaction lists is used or not. Passing \texttt{FDPS\_MAKE\_LIST} makes FDPS create a new interaction lists and perform interaction calculation using these lists.
\endifC

\subsubsubsubsection{Time integration}
\label{s4sec:nbody_time_integration}
In this sample code, we use the Leapfrog method to integrate the particle system in time. In this method, the time evolution operator can be expressed as $K(\frac{\Delta t}{2})D(\Delta t)K(\frac{\Delta t}{2})$, where $\Delta t$ is the timestep, $K(\Delta t)$ is the `kick' operator that integrates the velocities of particles from $t$ to $t+\Delta t$, $D(\Delta t)$ is the `drift' operator that integrates the positions of particles from $t$ to $t+\Delta t$ (e.g. see \href{http://mnras.oxfordjournals.org/content/364/4/1105}{Springel [2005,MNRAS,364,1105]}). In the sample code, these operators are implemented as the \procedures \texttt{kick} and \texttt{drift}.

At the beginning of the main loop, the positions and the velocities of the particles are updated by the operator $D(\Delta t)K(\frac{\Delta t}{2})$:

\ifCpp % for C++
\begin{lstlisting}[caption=Calculation of $D(\Delta t)K(\frac{\Delta t}{2})$ operator]
kick(system_grav, dt * 0.5);
drift(system_grav, dt);
\end{lstlisting}
\endifCpp
\ifFtn % for Fortran
\begin{lstlisting}[caption=Calculation of $D(\Delta t)K(\frac{\Delta t}{2})$operator]
!* Leapfrog: Kick-Drift
call kick(fdps_ctrl,psys_num,0.5d0*dt)
time_sys = time_sys + dt
call drift(fdps_ctrl,psys_num,dt)
\end{lstlisting}
\endifFtn
\ifFtn % for Fortran
\begin{lstlisting}[caption=Calculation of $D(\Delta t)K(\frac{\Delta t}{2})$operator]
// Leapfrog: Kick-Drift
kick(psys_num,0.5*dt);
time_sys +=  dt;
drift(psys_num,dt);
\end{lstlisting}
\endifFtn


After the force calculation, the velocities of the particles are updated by the operator $K(\frac{\Delta t}{2})$:

\ifCpp % for C++
\begin{lstlisting}[caption=Calculation of $K(\frac{\Delta t}{2})$ operator]
kick(system_grav, dt * 0.5);
\end{lstlisting}
\endifCpp
\ifFtn % for Fortran
\begin{lstlisting}[caption=Calculation of $K(\frac{\Delta t}{2})$ operator]
!* Leapfrog: Kick
call kick(fdps_ctrl,psys_num,0.5d0*dt)
\end{lstlisting}
\endifFtn
\ifC % for C
\begin{lstlisting}[caption=Calculation of $K(\frac{\Delta t}{2})$ operator]
// Leapfrog: Kick
kick(psys_num,0.5d0*dt);
\end{lstlisting}
\endifC


\ifIF % for Fortran and C
\subsubsubsection{Update of particle data}
To update the data of particles in the subroutines such as \texttt{kick} or \texttt{drift}, you need to access the data of particles contained in the object of type \textsf{ParticleSystem}. To do so, the user can follow the same way described in section \ref{s3sec:nbody_initialize_ptcl_data}.

\ifFtn % for Fortran
\begin{lstlisting}[caption=Update of particle data]
subroutine foo(fdps_ctrl,psys_num)
   use fdps_vector
   use fdps_module
   use user_defined_types
   implicit none
   type(fdps_controller), intent(IN) :: fdps_ctrl
   integer, intent(IN) :: psys_num
   !* Local variables
   integer :: i,nptcl_loc
   type(full_particle), dimension(:), pointer :: ptcl

   !* Get # of local particles
   nptcl_loc = fdps_ctrl%get_nptcl_loc(psys_num)

   !* Get the pointer to full particle data
   call fdps_ctrl%get_psys_fptr(psys_num,ptcl)
   
   !* Initialize or update particle data
   do i=1,nptcl_loc
      ptcl(i)%pos = ! Do something
   end do
   
   !* Release the pointer
   nullify(ptcl)

end subroutine foo
\end{lstlisting}
Using API \texttt{get\_psys\_fptr}, you can obtain the address of particle data contained in the object of \textsf{ParticleSystem} as a pointer. The pointer obtained here can be regarded as an array with the size of \texttt{nptcl\_loc}. Thus user can update the particle data as array.
\endifFtn
\ifC
\begin{lstlisting}[caption=Update of particle data]
void foo(psys_num) {
   // Get # of local particles
   int nptcl_loc = fdps_get_nptcl_loc(psys_num);
   
   // Get the pointer to full particle data
   Full_particle *ptcl = (Full_particle *) fdps_get_psys_cptr(psys_num);
   
   // Initialize or update particle data
   int i;
   for (i = 0; i < nptcl_loc; i++) {
      ptcl[i].pos.x = /* Do something */ ;
   }  
}
\end{lstlisting}
Using API \texttt{fdps\_get\_psys\_cptr}, you can obtain the address of particle data contained in the object of \textsf{ParticleSystem} as a pointer. The pointer obtained here can be regarded as an array of size \texttt{nptcl\_loc}. Thus, user can update the particle data as array.
\endifC
\endifIF

\subsubsection{Log file}
Once the calculation starts successfully, the time and the energy error are printed in the standard output. The first step is shown in the bellow example.
\begin{lstlisting}[caption=standard output]
time:    0.0000000000E+000, energy error:   -0.0000000000E+000
\end{lstlisting}

%===========================================
%   SPH code with fixed smoothing length
%===========================================
\subsection{SPH simulation code with fixed smoothing length}
\label{subsec:how_to_use_SPH_code}
In this section, we describe the sample code used in the previous section (\S~\ref{sec:getting_started}), a standard SPH code with fixed smoothing length, in detail.

\subsubsection{Location of source files and file structure}
The source files of the sample code are in the directory \dirNameSPHSample.
\describeForEach{% for C++
The sample code consists of \path{main.cpp} and a Makefile for GCC, \path{Makefile}.
}{% for Fortran
The sample code consists of \path{user_defined.F90} where user-defined types are described, and \path{f_main.F90} where the main loop etc. of the SPH simulation code are described. In addition, there are two Makefiles: \path{Makefile} (for GCC) and \path{Makefile.intel} (for Intel compilers).
}{%for C
The sample code consists of \path{user_defined.h} where user-defined types are described, \path{user_defined.c} where interaction functions are described, and \path{c_main.c} where the other parts of the SPH simulation code are described. In addition, there is a Makefile for GCC, \path{Makefile}.
}

\subsubsection{User-defined types and user-defined functions}
In this section, we describe the derived data types and subroutines that users must define when performing SPH simulations by using of FDPS.

%-----------------------
%   FullParticle type
%-----------------------
\subsubsubsection{FullParticle type}
Users must define a \textsf{FullParticle} type as a user-defined type. The \textsf{FullParticle} type must contain all physical quantities of an SPH particle necessary for the simulation. Listing~\ref{sph_FP} shows an example implementation of the \texttt{FullParticle} type in our sample code (see \describeForEach{\path{main.cpp}}{\path{user_defined.F90}}{\path{user_defined.h}}).

\ifCpp % for C++
\lstinputlisting[linerange={64-122},caption=FullParticle type,label=sph_FP]{../../../../sample/c++/sph/main.cpp}
\endifCpp
\ifFtn % for Fortran
\lstinputlisting[linerange={28-46},caption=FullParticle type,label=sph_FP]{../../../../sample/fortran/sph/user_defined.F90}
\endifFtn
\ifC % for C
\lstinputlisting[linerange={24-41},caption=FullParticle type,label=sph_FP]{../../../../sample/c/sph/user_defined.h}
\endifC

\ifCpp % for C++
\textsf{FullParticle} type must have a member function \texttt{copyFromForce} to copy the results from the \textsf{Force} type (explained later). It should have member functions \texttt{getCharge()} (returns the particle mass), \texttt{getPos()} (returns the particle position), \texttt{getRSearch()} (returns the search radius for neighbor particles), and \texttt{setPos()} (sets the position). In this sample code, we make use of file I/O functions of FDPS, which requires a user to define member functions \texttt{writeAscii()} and \texttt{readAscii()}. In addition to them, member function \texttt{setPressure()} is defined. This member function calculates the pressure from the equation of states. This function is not used by FDPS, but used within the user code.
\endifCpp
\ifIF % for Fortran and C
Unlike the case of the $N$-body simulation sample code, the \textsf{FullParticle} type of the SPH simulation sample code does not double as other user-defined types. Thus, to specify that this \structure is a \textsf{FullParticle} type, we append the following directive.
\endifIF
\ifFtn % for Fortran
\begin{screen}
\begin{spverbatim}
type, public, bind(c) :: full_particle !$fdps FP
\end{spverbatim}
\end{screen}
\endifFtn
\ifC % for C
\begin{screen}
\begin{spverbatim}
typedef struct full_particle { //$fdps FP
\end{spverbatim}
\end{screen}
\endifC
\ifIF % for Fortran and C
In the SPH simulations, the interaction force is short-range force. Therefore, a search radius is also necessary physical quantity in addition to the position and mass (charge). We can tell FDPS which member variables represent these necessary quantities in the following way:
\endifIF
\ifFtn % for Fortran
\begin{screen}
\begin{spverbatim}
real(kind=c_double) :: mass !$fdps charge
type(fdps_f64vec) :: pos !$fdps position
real(kind=c_double) :: smth !$fdps rsearch
\end{spverbatim}
\end{screen}
\endifFtn
\ifC % for C
\begin{screen}
\begin{spverbatim}
double mass; //$fdps charge
fdps_f64vec pos; //$fdps position
double smth; //$fdps rsearch
\end{spverbatim}
\end{screen}
\endifC
\ifIF % for Fortran and C
As described in the section of the $N$-boy simulation code, the keyword \texttt{velocity} to specify that a member corresponds to the velocity of a particle is mere a reserved word and not always necessary, we do not specify that in this sample code.

The \textsf{FullParticle} type copies data from a \textsf{Force} type. Users must specify how the data is copied by using of directives. As we will describe later, there are 2 \textsf{Force} types in this SPH sample code. Thus, for each \textsf{Force} type, users must write the directives. In this sample code, these are:
\endifIF
\ifFtn % for Fortran
\begin{screen}
\begin{spverbatim}
!$fdps copyFromForce force_dens (dens,dens)
!$fdps copyFromForce force_hydro (acc,acc) (eng_dot,eng_dot) (dt,dt)
\end{spverbatim}
\end{screen}
\endifFtn
\ifC % for C
\begin{screen}
\begin{spverbatim}
//$fdps copyFromForce force_dens (dens,dens)
//$fdps copyFromForce force_hydro (acc,acc) (eng_dot,eng_dot) (dt,dt)
\end{spverbatim}
\end{screen}
\endifC

%------------------------------
%   EssentialParticleI(J) type
%------------------------------
\subsubsubsection{EssentialParticleI(J) type}
Users must define an \textsf{EssentialParticleI} type. An \textsf{EssentialParticleI} type must contain all necessary physical quantities to compute the \textsf{Force} as an $i$-particle in its member variables. Moreover in this sample code, it also doubles as an \textsf{EssentialParticleJ} type and all necessary physical quantities as a $j$-particle as well need to be included in the member variables. Hereinafter, we simply call this \textsf{EssentialParticle} type. Listing~\ref{sph_EPI} shows an example of \textsf{EssentialParticle} type of this sample code (see \describeForEach{\path{main.cpp}}{\path{user_defined.F90}}{\path{user_defined.h}}):

\ifCpp % for C++
\lstinputlisting[linerange={125-151},caption=EssentialParticle type,label=sph_EPI]{../../../../sample/c++/sph/main.cpp}
\endifCpp
\ifFtn % for Fortran
\lstinputlisting[linerange={48-59},caption=EssentialParticle type,label=sph_EPI]{../../../../sample/fortran/sph/user_defined.F90}
\endifFtn
\ifC % for C
\lstinputlisting[linerange={44-54},caption=EssentialParticle type,label=sph_EPI]{../../../../sample/c/sph/user_defined.h}
\endifC

\ifCpp % for C++
\textsf{EssentialParticle} type should have member function \texttt{copyFromFP} to copy necessary quantities from \textsf{FullParticle} type described above. Also, it should have member functions \texttt{getPos()}, \texttt{getRSearch()}, and \texttt{setPos()}. 
\endifCpp
\ifIF % for Fortran and C
First, users must indicate to FDPS that this \structure corresponds to both the \textsf{EssentialParticleI} type and \textsf{EssentialParticleJ} type by using the directives. This sample code describes that as follows:
\endifIF
\ifFtn % for Fortran
\begin{screen}
\begin{spverbatim}
type, public, bind(c) :: essential_particle !$fdps EPI,EPJ
\end{spverbatim}
\end{screen}
\endifFtn
\ifC % for C
\begin{screen}
\begin{spverbatim}
typedef struct essential_particle { //$fdps EPI,EPJ
\end{spverbatim}
\end{screen}
\endifC
\ifIF % for Fortran and C
Next, users must indicate the correspondence between the each of member variable in this \structure and necessary physical quantity. For this SPH simulation, a search radius needs to be indicated as well. This sample code describes them as follows:
\endifIF
\ifFtn % for Fortran
\begin{screen}
\begin{spverbatim}
type(fdps_f64vec) :: pos !$fdps position
real(kind=c_double) :: mass !$fdps charge
real(kind=c_double) :: smth !$fdps rsearch
\end{spverbatim}
\end{screen}
\endifFtn
\ifC % for C
\begin{screen}
\begin{spverbatim}
fdps_f64vec pos; //$fdps position
double mass; //$fdps charge
double smth; //$fdps rsearch
\end{spverbatim}
\end{screen}
\endifC
\ifIF % for Fortran and C
The \textsf{EssentialParticleI} and \textsf{EssentialParticleJ} types receive data from the \textsf{FullParticle} type. Users must specify the source member variables in the \textsf{FullParticle} type and the destination member variable in the \textsf{EssentialParticle?} type (\textsf{?=I,J}) that will be copied through the directives. This sample code describes them as follows:
\endifIF
\ifFtn % for Fortran
\begin{screen}
\begin{spverbatim}
!$fdps copyFromFP full_particle (id,id) (pos,pos) (vel,vel) (mass,mass) (smth,smth) (dens,dens) (pres,pres) (snds,snds)
\end{spverbatim}
\end{screen}
\endifFtn
\ifC % for C
\begin{screen}
\begin{spverbatim}
//$fdps copyFromFP full_particle (id,id) (pos,pos) (vel,vel) (mass,mass) (smth,smth) (dens,dens) (pres,pres) (snds,snds)
\end{spverbatim}
\end{screen}
\endifC 

%-----------------
%   Force types
%-----------------
\subsubsubsection{Force type}
Users must define a \textsf{Force} type. A \textsf{Force} type must contain all the resultant physical quantities after performing the Force computations. In this sample code, we have 2 force computations; one for the density and the other for the fluid interactions. Thus, we have to define 2 different \textsf{Force} types. In Listing~\ref{sph_Force}, we show an example of the \textsf{Force} types in this sample code.

\ifCpp % for C++
\lstinputlisting[linerange={44-61},caption=Force type,label=sph_Force]{../../../../sample/c++/sph/main.cpp}
\endifCpp
\ifFtn % for Fortran
\lstinputlisting[linerange={14-26},caption=Force type,label=sph_Force]{../../../../sample/fortran/sph/user_defined.F90}
\endifFtn
\ifC % for C
\lstinputlisting[linerange={10-21},caption=Force type,label=sph_Force]{../../../../sample/c/sph/user_defined.h}
\endifC

\ifCpp % for C++
A \textsf{Force} type should have member function \texttt{clear()}, which zero-clears or initializes member variables that store the result of some accumulation operation.

In this sample, the \texttt{Dens} class has a member variable \texttt{smth} that stands for the smoothing length of a SPH particle, which is actually unnecessary for a SPH simulation with a \textit{fixed} smoothing length. However, we leave it in the sample code because it would be useful for a user to extend this sample code to a SPH simulation code with \textit{variable} smoothing length. In the formulation by \href{http://mnras.oxfordjournals.org/content/364/4/1105}{Springel [2005,MNRAS,364,1105]} (one of the most popular formulation of SPH with variable smoothing length), it is required to calculate the mass density and the smoothing length simultaneously. If you adopt this formulation, you need to let \textsf{Force} type have a member variable that represents smoothing length as in this sample code. The member function \texttt{clear} in the \texttt{Dens} class does not zero-clear \texttt{smth} because this sample code assume a fixed smoothing length (the density calculation will fail if \texttt{smth} is zero-cleared!).

The \texttt{Hydro} class has a member variable \texttt{dt} that stands for a timestep of each particle. In this sample, \texttt{dt} is not zero-cleared because \texttt{dt} is not a quantity that stores the result of some accumulation operation and  therefore zero-clear is unnecessary.
\endifCpp

\ifIF % for Fortran and C
First, users must indicate with directives that these \structures correspond to the \textsf{Force} types. In this example, these writes:
\endifIF
\ifFtn % for Fortran
\begin{screen}
\begin{spverbatim}
type, public, bind(c) :: force_dens !$fdps Force
type, public, bind(c) :: force_hydro !$fdps Force
\end{spverbatim}
\end{screen}
\endifFtn
\ifC % for C
\begin{screen}
\begin{spverbatim}
typedef struct force_dens { //$fdps Force
typedef struct force_hydro { //$fdps Force
\end{spverbatim}
\end{screen}
\endifC
\ifIF % for Fortran and C
For these \structures to be \textsf{Force} types, users \ulBold{must} indicate the initialization methods for the member variables that are accumulated during the interaction calculations. In this sample code, we indicate that only the accumulator variables ---  density, acceleration (due to pressure gradient), time-derivative of energy, and time step to be zero-cleared.
\endifIF
\ifFtn % for Fortran
\begin{screen}
\begin{spverbatim}
!$fdps clear smth=keep
!$fdps clear
\end{spverbatim}
\end{screen}
\endifFtn
\ifC % for C
\begin{screen}
\begin{spverbatim}
//$fdps clear smth=keep
//$fdps clear
\end{spverbatim}
\end{screen}
\endifC
\ifIF % for Fortran and C
In this example the \textsf{Force} type \texttt{force\_dens} includes a member variable \texttt{smth} that indicates the smoothing length. For a fixed length SPH, a member variable for the smoothing length in the \textsf{Force} type has nothing to do. We prepare this member variable for the future extension to the variable length SPH for some users. In one of the formulations of the variable length SPH in Springel [2005,MNRAS,364,1105], we need to calculate the smoothing length at the same time we calculate the density. To implement a formulation like that, a \textsf{Force} type need to contain a variable for the smoothing length as in this example. In this sample code for fixed length SPH, the member function \texttt{clear} will not zero-clear the variable \texttt{smth}, so as not to crush the next computation of the density.
\endifIF

%---------------------
%   calcForceEpEp
%---------------------
\subsubsubsection{calcForceEpEp}
Users must define a \procedure \textsf{calcForceEpEp} in \progLangName which specifies the interaction between particles. It should contain actual code for the calculation of interaction between particles. Listing~\ref{sph_calcForceEpEp} shows the implementation of \textsf{calcForceEpEp} (see \describeForEach{\path{main.cpp}{\path{user_defined.c}}\path{user_defined.F90}}{\path{user_defined.c}}).

\ifCpp % for C++
\lstinputlisting[linerange={174-211},caption=Function calcForceEpEp type,label=sph_calcForceEpEp]{../../../../sample/c++/sph/main.cpp}
\endifCpp
\ifFtn % for Fortran
\lstinputlisting[linerange={116-225},caption=Function  calcForceEpEp,label=sph_calcForceEpEp]{../../../../sample/fortran/sph/user_defined.F90}
\endifFtn
\ifC % for C
\lstinputlisting[linerange={42-142},caption=Function  calcForceEpEp,label=sph_calcForceEpEp]{../../../../sample/c/sph/user_defined.c}
\endifC

\ifCpp % for C++
Users can define \textsf{calcForceEpEp} using a functor (function object). In this sample, we use a functor instead of \procedure. In any case, the arguments of \textsf{calcForceEpEp} are an array of \textsf{EssentialParticleI} type, the number of \textsf{EssentialParticleI} type variables, an array of \textsf{EssentialParticleJ} type, the number of \textsf{EssentialParticleJ} variables, an array of \textsf{Force} type. As described above, two \textsf{Force} classes, one for density and the other for actual hydrodynamic interaction, are used in this code. Thus, two \textsf{calcForceEpEp} should be defined.
\endifCpp
\ifIF % for Fortran and C
This SPH simulation code includes two different forms of interactions, and hence, two different implementations of \textsf{calcForceEpEp} are needed. In either case, the dummy arguments of \procedure are, an array of \textsf{EssentialParticleI}, the number of \textsf{EssentialParticleI}, an array of \textsf{EssentialParticleJ}, the number of \textsf{EssentialParticleJ}, and an array of \textsf{Force}.
\endifIF

%---------------------------
%   Main body of the code
%---------------------------
\subsubsection{The main body of the user program}
In this section, we describe \procedures and \functions to be called from the \mainFunc of the user program when a user want to do an SPH simulation using FDPS \describeForIF{(for the meaning of ``\mainFunc'' see section \ref{subsubsec:nbody_sample_main_part})}.


\ifCpp % for C++
\subsubsubsection{Including the header file of FDPS}
To make the standard features of FDPS available, we must include header file  \texttt{particle\_simulator.hpp}.
\begin{lstlisting}[caption=Including header file \texttt{particle\_simulator.hpp}]
#include <particle_simulator.hpp>
\end{lstlisting}
\endifCpp
\ifFtn % for Fortran
\subsubsubsection{Creation of an object of type \texttt{fdps\_controller}}
In order to use APIs of FDPS, a user program should create an object of
type \texttt{FDPS\_controller}. In this sample code, \texttt{fdps\_ctrl}, an object of type \texttt{FDPS\_controller}, is created in the main routine.
\begin{lstlisting}[caption=Creation of an object of type \texttt{fdps\_controller}]
subroutine f_main()
   use fdps_module
   implicit none
   !* Local variables
   type(fdps_controller) :: fdps_ctrl
    
   ! Do something
   
end subroutine f_main    
\end{lstlisting}
Note that this code snippet only shows the necessary part of the code from the actual sample code. Also note that all FDPS APIs are called as member functions of this object because of the reason described above.
\endifFtn
\ifC % for C
\subsubsubsection{Including the header file of FDPS C interface}
To make the standard features of FDPS available, we must include header file  \texttt{FDPS\_c\_if.h}.
\begin{lstlisting}[caption=Including header file \texttt{FDPS\_c\_if.h}]
#include "FDPS_c_if.h"
\end{lstlisting}
\endifC

\subsubsubsection{Initialization and termination of FDPS}
You should first initialize FDPS by the following code.
\ifCpp % for C++
\begin{lstlisting}[caption=Initialization of FDPS]
PS::Initialize(argc, argv);
\end{lstlisting}
\endifCpp
\ifFtn % for Fortran
\begin{lstlisting}[caption=Initialization of FDPS]
call fdps_ctrl%PS_Initialize()
\end{lstlisting}
\endifFtn
\ifC % for C
\begin{lstlisting}[caption=Initialization of FDPS]
fdps_initialize();
\end{lstlisting}
\endifC

Once started, FDPS should be explicitly terminated. In this sample, FDPS is terminated just before the termination of the program. To achieve this, you write the following code at the end of the \mainFunc.

\ifCpp % for C++
\begin{lstlisting}[caption=Termination of FDPS]
PS::Finalize();
\end{lstlisting}
\endifCpp
\ifFtn % for Fortran
\begin{lstlisting}[caption=Termination of FDPS]
call fdps_ctrl%PS_Finalize()
\end{lstlisting}
\endifFtn
\ifC % for C
\begin{lstlisting}[caption=Termination of FDPS]
fdps_finalize();
\end{lstlisting}
\endifC


\subsubsubsection{Creation and initialization of FDPS objects}
After the initialization of FDPS, a user need to create the objects used to talk to FDPS. In this section we describe how to create and initialize these objects.

\subsubsubsubsection{Creation of necessary FDPS objects}
In an SPH simulation code, one needs to create objects for particles, for domain information, for interaction calculation of Gather type (for density calculation using gather type interaction), and for interaction calculation of Symmetry type  (for hydrodynamic interaction calculation using symmetric type interaction). The following is the code to create to them.

\ifCpp % for C++
\begin{lstlisting}[caption=Creation of FDPS Objects]
PS::ParticleSystem<FP> sph_system;
PS::DomainInfo dinfo;
PS::TreeForForceShort<Dens, EP, EP>::Gather dens_tree;
PS::TreeForForceShort<Hydro, EP, EP>::Symmetry hydr_tree;
\end{lstlisting}
\endifCpp
\ifFtn % for Fortran
\begin{lstlisting}[caption=Creation of necessary FDPS objects]
subroutine f_main()
   use fdps_vector
   use fdps_module
   use user_defined_types
   implicit none
   !* Local variables
   integer :: psys_num,dinfo_num
   integer :: dens_tree_num,hydro_tree_num
   
   !* Create FDPS objects
   call fdps_ctrl%create_psys(psys_num,'full_particle')
   call fdps_ctrl%create_dinfo(dinfo_num)
   call fdps_ctrl%create_tree(dens_tree_num, &
                              "Short,dens_force,essential_particle,essential_particle,Gather")
   call fdps_ctrl%create_tree(hydro_tree_num, &
                              "Short,hydro_force,essential_particle,essential_particle,Symmetry")

end subroutine f_main
\end{lstlisting}
Note that here again this code snippet only shows the necessary part of the code from the actual sample code.

API \texttt{create\_psys} and \texttt{create\_tree} should receive
strings indicating particle type and tree type, respectively. \textbf{\ul{All  of names of \structures in these strings should be in lowercases.}}
\endifFtn
\ifC % for C
\begin{lstlisting}[caption=Creation of necessary FDPS objects]
void c_main() {   
   // Create ParticleSystem object
   int psys_num;
   fdps_create_psys(&psys_num,"full_particle");
   
   // Create DomainInfo object
   int dinfo_num;
   fdps_create_dinfo(&dinfo_num);
   
   // Create Tree objects
   int tree_num_dens;
   fdps_create_tree(&tree_num_dens,
                    "Short,dens_force,essential_particle,essential_particle,Gather");
   int tree_num_hydro;
   fdps_create_tree(&tree_num_hydro,
                    "Short,hydro_force,essential_particle,essential_particle,Symmetry");

}
\end{lstlisting}
Note that here again this code snippet only shows the necessary part of the code from the actual sample code.

API \texttt{fdps\_create\_psys} and \texttt{fdps\_create\_tree} should receive
strings indicating particle type and tree type, respectively. \textbf{\ul{All of names of \structures in these strings should be in lowercases.}}
\endifC


\subsubsubsubsection{Initialization of the domain information object}
FDPS objects created by a user code should be initialized. Here, we describe the necessary procedures required to initialize a \textsf{DomainInfo} object. First, we need to call API \describeForEach{\texttt{initialize}}{\texttt{init\_dinfo}}{\texttt{fdps\_init\_dinfo}} of \textsf{DomainInfo} object. After the initialization of the object, the type of the boundary and the size of the simulation box should be set by calling APIs \describeForEach{\texttt{setBoundaryCondition}}{\texttt{set\_boundary\_condition}}{\texttt{fdps\_set\_boundary\_condition}} and \describeForEach{\texttt{setPosRootDomain}}{\texttt{set\_pos\_root\_domain}}{\texttt{fdps\_set\_pos\_root\_domain}} of \textsf{DomainInfo} object. In this code, we use the periodic boundary for all of $x$, $y$ and $z$ directions.

\ifCpp % for C++
\begin{lstlisting}[caption=Initialization of DomainInfo object]
dinfo.initialize();
dinfo.setBoundaryCondition(PS::BOUNDARY_CONDITION_PERIODIC_XYZ);
dinfo.setPosRootDomain(PS::F64vec(0.0, 0.0, 0.0),
                       PS::F64vec(box.x, box.y, box.z));
\end{lstlisting}
\endifCpp
\ifFtn % for Fortran
\begin{lstlisting}[caption=Initialization of DomainInfo object]
call fdps_ctrl%init_dinfo(dinfo_num,coef_ema)
call fdps_ctrl%set_boundary_condition(dinfo_num,fdps_bc_periodic_xyz)
call fdps_ctrl%set_pos_root_domain(dinfo_num,pos_ll,pos_ul)
\end{lstlisting}
\endifFtn
\ifC % for C
\begin{lstlisting}[caption=Initialization of DomainInfo object]
fdps_init_dinfo(dinfo_num,coef_ema);
fdps_set_boundary_condition(dinfo_num,FDPS_BC_PERIODIC_XYZ);
fdps_set_pos_root_domain(dinfo_num,&pos_ll,&pos_ul);
\end{lstlisting}
\endifC


\subsubsubsubsection{Initialization of ParticleSystem object}
Next, we need to initialize the \textsf{ParticleSystem} object. This is done by the following single line of code:

\ifCpp % for C++
\begin{lstlisting}[caption=Initialization of ParticleSystem object]
sph_system.initialize();
\end{lstlisting}
\endifCpp
\ifFtn % for Fortran
\begin{lstlisting}[caption=Initialization of ParticleSystem object]
call fdps_ctrl%init_psys(psys_num)
\end{lstlisting}
\endifFtn
\ifC % for C
\begin{lstlisting}[caption=Initialization of ParticleSystem object]
fdps_init_psys(psys_num);
\end{lstlisting}
\endifC


\subsubsubsubsection{Initialization of Tree objects}
Finally, \textsf{Tree} objects should be initialized. This is done by calling API \initTree. This API should be given an integer for determining the initial sizes of internally-used arrays. A number comparable to the number of local particles is enough. In this sample, we set three times the number of local particles:
\ifCpp % for C++
\begin{lstlisting}[caption=Initialization of tree objects]
dens_tree.initialize(n_loc);
hydr_tree.initialize(n_loc);
\end{lstlisting}
\endifCpp
\ifFtn % for Fortran
\begin{lstlisting}[caption=Initialization of tree objects]
call fdps_ctrl%init_tree(dens_tree_num,n_loc,theta, &
                         n_leaf_limit,n_group_limit)
call fdps_ctrl%init_tree(hydro_tree_num,n_loc,theta, &
                         n_leaf_limit,n_group_limit)
\end{lstlisting}
\endifFtn
\ifC % for C
\begin{lstlisting}[caption=Initialization of tree objects]
fdps_init_tree(dens_tree_num,n_loc,theta,
               n_leaf_limit,n_group_limit);
fdps_init_tree(hydro_tree_num,n_loc,theta,
               n_leaf_limit,n_group_limit);
\end{lstlisting}
\endifC

\subsubsubsection{Time integration loop}
In this section we describe the structure of the time integration loop.

\subsubsubsubsection{Domain Decomposition}
First, the computational domain is decomposed, using the current distribution of particles. To do so, the API \describeForEach{\texttt{decomposeDomainAll}}{\texttt{decompose\_domain\_all}}{\texttt{fdps\_decompose\_domain\_all}} of \textsf{DomainInfo} object is called.

\ifCpp % for C++
\begin{lstlisting}[caption=Domain Decomposition]
dinfo.decomposeDomainAll(sph_system);
\end{lstlisting}
\endifCpp
\ifFtn % for Fortran
\begin{lstlisting}[caption=Domain Decomposition]
call fdps_ctrl%decompose_domain_all(dinfo_num,psys_num)
\end{lstlisting}
\endifFtn
\ifC % for C
\begin{lstlisting}[caption=Domain Decomposition]
fdps_decompose_domain_all(dinfo_num,psys_num);
\end{lstlisting}
\endifC

\subsubsubsubsection{Particle Exchange}
Then particles are exchanged between processes so that they belong to the process for the domain of their coordinates. To do so, the following API \describeForEach{\texttt{exchangeParticle}}{\texttt{exchange\_particle}}{\texttt{fdps\_exchange\_particle}} of \texttt{ParticleSystem} object is used.

\ifCpp % for C++
\begin{lstlisting}[caption=Particle Exchange]
sph_system.exchangeParticle(dinfo);
\end{lstlisting}
\endifCpp
\ifFtn % for Fortran
\begin{lstlisting}[caption=Particle Exchange]
call fdps_ctrl%exchange_particle(psys_num,dinfo_num)
\end{lstlisting}
\endifFtn
\ifC % for C
\begin{lstlisting}[caption=Particle Exchange]
fdps_exchange_particle(psys_num,dinfo_num);
\end{lstlisting}
\endifC

\subsubsubsubsection{Interaction Calculation}
After the domain decomposition and particle exchange, interaction calculation is done. To do so, the following API \describeForEach{\texttt{calcForceAllAndWriteBack}}{\texttt{calc\_force\_all\_and\_write\_back}}{\texttt{fdps\_calc\_force\_all\_and\_write\_back}} of \textsf{Tree} object is used. 

\ifCpp % for C++
\begin{lstlisting}[caption=Interaction Calculation]
dens_tree.calcForceAllAndWriteBack(CalcDensity(), sph_system, dinfo);
hydr_tree.calcForceAllAndWriteBack(CalcHydroForce(), sph_system, dinfo);
\end{lstlisting}
\endifCpp
\ifFtn % for Fortran
\begin{lstlisting}[caption=Interaction Calculation]
subroutine f_main()
   use, intrinsic :: iso_c_binding
   use user_defined_types
   implicit none
   !* Local variables
   type(c_funptr) :: pfunc_ep_ep
   
   ! Do something
   
   pfunc_ep_ep = c_funloc(calc_density)
   call fdps_ctrl%calc_force_all_and_write_back(dens_tree_num, &
                                                pfunc_ep_ep,   &
                                                psys_num,      &
                                                dinfo_num)
   call set_pressure(fdps_ctrl,psys_num)
   pfunc_ep_ep = c_funloc(calc_hydro_force)
   call fdps_ctrl%calc_force_all_and_write_back(hydro_tree_num, &
                                                pfunc_ep_ep,   &
                                                psys_num,      &
                                                dinfo_num)

   ! Do something

end subroutine f_main
\end{lstlisting}
For the second argument of API, the function pointer (as in the C
language) of function \textsf{calcForceEpEp} should be given.
\endifFtn
\ifC % for C
\begin{lstlisting}[caption=Interaction Calculation]
void c_main() {
   
   // Do something
   
   fdps_calc_force_all_and_write_back(tree_num_dens,
                                      calc_density,
                                      NULL,
                                      psys_num,
                                      dinfo_num,
                                      true,
                                      FDPS_MAKE_LIST);
   set_pressure(psys_num);
   fdps_calc_force_all_and_write_back(tree_num_hydro,
                                      calc_hydro_force,
                                      NULL,
                                      psys_num,
                                      dinfo_num,
                                      true,
                                      FDPS_MAKE_LIST);

   // Do something

}
\end{lstlisting}
For the second argument of API, the function pointer \textsf{calcForceEpEp} should be given. The sixth argument determines whether the result of the previous interaction calculation is cleared before performing interaction calculation. The seventh argument determines whether the interaction lists are re-used or not. Passing \texttt{FDPS\_MAKE\_LIST} to this argument makes FDPS construct new interaction lists and perform interaction calculation using these lists, and tells FDPS that the lists used this time are not used in the next interaction calculation.
\endifC

\subsubsection{Compilation of the program}
Run \texttt{make} at the working directory. You can use the Makefile attached to the sample code.
\begin{screen}
\begin{verbatim}
$ make
\end{verbatim}
\end{screen}

\subsubsection{Execution}
To run the code without MPI, you should execute the following command in the command shell.
\begin{screen}
\begin{verbatim}
$ ./sph.out
\end{verbatim}
\end{screen}

To run the code using MPI, you should execute the following command in the command shell, or follow the document of your system.
\begin{screen}
\begin{verbatim}
$ MPIRUN -np NPROC ./sph.out
\end{verbatim}
\end{screen}
Here, \texttt{MPIRUN} represents the command to run your program using MPI such as \texttt{mpirun} or \texttt{mpiexec}, and \texttt{NPROC} is the number of MPI processes.


\subsubsection{Log and output files}
Log and output files are created under {\tt result} directory.

\subsubsection{Visualization}
In this section, we describe how to visualize the calculation result using \texttt{gnuplot}. To enter the interactive mode of \texttt{gnuplot}, execute the following command.

\begin{screen}
\begin{verbatim}
$ gnuplot
\end{verbatim}
\end{screen}

In the interactive mode, you can visualize the result. 
\ifCpp % for C++
In the following example, using the 40th snapshot file, we create the
plot in which the abscissa is the x coordinate of particles and the ordinate is the density of particles.
\begin{screen}
\begin{verbatim}
gnuplot> plot "result/0040.txt" u 3:9
\end{verbatim}
\end{screen}
\endifCpp 
\ifIF % for Fortran and C
In the following example, using the 50th snapshot file, we create the plot in which the abscissa is the x coordinate of particles and the ordinate is the density of particles.

\begin{screen}
\begin{verbatim}
gnuplot> plot "result/snap00050-proc00000.dat" u 3:9
\end{verbatim}
\end{screen}
where the integral number after the string of characters \texttt{proc} represents the rank number of a MPI process.
\endifIF

