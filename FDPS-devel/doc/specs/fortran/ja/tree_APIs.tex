\newcommand{\tlap}[1]{\vbox to 0pt{\vss\hbox{#1}}}
\newcommand{\blap}[1]{\vbox to 0pt{\hbox{#1}\vss}}

本節では、第\ref{chap:overview}章で説明した相互作用ツリークラスのオブジェクト(以後、単に\textbf{ツリーオブジェクト}と呼ぶ)に関するAPIについて説明する。FDPS本体において、ツリーオブジェクトは粒子間相互作用の計算を行うAPIを提供する。Fortran/C言語 インターフェースを用いたプログラムでは、ツリーオブジェクトを識別番号で管理する。

ツリーオブジェクトを操作する全APIの名称の一覧を以下に示す:
\begin{screen}
\begin{spverbatim}
(fdps_)create_tree
(fdps_)delete_tree
(fdps_)init_tree
(fdps_)get_tree_info
(fdps_)get_tree_memsize
(fdps_)get_tree_time_prof
(fdps_)clear_tree_time_prof
(fdps_)get_num_interact_ep_ep_loc
(fdps_)get_num_interact_ep_sp_loc
(fdps_)get_num_interact_ep_ep_glb
(fdps_)get_num_interact_ep_sp_glb
(fdps_)clear_num_interact
(fdps_)get_num_tree_walk_loc
(fdps_)get_num_tree_walk_glb
(fdps_)set_particle_local_tree
(fdps_)get_force
(fdps_)calc_force_all_and_write_back
(fdps_)calc_force_all
(fdps_)calc_force_making_tree
(fdps_)calc_force_and_write_back
(fdps_)get_neighbor_list
(fdps_)get_epj_from_id
\end{spverbatim}  
\end{screen}

以下、ツリーの種類に関して記述した後に、順に、各APIの仕様を記述していく。
\clearpage

%=============================================================
\subsection{ツリーの種別}
本節ではFDPS Fortran/C言語 インターフェースで使用可能なツリーの種類とその定義について説明する。自然界のほとんどの相互作用は、長距離力と短距離力に分類することができる。これに応じて、FDPSでは長距離力計算と短距離力計算で異なるツリーを用いる。ここでは、簡単のため、それぞれ、\textbf{長距離力用ツリー}と\textbf{短距離力用ツリー}と呼ぶことにする。FDPSではこれら2種類のツリーが、さらに動作モードに応じて細分される。以下、長距離力用ツリーと短距離力用ツリーに分けて、記述する。

%==============================
\subsubsection{長距離力用ツリーの種別}
\label{subsubsec:tree_kinds_long}
長距離用ツリーは、モーメントの計算方法別に10種類に細分される。粒子の重心を中心として単極子まで計算する場合をMonopole型、同じく四重極子までのモーメントを計算する場合をQuadrupole型と呼ぶ。粒子の幾何中心を中心として単極子まで、双極子まで、そして、四重極子までのモーメントを計算する場合を、それぞれ、MonopoleGeometricCenter型、DipoleGeometricCenter型、QuadrupoleGeometricCenter型と呼ぶ。

$\mathrm{P^{3}T}$(Particle-Particle-Particle-Tree)法等、一部の相互作用計算法では、近傍粒子探索が必要となる場合がある。そのような方法を使うユーザ用に、近傍粒子探索を可能としたMonopole型とQuadrupole型も用意している。近傍粒子探索を$j$粒子の探索半径を用いて行う場合を、それぞれ、MonopoleWithScatterSearch型、QuadrupoleWithScatterSearch型と呼ぶ。近傍粒子探索を$i$粒子の$j$粒子の探索半径の大きい方を用いて行う場合を、それぞれ、MonopoleWithSymmetrySearch型、QuadrupoleWithSymmetrySearch型と呼ぶ。相互計算時には近傍粒子は超粒子に含まれず、通常の粒子として計算される。探索半径の持たせ方に関しては、\S~\ref{sec:EPI:FDPS_directives_required_in_specific_cases} 及び \S~\ref{sec:EPJ:FDPS_directives_required_in_specific_cases}を参照のこと。

さらに、$\mathrm{P^{3}M}$(Particle-Particle-Particle-Mesh)法やTreePM法などでは、長距離力をカットオフ半径によって遠方成分と近傍成分に分け、遠方成分はPM法で、近傍成分は直接計算かツリー法で計算する。このような場合、カットオフ半径に含まれるツリー構造だけを考慮すればよく、この点における最適化を行える。これをMonopole型に適用したものが、MonopoleWithCutoff型である。このMonopoleWithCutoff型ではカットオフ半径はすべての粒子で同一である必要がある。カットオフ半径は相互作用する粒子を見つけるための探索半径として使われ、探索半径はEssentialParticleJ型が持っている必要がある(詳細は\S~\ref{sec:EPJ:FDPS_directives_required_in_specific_cases}を参照のこと)。

以上が、本 Fortran/C言語 インターフェースで使用可能な長距離力用ツリーである。一覧は、第\ref{sec:super_particle_types}節の表\ref{tbl:tree_and_super_particle}に示している。


%==============================
\subsubsection{短距離力用ツリーの種別}
\label{subsubsec:tree_kinds_short}
短距離用ツリーは、相互作用の仕方別に以下の3種類に細分される:
\begin{enumerate}[leftmargin=*]
\litem{Gather型} 相互作用の到達距離が有限で、かつ、その到達距離が$i$粒子の大きさ、或いは、$i$粒子が持つ探索半径で決まる場合。
\litem{Scatter型} 相互作用の到達距離が有限で、かつ、その到達距離が$j$粒子の大きさ、或いは、$j$粒子が持つ探索半径で決まる場合。
\litem{Symmetry型} 相互作用の到達距離が有限で、かつ、その到達距離が$i$,$j$粒子の大きさ($i$,$j$粒子が持つ探索半径)の\uline{どちらか大きい方}で決まる場合。
\end{enumerate}


\clearpage

%=============================================================
% API名::create_tree()
\subsection{create\_tree}
\subsubsection*{Fortran 構文}
\begin{screen}
\begin{spverbatim}
subroutine fdps_ctrl%create_tree(tree_num,tree_info_in)
\end{spverbatim}
\end{screen}

\subsubsection*{C言語 構文}
\begin{screen}
\begin{spverbatim}
void fdps_create_tree(int *tree_num,                                                                
                      char *tree_info);
\end{spverbatim}
\end{screen}

\subsubsection*{仮引数仕様}
\begin{table}[h]
\begin{tabularx}{\linewidth}{cXcX}
\toprule
\rowcolor{Snow2}
仮引数名 & データ型 & 入出力属性 & 定義 \\
\midrule
\verb|tree_num| & integer(kind=c\_int) & 入出力 & ツリーオブジェクトの識別番号を受け取るための変数。{\setnoko\uc{C言語では引数に変数のアドレスを指定する必要があることに注意}}。\\
\verb|tree_info_in| & character \newline (len=*,kind=c\_char) & 入力 & 生成するツリーの種別を指定するための文字列。\\
\verb|tree_info| & char * & 入力 & 生成するツリーの種別を指定するための文字列定数。\\
\bottomrule
\end{tabularx}
\end{table}

\subsubsection*{返り値}
なし

\subsubsection*{機能}
メモリ上にツリーオブジェクトを生成し、そのオブジェクトの識別番号を返す。ツリーオブジェクトの種類は、文字列\verb|tree_info_in| {\small (Fortranの場合)} 或いは 文字列定数\verb|tree_info| {\small (C言語の場合)}により指定される。長距離力用ツリーオブジェクトを生成する場合、文字列を以下のように指定する:
\begin{screen}
\verb|"Long,<force_type>,<epi_type>,<epj_type>,<tree_mode>"|
\end{screen}
ここで、\verb|<tree_mode>|として取れるのは、
Monopole,
Quadrupole,
MonopoleGeometricCenter,
DipoleGeometricCenter,
QuadrupoleGeometricCenter,
MonopoleWithScatterSearch, \newline
QuadrupoleWithScatterSearch,
MonopoleWithSymmetrySearch, \newline
QuadrupoleWithSymmetrySearch, 
MonopoleWithCutoff
のいずれかである。{\setnoko\uc{{\texttt{Long}}も含め、これらのキーワードは大文字・小文字が区別される}}。さらに、角括弧\verb|<>|は入力してはならない。これらは第\ref{subsubsec:tree_kinds_long}節で説明した長距離力用ツリーの種別に対応している。短距離力用ツリーオブジェクトを生成する場合、文字列を以下のように指定する:
\begin{screen}
\verb|"Short,<force_type>,<epi_type>,<epj_type>,<search_mode>"|
\end{screen}
ここで、\verb|<search_mode>|として取れるのは、
Gather,
Scatter,
Symmetry
のいずれかである。同様に、大文字・小文字が区別される。これらは第\ref{subsubsec:tree_kinds_short}節で説明した短距離用ツリーの種別に対応している。

長距離力用ツリーと短距離力用ツリーに共通して、\verb|<force_type>|, \verb|<epi_type>|, \verb|<epj_type>|にはユーザー定義型の派生データ型名 {\small (Fortranの場合)} 或いは 構造体名 {\small (C言語の場合)}を指定する。各カンマの前後に空白があってはならない。また、{\setnoko\uc{文字列はすべて小文字で入力されなければならない}}。
\clearpage

%=============================================================
\subsection{delete\_tree}
\subsubsection*{Fortran 構文}
\begin{screen}
\begin{spverbatim}
subroutine fdps_ctrl%delete_tree(tree_num)
\end{spverbatim}
\end{screen}

\subsubsection*{C言語 構文}
\begin{screen}
\begin{spverbatim}
void fdps_delete_tree(const int tree_num);
\end{spverbatim}
\end{screen}

\subsubsection*{仮引数仕様}
\begin{table}[h]
\begin{tabularx}{\linewidth}{cccX}
\toprule
\rowcolor{Snow2}
仮引数名 & データ型 & 入出力属性 & 定義 \\
\midrule
\verb|tree_num| & integer(kind=c\_int) & 入力 & ツリーオブジェクトの識別番号を受け取るための変数。\\
\bottomrule
\end{tabularx}
\end{table}

\subsubsection*{返り値}
なし

\subsubsection*{機能}
識別番号 \texttt{tree\_num}のツリーオブジェクトをメモリ上から削除する。
\clearpage

%=============================================================
\subsection{init\_tree}
\subsubsection*{Fortran 構文}
\begin{screen}
\begin{spverbatim}
subroutine fdps_ctrl%init_tree(tree_num,     &
                               nptcl,theta,  &
                               n_leaf_limit, &
                               n_group_limit)
\end{spverbatim}
\end{screen}

\subsubsection*{C言語 構文}
\begin{screen}
\begin{spverbatim}
void fdps_init_tree(const int tree_num,
                    const int nptcl,
                    const float theta,
                    const int n_leaf_limit,
                    const int n_group_limit);
\end{spverbatim}
\end{screen}

\clearpage

\subsubsection*{仮引数仕様}
\begin{table}[h]
\begin{tabularx}{\linewidth}{cccX}
\toprule
\rowcolor{Snow2}
仮引数名 & データ型 & 入出力属性 & 定義 \\
\midrule
\verb|tree_num|      & integer(kind=c\_int) & 入力 & ツリーオブジェクトの識別番号。\\
\verb|nptcl|         & integer(kind=c\_int) & 入力 & 粒子配列の上限。\\
\verb|theta|         & real(kind=c\_float)  & 入力 & 見こみ角に対する基準。Fortranの場合、この引数は省略可能であり、省略された場合のデフォルト値は0.7である。C言語では負値が入力された場合、自動的にFortranにおけるデフォルト値が設定される。\\
\verb|n_leaf_limit|  & integer(kind=c\_int) & 入力 & ツリーを切るのをやめる粒子数の上限。Fortranの場合、この引数は省略可能であり、省略された場合のデフォルト値は8である。C言語では負値が入力された場合、自動的にFortranにおけるデフォルト値が設定される。 \\ 
\verb|n_group_limit| & integer(kind=c\_int) & 入力 & 相互作用リストを共有する粒子数の上限。Fortranでは省略可能であり、省略された場合のデフォルト値は64である。C言語では負値が入力された場合、自動的にFortranにおけるデフォルト値が設定される。\\ 
\bottomrule
\end{tabularx}
\end{table}

\subsubsection*{返り値}
なし

\subsubsection*{機能}
識別番号 \texttt{tree\_num} のツリーオブジェクトを初期化する。
\clearpage

%=============================================================
\subsection{get\_tree\_info}
\subsubsection*{Fortran 構文}
\begin{screen}
\begin{spverbatim}
subroutine fdps_ctrl%get_tree_info(tree_num,tree_info)
\end{spverbatim}
\end{screen}

\subsubsection*{C言語 構文}
\begin{screen}
\begin{spverbatim}
void fdps_get_tree_info(const int tree_num,
                        char *tree_info,
                        size_t *charlen);
\end{spverbatim}
\end{screen}

\subsubsection*{仮引数仕様}
\begin{table}[h]
\begin{tabularx}{\linewidth}{cccX}
\toprule
\rowcolor{Snow2}
仮引数名 & データ型 & 入出力属性 & 定義 \\
\midrule
\verb|tree_num|  & integer(kind=c\_int) & 入力 & ツリーオブジェクトの識別番号。\\
\verb|tree_info| & character(len=*,kind=c\_char) & 入出力 & ツリーの種別を示す文字列を受け取るための変数。{\setnoko\uc{C言語では引数に変数のアドレスを指定する必要があることに注意}}。\\
\verb|charlen| & size\_t * & 入出力 & \verb|tree_info|に書き込まれた文字列の長さ。 \\
\bottomrule
\end{tabularx}
\end{table}

\subsubsection*{返り値}
なし

\subsubsection*{機能}
識別番号 \texttt{tree\_num} のツリーの種別を示す文字列を取得する。この文字列はツリー生成時に指定した文字列である。 
\clearpage

%=============================================================
\subsection{get\_tree\_memsize}
\subsubsection*{Fortran 構文}
\begin{screen}
\begin{spverbatim}
function fdps_ctrl%get_tree_memsize(tree_num)
\end{spverbatim}
\end{screen}

\subsubsection*{C言語 構文}
\begin{screen}
\begin{spverbatim}
long long int fdps_get_tree_memsize(const int tree_num);
\end{spverbatim}
\end{screen}

\subsubsection*{仮引数仕様}
\begin{table}[h]
\begin{tabularx}{\linewidth}{cccX}
\toprule
\rowcolor{Snow2}
仮引数名 & データ型 & 入出力属性 & 定義 \\
\midrule
\verb|tree_num|  & integer(kind=c\_int)  & 入力   & ツリーオブジェクトの識別番号。\\
\bottomrule
\end{tabularx}
\end{table}

\subsubsection*{返り値}
\verb|integer(kind=c_long_long)|型。

\subsubsection*{機能}
対象のオブジェクトが使用しているメモリー量を Byte 単位で返す。
\clearpage

%=============================================================
\subsection{get\_tree\_time\_prof}
\subsubsection*{Fortran 構文}
\begin{screen}
\begin{spverbatim}
subroutine fdps_ctrl%get_tree_time_prof(tree_num,prof)
\end{spverbatim}
\end{screen}

\subsubsection*{C言語 構文}
\begin{screen}
\begin{spverbatim}
void fdps_get_tree_time_prof(const int tree_num,                                                    
                             fdps_time_prof *prof);
\end{spverbatim}
\end{screen}

\subsubsection*{仮引数仕様}
\begin{table}[h]
\begin{tabularx}{\linewidth}{cccX}
\toprule
\rowcolor{Snow2}
仮引数名 & データ型 & 入出力属性 & 定義 \\
\midrule
\verb|tree_num|  & integer(kind=c\_int)   & 入力     & ツリーオブジェクトの識別番号。\\
\verb|prof|      & type(fdps\_time\_prof)  & 入出力   & ツリーオブジェクトのAPI でかかった時間を受け取るための変数。{\setnoko\uc{C言語の場合、変数のアドレスを引数に指定する必要があることに注意}}。 \\
\bottomrule
\end{tabularx}
\end{table}

\subsubsection*{返り値}
なし

\subsubsection*{機能}
ローカルツリー構築、グローバルツリー構築、力の計算(walk込)、ローカルツリーのモーメント計算、グローバルツリーのモーメント計算、LET(Local Essential Tree)構築、LET交換にかかった時間（ミリ秒単位）を\texttt{fdps\_time\_prof}型のメンバ変数の該当部分
\texttt{make\_local\_tree}, 
\texttt{make\_global\_tree},
\texttt{calc\_force},
\texttt{calc\_moment\_local\_tree},
\texttt{calc\_moment\_global\_tree},
\texttt{make\_LET\_1st\_, make\_LET\_2nd},
\texttt{exchange\_LET\_1st},
\texttt{exchange\_LET\_2nd}
に格納する。長距離力やShort-Scatter型ツリーの様にLET交換が1段階通信の場合は\texttt{make\_LET\_2nd}, \texttt{exchange\_LET\_2nd}に値は格納されない。
\clearpage

%=============================================================
\subsection{clear\_tree\_time\_prof}
\subsubsection*{Fortran 構文}
\begin{screen}
\begin{spverbatim}
subroutine fdps_ctrl%clear_tree_time_prof(tree_num)
\end{spverbatim}
\end{screen}

\subsubsection*{C言語 構文}
\begin{screen}
\begin{spverbatim}
void fdps_clear_tree_time_prof(const int tree_num); 
\end{spverbatim}
\end{screen}

\subsubsection*{仮引数仕様}
\begin{table}[h]
\begin{tabularx}{\linewidth}{cccX}
\toprule
\rowcolor{Snow2}
仮引数名 & データ型 & 入出力属性 & 定義 \\
\midrule
\verb|tree_num|  & integer(kind=c\_int)   & 入力     & ツリーオブジェクトの識別番号。\\
\bottomrule
\end{tabularx}
\end{table}

\subsubsection*{返り値}
なし

\subsubsection*{機能}
FDPS 本体に用意された識別番号 \texttt{tree\_num} のツリーオブジェクトのTimeProfile型プライベートメンバ変数のメンバ変数\texttt{make\_local\_tree}, \texttt{make\_global\_tree}, \texttt{calc\_force}, \texttt{calc\_moment\_local\_tree}, \texttt{calc\_moment\_global\_tree}, \texttt{make\_LET\_1st}, \texttt{make\_LET\_2nd}, \texttt{exchange\_LET\_1st}, \texttt{exchange\_LET\_2nd}の値を０クリアする。ここで、TimeProfile型はFortran/C言語インターフェースで用意された\texttt{fdps\_time\_prof}型に対応するC++のデータ型のことである(詳細は、FDPS本体の仕様書を参照)。本APIは時間計測をリセットするために使用する。
\clearpage

%=============================================================
\subsection{get\_num\_interact\_ep\_ep\_loc}
\subsubsection*{Fortran 構文}
\begin{screen}
\begin{spverbatim}
function fdps_ctrl%get_num_interact_ep_ep_loc(tree_num)
\end{spverbatim}
\end{screen}

\subsubsection*{C言語 構文}
\begin{screen}
\begin{spverbatim}
long long int fdps_get_num_interact_ep_ep_loc(const int tree_num); 
\end{spverbatim}
\end{screen}

\subsubsection*{仮引数仕様}
\begin{table}[h]
\begin{tabularx}{\linewidth}{cccX}
\toprule
\rowcolor{Snow2}
仮引数名 & データ型 & 入出力属性 & 定義 \\
\midrule
\verb|tree_num|  & integer(kind=c\_int)   & 入力     & ツリーオブジェクトの識別番号。\\
\bottomrule
\end{tabularx}
\end{table}

\subsubsection*{返り値}
integer(kind=c\_long\_long)型。

\subsubsection*{機能}
自プロセス内で計算したEPIとEPJの相互作用数を返す。
\clearpage

%=============================================================
\subsection{get\_num\_interact\_ep\_sp\_loc}
\subsubsection*{Fortran 構文}
\begin{screen}
\begin{spverbatim}
function fdps_ctrl%get_num_interact_ep_sp_loc(tree_num)
\end{spverbatim}
\end{screen}

\subsubsection*{C言語 構文}
\begin{screen}
\begin{spverbatim}
long long int fdps_get_num_interact_ep_sp_loc(const int tree_num); 
\end{spverbatim}
\end{screen}

\subsubsection*{仮引数仕様}
\begin{table}[h]
\begin{tabularx}{\linewidth}{cccX}
\toprule
\rowcolor{Snow2}
仮引数名 & データ型 & 入出力属性 & 定義 \\
\midrule
\verb|tree_num|  & integer(kind=c\_int)   & 入力     & ツリーオブジェクトの識別番号。\\
\bottomrule
\end{tabularx}
\end{table}

\subsubsection*{返り値}
integer(kind=c\_long\_long)型。

\subsubsection*{機能}
自プロセス内で計算したEPIとSPJの相互作用数を返す。
\clearpage

%=============================================================
\subsection{get\_num\_interact\_ep\_ep\_glb}
\subsubsection*{Fortran 構文}
\begin{screen}
\begin{spverbatim}
function fdps_ctrl%get_num_interact_ep_ep_glb(tree_num)
\end{spverbatim}
\end{screen}

\subsubsection*{C言語 構文}
\begin{screen}
\begin{spverbatim}
long long int fdps_get_num_interact_ep_ep_glb(const int tree_num);
\end{spverbatim}
\end{screen}

\subsubsection*{仮引数仕様}
\begin{table}[h]
\begin{tabularx}{\linewidth}{cccX}
\toprule
\rowcolor{Snow2}
仮引数名 & データ型 & 入出力属性 & 定義 \\
\midrule
\verb|tree_num|  & integer(kind=c\_int)   & 入力     & ツリーオブジェクトの識別番号。\\
\bottomrule
\end{tabularx}
\end{table}

\subsubsection*{返り値}
integer(kind=c\_long\_long)型。

\subsubsection*{機能}
全プロセス内で計算したEPIとEPJの相互作用数を返す。
\clearpage

%=============================================================
\subsection{get\_num\_interact\_ep\_sp\_glb}
\subsubsection*{Fortran 構文}
\begin{screen}
\begin{spverbatim}
function fdps_ctrl%get_num_interact_ep_sp_glb(tree_num)
\end{spverbatim}
\end{screen}

\subsubsection*{C言語 構文}
\begin{screen}
\begin{spverbatim}
long long int fdps_get_num_interact_ep_sp_glb(const int tree_num);
\end{spverbatim}
\end{screen}

\subsubsection*{仮引数仕様}
\begin{table}[h]
\begin{tabularx}{\linewidth}{cccX}
\toprule
\rowcolor{Snow2}
仮引数名 & データ型 & 入出力属性 & 定義 \\
\midrule
\verb|tree_num|  & integer(kind=c\_int)   & 入力     & ツリーオブジェクトの識別番号。\\
\bottomrule
\end{tabularx}
\end{table}

\subsubsection*{返り値}
integer(kind=c\_long\_long)型。

\subsubsection*{機能}
全プロセスで計算したEPIとSPJの相互作用数を返す。
\clearpage

%=============================================================
\subsection{clear\_num\_interact}
\subsubsection*{Fortran 構文}
\begin{screen}
\begin{spverbatim}
subroutine fdps_ctrl%clear_num_interact(tree_num)
\end{spverbatim}
\end{screen}

\subsubsection*{C言語 構文}
\begin{screen}
\begin{spverbatim}
void fdps_clear_num_interact(const int tree_num);
\end{spverbatim}
\end{screen}


\subsubsection*{仮引数仕様}
\begin{table}[h]
\begin{tabularx}{\linewidth}{cccX}
\toprule
\rowcolor{Snow2}
仮引数名 & データ型 & 入出力属性 & 定義 \\
\midrule
\verb|tree_num|  & integer(kind=c\_int)   & 入力     & ツリーオブジェクトの識別番号。\\
\bottomrule
\end{tabularx}
\end{table}

\subsubsection*{返り値}
なし

\subsubsection*{機能}
EP-EP,EP-SP の local,global の相互作用数を 0 クリアする。
\clearpage

%=============================================================
\subsection{get\_num\_tree\_walk\_loc}
\subsubsection*{Fortran 構文}
\begin{screen}
\begin{spverbatim}
function fdps_ctrl%get_num_tree_walk_loc(tree_num)
\end{spverbatim}
\end{screen}

\subsubsection*{C言語 構文}
\begin{screen}
\begin{spverbatim}
long long int fdps_get_num_tree_walk_loc(const int tree_num);
\end{spverbatim}
\end{screen}


\subsubsection*{仮引数仕様}
\begin{table}[h]
\begin{tabularx}{\linewidth}{cccX}
\toprule
\rowcolor{Snow2}
仮引数名 & データ型 & 入出力属性 & 定義 \\
\midrule
\verb|tree_num|  & integer(kind=c\_int)   & 入力     & ツリーオブジェクトの識別番号。\\
\bottomrule
\end{tabularx}
\end{table}

\subsubsection*{返り値}
integer(kind=c\_long\_long)型。

\subsubsection*{機能}
自プロセスでの相互作用計算時のtree walk数を返す。
\clearpage

%=============================================================
\subsection{get\_num\_tree\_walk\_glb}
\subsubsection*{Fortran 構文}
\begin{screen}
\begin{spverbatim}
function fdps_ctrl%get_num_tree_walk_glb(tree_num)
\end{spverbatim}
\end{screen}

\subsubsection*{C言語 構文}
\begin{screen}
\begin{spverbatim}
long long int fdps_get_num_tree_walk_glb(const int tree_num);
\end{spverbatim}
\end{screen}

\subsubsection*{仮引数仕様}
\begin{table}[h]
\begin{tabularx}{\linewidth}{cccX}
\toprule
\rowcolor{Snow2}
仮引数名 & データ型 & 入出力属性 & 定義 \\
\midrule
\verb|tree_num|  & integer(kind=c\_int)   & 入力     & ツリーオブジェクトの識別番号。\\
\bottomrule
\end{tabularx}
\end{table}

\subsubsection*{返り値}
integer(kind=c\_long\_long)型。

\subsubsection*{機能}
全プロセスでの相互作用計算時のtree walk数を返す。
\clearpage

%=============================================================
\subsection{set\_particle\_local\_tree}
\subsubsection*{Fortran 構文}
\begin{screen}
\begin{spverbatim}  
subroutine fdps_ctrl%set_particle_local_tree(tree_num, &
                                             psys_num, &
                                             clear)
\end{spverbatim}
\end{screen}

\subsubsection*{C言語 構文}
\begin{screen}
\begin{spverbatim}  
void fdps_set_particle_local_tree(const int tree_num,                                               
                                  const int psys_num,                                               
                                  const _Bool clear);
\end{spverbatim}
\end{screen}

\subsubsection*{仮引数仕様}
\begin{table}[h]
\begin{tabularx}{\linewidth}{cccX}
\toprule
\rowcolor{Snow2}
仮引数名 & データ型 & 入出力属性 & 定義 \\
\midrule
\verb|tree_num| & integer(kind=c\_int) & 入力 & ツリーオブジェクトの識別番号。\\
\verb|psys_num| & integer(kind=c\_int) & 入力 & 粒子群オブジェクトの識別番号。\\
\verb|clear| & logical(kind=c\_bool) & 入力 & 前に読込んだ粒子データをクリアするかどうか決定するフラグ。\texttt{.true.} {\small (Fortranの場合)}/\texttt{true} {\small (C言語の場合)}でクリアする。Fortranの場合、この引数は省略可能引数で、デフォルト値は\texttt{.true.}である。\\
\bottomrule
\end{tabularx}
\end{table}


\subsubsection*{返り値}
なし

\subsubsection*{機能}
識別番号\texttt{tree\_num}のツリーオブジェクトに、識別番号\texttt{psys\_num}の粒子群オブジェクトが保持する粒子データを読み込ませる。引数\texttt{clear}が\texttt{.true.} {\small (Fortranの場合)}/\texttt{true} {\small (C言語の場合)}ならば前に読込んだ粒子情報をクリアし、\texttt{.false.} {\small (Fortranの場合)}/\texttt{false} {\small (C言語の場合)}ならクリアしない。\texttt{.false.}/\texttt{false}の場合、新しく読み込む粒子データは、これまで読み込まれた粒子データの後に(メモリ上連続して)格納される。

\clearpage

%=============================================================
\subsection{get\_force}
\subsubsection*{Fortran 構文}
\begin{screen}
\begin{spverbatim}  
subroutine fdps_ctrl%get_force(tree_num, &
                               i, &
                               force)
\end{spverbatim}
\end{screen}

\subsubsection*{C言語 構文}
\begin{screen}
\begin{spverbatim}  
void fdps_get_force(const int tree_num,                                                             
                    const fdps_s32 i,                                                               
                    const void *cptr_to_force);
\end{spverbatim}
\end{screen}

\subsubsection*{仮引数仕様}
\begin{table}[h]
\begin{tabularx}{\linewidth}{cccX}
\toprule
\rowcolor{Snow2}
仮引数名 & データ型 & 入出力属性 & 定義 \\
\midrule
\verb|tree_num| & integer(kind=c\_int) & 入力 & ツリーオブジェクトの識別番号。\\
\verb|i| & integer(kind=c\_int) & 入力 & 粒子配列のインデックス。\\
\verb|force| & Force型 & 入出力 & i番目に読み込まれた粒子の相互作用計算の結果を格納する変数。\\
\verb|cptr_to_force| & void * & 入出力 & i番目に読み込まれた粒子の相互作用計算の結果を格納する変数のアドレス。\\
\bottomrule
\end{tabularx}
\end{table}

\subsubsection*{返り値}
なし

\subsubsection*{機能}
識別番号\texttt{tree\_num}のツリーオブジェクトがAPI \texttt{(fdps\_)set\_particle\_local\_tree}でi番目に読み込んだ粒子の受ける作用を返す。\texttt{i}が取りうる最小値は、Fortranでは1、C言語では0である。\texttt{force}のデータ型は、当該ツリーオブジェクトを生成するときに使用した派生データ型と同じでなければならない。同様、\texttt{cptr\_to\_force}が指す先のデータの型は、当該ツリーオブジェクトを生成するときに仕様した構造体と同じでなければならない。

\clearpage

%=============================================================
\subsection{calc\_force\_all\_and\_write\_back}
\subsubsection*{Fortran 構文 (短距離力の場合)}
\begin{screen}
\begin{spverbatim}
subroutine fdps_ctrl%calc_force_all_and_write_back(tree_num,    &
                                                   pfunc_ep_ep, &
                                                   psys_num,    &
                                                   dinfo_num,   &
                                                   list_mode)
\end{spverbatim}
\end{screen}

\subsubsection*{仮引数仕様}
\begin{table}[h]
\begin{tabularx}{\linewidth}{cccX}
\toprule
\rowcolor{Snow2}
仮引数名 & データ型 & 入出力属性 & 定義 \\
\midrule
\verb|tree_num|    & integer(kind=c\_int)   & 入力     & ツリーオブジェクトの識別番号。\\
\verb|pfunc_ep_ep| & type(c\_funptr)        & 入力     & EPIとEPJ間の相互作用を計算する関数ポインタ。\\
\verb|psys_num|    & integer(kind=c\_int)   & 入力     & 粒子群オブジェクトの識別番号。\\
\verb|dinfo_num|   & integer(kind=c\_int)   & 入力     & 領域情報オブジェクトの識別番号。\\
\verb|list_mode|   & integer(kind=c\_int)   & 入力     & 相互作用リストを使い回すかを決定する変数(詳細は「機能」の欄を参照のこと)。\\
\bottomrule
\end{tabularx}
\end{table}

\subsubsection*{返り値}
なし

\subsubsection*{機能}
短距離版。識別番号 \texttt{psys\_num} で指定された粒子群オブジェクトの粒子すべての相互作用を計算し、その計算結果を粒子群オブジェクトに書き戻す。関数ポインタとして渡される関数は第\ref{sec:user_defined_function}節で述べたインターフェースとなっている必要がある。

引数 \texttt{list\_mode}は第\ref{subsec:enum_list_mode}節で説明した相互作用リストモード型で、相互作用リストの使い回し(再利用)に関する振舞を制御するための変数である。値は、\texttt{fdps\_make\_list}、\texttt{fdps\_make\_list\_for\_reuse}、\texttt{fdps\_reuse\_list}のいずれかでなければならない。これ以外が指定された場合の動作は不定である。引数の値が\texttt{fdps\_make\_list}ならば、新たに相互作用リストを作成し、相互作用計算を行う。この際に作成した相互作用リストの情報はFDPS内部に保持されず、次の相互作用計算時に再利用することはできない。値が\texttt{fdps\_make\_list\_for\_reuse}のときは、新たに相互作用リストを作成し相互作用計算を行う。作成した相互作用リストをFDPS内部に保持するため、次回の相互作用計算時に、今回作った相互作用リストを再利用して相互作用計算を行うことができる。値が\texttt{fdps\_reuse\_list}ならば、前回 \texttt{fdps\_make\_list\_for\_reuse}を選んだ際に作成した相互作用リストを再利用して相互作用計算を行う。引数が省略された場合、デフォルト値\texttt{fdps\_make\_list}が採用される。
\clearpage

\subsubsection*{Fortran 構文 (長距離力の場合)}
\begin{screen}
\begin{spverbatim}
subroutine fdps_ctrl%calc_force_all_and_write_back(tree_num,    &
                                                   pfunc_ep_ep, &
                                                   pfunc_ep_sp, &
                                                   psys_num,    &
                                                   dinfo_num,   &
                                                   list_mode)
\end{spverbatim}
\end{screen}

\subsubsection*{仮引数仕様}
\begin{table}[h]
\begin{tabularx}{\linewidth}{cccX}
\toprule
\rowcolor{Snow2}
仮引数名 & データ型 & 入出力属性 & 定義 \\
\midrule
\verb|tree_num|    & integer(kind=c\_int)   & 入力     & ツリーオブジェクトの識別番号。\\
\verb|pfunc_ep_ep| & type(c\_funptr)        & 入力     & EPIとEPJ間の相互作用を計算する関数ポインタ。\\
\verb|pfunc_ep_sp| & type(c\_funptr)        & 入力     & EPIとSPJ間の相互作用を計算する関数ポインタ。\\
\verb|psys_num|    & integer(kind=c\_int)   & 入力     & 粒子群オブジェクトの識別番号。\\
\verb|dinfo_num|   & integer(kind=c\_int)   & 入力     & 領域情報オブジェクトの識別番号。\\
\verb|list_mode|   & integer(kind=c\_int)   & 入力     & 相互作用リストを使い回すかを決定する変数(詳細はFortran構文 (短距離力の場合)の「機能」の欄を参照のこと)。\\
\bottomrule
\end{tabularx}
\end{table}

\subsubsection*{返り値}
なし

\subsubsection*{機能}
長距離版。関数ポインタを2つ取る点を除いて短距離版と同じ。
\clearpage

\subsubsection*{C言語 構文 (短距離力・長距離力共用)}
\begin{screen}
\begin{spverbatim}
void fdps_calc_force_all_and_write_back(const int tree_num,
                                        void *(pfunc_ep_ep)(void *, int, void *, int, void *),
                                        void *(pfunc_ep_sp)(void *, int, void *, int, void *),
                                        const int psys_num,
                                        const int dinfo_num,
                                        const _Bool clear,
                                        const int list_mode);
\end{spverbatim}
\end{screen}

\subsubsection*{仮引数仕様}
\begin{table}[h]
\begin{tabularx}{\linewidth}{cX}
\toprule
\rowcolor{Snow2}
仮引数名 & 定義 \\
\midrule
\verb|tree_num|    & ツリーオブジェクトの識別番号。\\
\verb|pfunc_ep_ep| & EPIとEPJ間の相互作用を計算する関数ポインタ。\\
\verb|pfunc_ep_sp| & EPIとSPJ間の相互作用を計算する関数ポインタ。識別番号\verb|tree_num|のツリーオブジェクトが短距離力用のツリーの場合には使用されない。その場合、\texttt{NULL}ポインタを指定しておけばよい。\\
\verb|psys_num|    & 粒子群オブジェクトの識別番号。\\
\verb|dinfo_num|   & 領域情報オブジェクトの識別番号。\\
\verb|clear|       & 前回の相互作用計算の結果をクリアするかを指定するためのフラグ。\texttt{true}の場合、クリアする。\\
\verb|list_mode|   & 相互作用リストを使い回すかを決定する変数(詳細はFortran 構文(短距離力の場合)の「機能」の欄を参照のこと)。ただし、Fortranの場合と次の相違点がある。(i)引数は省略可能ではない。もし負の整数値が指定された場合、自動的にFortranにおけるデフォルト値に設定される。(ii) C言語の相互作用リストモード型を使って指定する必要がある。\\
\bottomrule
\end{tabularx}
\end{table}

\subsubsection*{返り値}
なし

\subsubsection*{機能}
Fortran版のAPIの説明を参照のこと。

\clearpage

%=============================================================
\subsection{calc\_force\_all}
\subsubsection*{Fortran 構文 (短距離力の場合)}
\begin{screen}
\begin{spverbatim}
subroutine fdps_ctrl%calc_force_all(tree_num,    &
                                    pfunc_ep_ep, &
                                    psys_num,    &
                                    dinfo_num,   &
                                    list_mode)
\end{spverbatim}
\end{screen}

\subsubsection*{仮引数仕様}
\begin{table}[h]
\begin{tabularx}{\linewidth}{cccX}
\toprule
\rowcolor{Snow2}
仮引数名 & データ型 & 入出力属性 & 定義 \\
\midrule
\verb|tree_num|    & integer(kind=c\_int)   & 入力     & ツリーオブジェクトの識別番号。\\
\verb|pfunc_ep_ep| & type(c\_funptr)        & 入力     & EPIとEPJ間の相互作用を計算する関数ポインタ。\\
\verb|psys_num|    & integer(kind=c\_int)   & 入力     & 粒子群オブジェクトの識別番号。\\
\verb|dinfo_num|   & integer(kind=c\_int)   & 入力     & 領域情報オブジェクトの識別番号。\\
\verb|list_mode|   & integer(kind=c\_int)   & 入力     & 相互作用リストを使い回すかを決定する変数(詳細はAPI \texttt{(fdps\_)calc\_force\_all\_and\_write\_back}のFortran構文(短距離力の場合)の「機能」の欄を参照のこと)。\\
\bottomrule
\end{tabularx}
\end{table}

\subsubsection*{返り値}
なし

\subsubsection*{機能}
短距離版。API \texttt{calc\_force\_all\_and\_write\_back}から計算結果の書き戻しがなくなったもの。
\clearpage

\subsubsection*{Fortran 構文 (長距離力の場合)}
\begin{screen}
\begin{spverbatim}
subroutine fdps_ctrl%calc_force_all(tree_num,    &
                                    pfunc_ep_ep, &
                                    pfunc_ep_sp, &
                                    psys_num,    &
                                    dinfo_num,   &
                                    list_mode)
\end{spverbatim}
\end{screen}

\subsubsection*{仮引数仕様}
\begin{table}[h]
\begin{tabularx}{\linewidth}{cccX}
\toprule
\rowcolor{Snow2}
仮引数名 & データ型 & 入出力属性 & 定義 \\
\midrule
\verb|tree_num|    & integer(kind=c\_int)   & 入力     & ツリーオブジェクトの識別番号。\\
\verb|pfunc_ep_ep| & type(c\_funptr)        & 入力     & EPIとEPJ間の相互作用を計算する関数ポインタ。\\
\verb|pfunc_ep_sp| & type(c\_funptr)        & 入力     & EPIとSPJ間の相互作用を計算する関数ポインタ。\\
\verb|psys_num|    & integer(kind=c\_int)   & 入力     & 粒子群オブジェクトの識別番号。\\
\verb|dinfo_num|   & integer(kind=c\_int)   & 入力     & 領域情報オブジェクトの識別番号。\\
\verb|list_mode|   & integer(kind=c\_int)   & 入力     & 相互作用リストを使い回すかを決定する変数(詳細はAPI \texttt{(fdps\_)calc\_force\_all\_and\_write\_back}のFortran構文(短距離力の場合)の「機能」の欄を参照のこと)。\\
\bottomrule
\end{tabularx}
\end{table}

\subsubsection*{返り値}
なし

\subsubsection*{機能}
長距離版。関数ポインタを2つ取る点を除いて短距離版と同じ。
\clearpage

\subsubsection*{C言語 構文 (短距離力・長距離力共用)}
\begin{screen}
\begin{spverbatim}
void fdps_calc_force_all(const int tree_num,
                         void *(pfunc_ep_ep)(void *, int, void *, int, void *),
                         void *(pfunc_ep_sp)(void *, int, void *, int, void *),
                         const int psys_num,
                         const int dinfo_num,
                         const _Bool clear,
                         const int list_mode);
\end{spverbatim}
\end{screen}

\subsubsection*{仮引数仕様}
\begin{table}[h]
\begin{tabularx}{\linewidth}{cX}
\toprule
\rowcolor{Snow2}
仮引数名 & 定義 \\
\midrule
\verb|tree_num|    & ツリーオブジェクトの識別番号。\\
\verb|pfunc_ep_ep| & EPIとEPJ間の相互作用を計算する関数ポインタ。\\
\verb|pfunc_ep_sp| & EPIとSPJ間の相互作用を計算する関数ポインタ。識別番号\verb|tree_num|のツリーオブジェクトが短距離力用のツリーの場合には使用されない。その場合、\texttt{NULL}ポインタを指定しておけばよい。\\
\verb|psys_num|    & 粒子群オブジェクトの識別番号。\\
\verb|dinfo_num|   & 領域情報オブジェクトの識別番号。\\
\verb|clear|       & 前回の相互作用計算の結果をクリアするかを指定するためのフラグ。\texttt{true}でクリアする。\\
\verb|list_mode|   & 相互作用リストを使い回すかを決定する変数(詳細はAPI \texttt{(fdps\_)calc\_force\_all\_and\_write\_back}のC言語構文の記述を参照のこと)。\\
\bottomrule
\end{tabularx}
\end{table}

\subsubsection*{返り値}
なし

\subsubsection*{機能}
Fortran版のAPIの説明を参照のこと。
\clearpage


%=============================================================
\subsection{calc\_force\_making\_tree}
\subsubsection*{Fortran 構文 (短距離力の場合)}
\begin{screen}
\begin{spverbatim}
subroutine fdps_ctrl%calc_force_making_tree(tree_num,    &
                                            pfunc_ep_ep, &
                                            dinfo_num)
\end{spverbatim}
\end{screen}

\subsubsection*{仮引数仕様}
\begin{table}[h]
\begin{tabularx}{\linewidth}{cXcX}
\toprule
\rowcolor{Snow2}
仮引数名 & データ型 & 入出力属性 & 定義 \\
\midrule
\verb|tree_num|    & integer(kind=c\_int)   & 入力     & ツリーオブジェクトの識別番号。\\
\verb|pfunc_ep_ep| & type(c\_funptr)        & 入力     & EPIとEPJ間の相互作用を計算する関数ポインタ。\\
\verb|pfunc_ep_sp| & type(c\_funptr)        & 入力     & EPIとSPJ間の相互作用を計算する関数ポインタ。\\
\verb|dinfo_num|   & integer(kind=c\_int)   & 入力     & 領域情報オブジェクトの識別番号。\\
\bottomrule
\end{tabularx}
\end{table}

\subsubsection*{返り値}
なし

\subsubsection*{機能}
短距離版。ツリーオブジェクトに読み込まれた粒子群オブジェクトの粒子すべての相互作用を計算する。API \texttt{calc\_force\_all\_and\_write\_back} に対して、粒子群オブジェクトからの粒子読み込みと計算結果の書き戻しがなくなったもの。
\clearpage

\subsubsection*{Fortran 構文 (長距離力の場合)}
\begin{screen}
\begin{spverbatim}
subroutine fdps_ctrl%calc_force_making_tree(tree_num,    &
                                            pfunc_ep_ep, &
                                            pfunc_ep_sp, &
                                            dinfo_num)
\end{spverbatim}
\end{screen}

\subsubsection*{仮引数仕様}
\begin{table}[h]
\begin{tabularx}{\linewidth}{cXcX}
\toprule
\rowcolor{Snow2}
仮引数名 & データ型 & 入出力属性 & 定義 \\
\midrule
\verb|tree_num|    & integer(kind=c\_int)   & 入力     & ツリーオブジェクトの識別番号。\\
\verb|pfunc_ep_ep| & type(c\_funptr)        & 入力     & EPIとEPJ間の相互作用を計算する関数ポインタ。\\
\verb|pfunc_ep_sp| & type(c\_funptr)        & 入力     & EPIとSPJ間の相互作用を計算する関数ポインタ。\\
\verb|dinfo_num|   & integer(kind=c\_int)   & 入力     & 粒子群オブジェクトの識別番号。\\
\bottomrule
\end{tabularx}
\end{table}

\subsubsection*{返り値}
なし

\subsubsection*{機能}
長距離版。関数ポインタを2つ取る点を除いて短距離版と同じ。
\clearpage

\subsubsection*{C言語 構文 (短距離力・長距離力共用)}
\begin{screen}
\begin{spverbatim}
void fdps_calc_force_making_tree(const int tree_num,
                                 void *(pfunc_ep_ep)(void *, int, void *, int, void *),
                                 void *(pfunc_ep_sp)(void *, int, void *, int, void *),
                                 const int dinfo_num,
                                 const _Bool clear);
\end{spverbatim}
\end{screen}

\subsubsection*{仮引数仕様}
\begin{table}[h]
\begin{tabularx}{\linewidth}{cX}
\toprule
\rowcolor{Snow2}
仮引数名 & 定義 \\
\midrule
\verb|tree_num|    & ツリーオブジェクトの識別番号。\\
\verb|pfunc_ep_ep| & EPIとEPJ間の相互作用を計算する関数ポインタ。\\
\verb|pfunc_ep_sp| & EPIとSPJ間の相互作用を計算する関数ポインタ。識別番号\verb|tree_num|のツリーオブジェクトが短距離力用のツリーの場合には使用されない。その場合、\texttt{NULL}ポインタを指定しておけばよい。\\
\verb|dinfo_num|   & 粒子群オブジェクトの識別番号。\\
\verb|clear|       & 前回の相互作用計算の結果をクリアするかを指定するためのフラグ。\texttt{true}でクリアする。\\
\bottomrule
\end{tabularx}
\end{table}

\subsubsection*{返り値}
なし

\subsubsection*{機能}
Fortran版のAPIの説明を参照のこと。
\clearpage

%=============================================================
\subsection{calc\_force\_and\_write\_back}
\subsubsection*{Fortran 構文 (短距離力の場合)}
\begin{screen}
\begin{spverbatim}
subroutine fdps_ctrl%calc_force_and_write_back(tree_num,   &
                                               func_ep_ep, &
                                               psys_num)
\end{spverbatim}
\end{screen}

\subsubsection*{仮引数仕様}
\begin{table}[h]
\begin{tabularx}{\linewidth}{cXcX}
\toprule
\rowcolor{Snow2}
仮引数名 & データ型 & 入出力属性 & 定義 \\
\midrule
\verb|tree_num|    & integer(kind=c\_int)   & 入力     & ツリーオブジェクトの識別番号。\\
\verb|pfunc_ep_ep| & type(c\_funptr)        & 入力     & EPIとEPJ間の相互作用を計算する関数ポインタ。\\
\verb|dinfo_num|   & integer(kind=c\_int)   & 入力     & 粒子群オブジェクトの識別番号。\\
\bottomrule
\end{tabularx}
\end{table}

\subsubsection*{返り値}
なし

\subsubsection*{機能}
短距離版。\texttt{calc\_force\_all\_and\_write\_back}に対して、粒子群オブジェクトからの粒子読込、ローカルツリーの構築、グローバルツリーの構築、グローバルツリーのモーメントの計算がなくなったもの。
\clearpage

\subsubsection*{Fortran 構文 (長距離力の場合)}
\begin{screen}
\begin{spverbatim}
subroutine fdps_ctrl%calc_force_and_write_back(tree_num,    &
                                               pfunc_ep_ep, &
                                               pfunc_ep_sp, &
                                               psys_num)
\end{spverbatim}
\end{screen}

\subsubsection*{仮引数仕様}
\begin{table}[h]
\begin{tabularx}{\linewidth}{cXcX}
\toprule
\rowcolor{Snow2}
仮引数名 & データ型 & 入出力属性 & 定義 \\
\midrule
\verb|tree_num|    & integer(kind=c\_int)   & 入力     & ツリーオブジェクトの識別番号。\\
\verb|pfunc_ep_ep| & type(c\_funptr)        & 入力     & EPIとEPJ間の相互作用を計算する関数ポインタ。\\
\verb|pfunc_ep_sp| & type(c\_funptr)        & 入力     & EPIとSPJ間の相互作用を計算する関数ポインタ。\\
\verb|dinfo_num|   & integer(kind=c\_int)   & 入力     & 領域情報オブジェクトの識別番号。\\
\bottomrule
\end{tabularx}
\end{table}

\subsubsection*{返り値}
なし

\subsubsection*{機能}
長距離版。関数ポインタを2つ取る点を除いて短距離版と同じ。
\clearpage

\subsubsection*{C言語 構文 (短距離力・長距離力共用)}
\begin{screen}
\begin{spverbatim}
void fdps_calc_force_and_write_back(const int tree_num,                                             
                                    void *(pfunc_ep_ep)(void *, int, void *, int, void *),          
                                    void *(pfunc_ep_sp)(void *, int, void *, int, void *),          
                                    const int psys_num,                                             
                                    const _Bool clear);
\end{spverbatim}
\end{screen}

\subsubsection*{仮引数仕様}
\begin{table}[h]
\begin{tabularx}{\linewidth}{cX}
\toprule
\rowcolor{Snow2}
仮引数名 & 定義 \\
\midrule
\verb|tree_num|    & ツリーオブジェクトの識別番号。\\
\verb|pfunc_ep_ep| & EPIとEPJ間の相互作用を計算する関数ポインタ。\\
\verb|pfunc_ep_sp| & EPIとSPJ間の相互作用を計算する関数ポインタ。識別番号\verb|tree_num|のツリーオブジェクトが短距離力用のツリーの場合には使用されない。その場合、\texttt{NULL}ポインタを指定しておけばよい。\\
\verb|dinfo_num|   & 領域情報オブジェクトの識別番号。\\
\verb|clear|       & 前回の相互作用計算の結果をクリアするかを指定するためのフラグ。\texttt{true}でクリアする。\\
\bottomrule
\end{tabularx}
\end{table}

\subsubsection*{返り値}
なし

\subsubsection*{機能}
Fortran版のAPIの説明を参照のこと。
\clearpage


%=============================================================
\subsection{get\_neighbor\_list}
\subsubsection*{Fortran 構文}
\begin{screen}
\begin{spverbatim}
subroutine fdps_ctrl%get_neighbor_list(tree_num, &
                                       pos,      &
                                       r_search, &
                                       num_epj,  &
                                       fptr_to_EPJ)
\end{spverbatim}
\end{screen}

\subsubsection*{C言語 構文}
\begin{screen}
\begin{spverbatim}
void fdps_get_neighbor_list(const int tree_num,                                                     
                            const fdps_f64vec *pos,                                                 
                            const fdps_f64 r_search,                                                
                            int *num_epj,                                                           
                            void **cptr_to_epj);
\end{spverbatim}
\end{screen}
\clearpage

\subsubsection*{仮引数仕様}
\begin{table}[h]
\begin{tabularx}{\linewidth}{cXcX}
\toprule
\rowcolor{Snow2}
仮引数名 & データ型 & 入出力属性 & 定義 \\
\midrule
\verb|tree_num|  & integer(kind=c\_int)   & 入力     & ツリーオブジェクトの識別番号。\\
\verb|pos|  & type(fdps\_f64vec)   & 入力     & 近傍粒子を求めたい粒子の位置。{\setnoko\uc{C言語では引数に変数のアドレスを指定する必要があることに注意}}。\\
\verb|r_search|  & real(kind=c\_double)   & 入力     & 近傍粒子を求めたい粒子の探索半径。\\
\verb|num_epj|  & integer(kind=c\_int)   & 入出力     & 探索して求めた近傍粒子数を格納するための変数。{\setnoko\uc{C言語では引数に変数のアドレスを指定する必要があることに注意}}。\\
\verb|fptr_to_EPJ|  & EssentialParticleJ型, \newline dimension(:), pointer   & 入出力     & 近傍粒子として同定されたEssentialParticleJ型粒子へのポインタ。\\
\verb|cptr_to_epj| & void ** & 入出力 & 近傍粒子として同定されたEssentialParticleJ型粒子の配列の先頭アドレスを格納する変数のアドレス。近傍粒子配列の先頭アドレスはvoid *型として返ってくるため、void *型を格納できる変数のアドレスを指定する必要がある。\\
\bottomrule
\end{tabularx}
\end{table}

\subsubsection*{返り値}
なし

\subsubsection*{機能}
識別番号 \texttt{tree\_num} のツリーオブジェクトを使って、位置\texttt{pos}、探索半径\texttt{r\_search}の粒子に対して近傍粒子探索を行い、近傍粒子数および近傍粒子の粒子配列へのポインタを返す。この粒子配列のデータ型は、ツリーオブジェクト作成時に指定したEssentialParticleJ型である必要がある。
\clearpage

%=============================================================
\subsection{get\_epj\_from\_id}
\subsubsection*{Fortran 構文}
\begin{screen}
\begin{spverbatim}
subroutine fdps_ctrl%get_epj_from_id(tree_num, &
                                     id,       &
                                     fptr_to_EPJ)
\end{spverbatim}
\end{screen}

\subsubsection*{C言語 構文}
\begin{screen}
\begin{spverbatim}
void * fdps_get_epj_from_id(const int tree_num,
                            const fdps_s64 id);
\end{spverbatim}
\end{screen}


\subsubsection*{仮引数仕様}
\begin{table}[h]
\begin{tabularx}{\linewidth}{cXcX}
\toprule
\rowcolor{Snow2}
仮引数名 & データ型 & 入出力属性 & 定義 \\
\midrule
\verb|tree_num|  & integer(kind=c\_int)   & 入力     & ツリーオブジェクトの識別番号。\\
\verb|id|  & type(kind=c\_long\_long)   & 入力     & 取得したい粒子の id。\\
\verb|fptr_to_EPJ|  & EssentialParticleJ型, \newline pointer   & 入出力     & EssentialParticleJ型へのポインタ。\\
\bottomrule
\end{tabularx}
\end{table}

\subsubsection*{返り値}
Fortranの場合にはなし、C言語の場合にはvoid *型。

\subsubsection*{機能}
識別番号 \texttt{tree\_num} のツリーオブジェクトの生成時に指定されたEssentialParticleJ(EPJ)型が、メンバ変数に粒子 id を持つ場合に使用可能(対応するメンバ変数には id であることを示すFDPS指示文が必要)。Fortranでは、引数 \texttt{fptr\_to\_EPJ} に、引数 id で指定された粒子idを持つ EPJ のポインタをセットする。対応する EPJ がない場合は、\texttt{fptr\_to\_EPJ}は未結合状態(NULL()の状態)となる(組み込み関数\texttt{associated}で結合状態を判定可能)。また、複数の EPJ が同じ id を持つ場合結果は保証されない。メンバ変数が粒子 id であることを指示する指示文については、第\ref{chap:user_defined}章を参照。以下に使用例を示す。
\begin{lstlisting}[caption=例]
integer(kind=c_long_long) :: id
type(essential_particle_j), pointer :: epj

call fdps_ctrl%get_epj_from_id(tree_num,id,epj)
if (associated(epj)) then
   ! Do something using epj
   write(*,*)'id = ',epj%id
else 
   write(*,*)'epj is NULL'
end if
\end{lstlisting}
C言語の場合、引数 id で指定された粒子idを持つEPJのアドレスが返り値として返ってくる。対応する EPJ がない場合の振る舞いはNULLポインタが返ってくる。
\clearpage

