ここまでの章で、FDPSの Fortran/C言語 インターフェースの生成に必要な情報に関して解説を行ってきた。本章では、インターフェースプログラムのコンパイルに関連したトピックを扱う。第\ref{chap:file_str_and_ftn_if_overview}章の図\ref{fig:FDPS_ftn_if_file_str}に示されるように、FDPS Fortran インターフェースプログラムは、C++言語のソースファイルとFortran言語のソースファイルから構成される。同様、FDPS C言語インターフェースプログラムもC++言語のソース・ファイルとC言語のソースファイルから構成される(図\ref{fig:FDPS_c_if_file_str})。本章のはじめに、複数の言語で構成されるインターフェースプログラムをコンパイルする際の注意点について記述する。次に、FDPS Fortran/C言語 インターフェースで使用可能なマクロ定義について記述する。FDPSでは、コンパイル時のマクロ定義によって、座標系の指定や並列処理の有無等を選択することができる。使用可能なマクロとその機能について解説する。


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{コンパイル}
本節では、Fortran/C言語 インターフェースプログラムを含むユーザコードをコンパイルする方法に関して記述する。はじめにコンパイラ依存しない事項に関して記述した後に、例としてGCC (The GNU Compiler Collection)を使った場合のコンパイル方法を示す。
%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{コンパイルの基本手順}
\label{subsec:compile:basic_procedures}
ここでは、(コンパイラ依存しない)コンパイルの一般的な手順について説明する。まずはじめにFortranインターフェースを利用する場合を述べ、その後、C言語インターフェースを利用する場合を述べる。

%%%%%%%%%%%%%
\subsubsection{Fortranインターフェースを利用する場合}

前提条件として、C++言語とFortran言語で記述された複数のソースファイルをコンパイルして実行ファイルを得るためには、相互運用可能なC++コンパイラ、C++リンカー、および、Fortranコンパイラが必要である。今日では、通常、C++コンパイラはC++リンカーとして動作するため、事実上必要となるのは相互運用可能なC++コンパイラとFortranコンパイラである。FortranコンパイラはFortran 2003標準 (ISO/IEC 1539-1:2004(E))に対応していなければならない。また、FDPS 本体のコンパイルのため、C++コンパイラはC++03 標準(ISO/IEC 14882:2003)に対応している必要がある。

第\ref{chap:file_str_and_ftn_if_overview}章で述べた通り、Fortran インターフェースを用いたコードでは\path{main}関数がC++側に存在する。したがって、コンパイルは、まずコンパイラでFortranとC++のソースファイルからオブジェクトファイルを生成し、その後、C++リンカーでオブジェクトファイルをリンクするという手順となる。より詳細には、以下の手順でコンパイルを行う:
\begin{enumerate}[leftmargin=*,label={[\arabic*]}]
\litem{Fortranソースのコンパイル} ユーザが記述したすべてのFortranソースコードの他、インターフェースプログラムの1つである\path{FDPS_module.F90}、FDPSから提供されるFortranファイル群(\path{src/fortran_interface/modules/*.F90})を、Fortranコンパイラでコンパイルし、オブジェクトファイルを生成する。多くの場合、オブジェクトファイルの生成はコンパイラオプション「\path{-c}」を付けてコンパイルすることよってなされる。

コンパイル時に注意しなければならないのは、コンパイラに渡すファイルの順序である。多くのコンパイラでは、あるファイル\path{foo.F90}でモジュール\path{bar}を使用している場合(\path{use}している場合)、モジュール\path{bar}が記述されたファイルは先にコンパイルされていなければならない。コンパイラは引数に渡されたファイルを先頭から順に処理するため、独立なモジュールを先に記述し、その後、依存関係の順にファイルを並べる必要がある。すなわち、Fortranコンパイラを\path{FC}とすれば、以下のようにコンパイルする:
\begin{Verbatim}[commandchars=\\\{\}]
$ FC -c \textbackslash
  FDPS_time_profile.F90 \textbackslash
  FDPS_vector.F90 \textbackslash
  FDPS_matrix.F90 \textbackslash
  FDPS_super_particle.F90 \textbackslash
  user_defined_1.F90 ... user_defined_n.F90 \textbackslash
  FDPS_module.F90 \textbackslash
  user_code_1.F90 ... user_code_n.F90
\end{Verbatim}
ここで、\textbackslash はコマンドラインが次の行に継続することを表す。これは、本文書のスペースの都合上導入したものであり、実際には不要である。サブルーチン\path{f_main()}はユーザコード(\path{user_code_*.F90})のどれかに実装されていると仮定する。この例におけるファイルの依存関係は次のようになっている:
\begin{itemize}[leftmargin=*]
\item \path{FDPS_super_particle.F90}は\path{FDPS_vector.F90}と\path{FDPS_matrix.F90}に依存
\item \path{FDPS_module.F90}はユーザ定義型が記述された$n$個のファイル\path{user_defined_}$i$\path{.F90} ($i=1$-$n$)に依存
\item $n$個のユーザコード \path{user_code_}$i$\path{.F90} ($i=1$-$n$)は、\path{FDPS_module.F90}に依存
\end{itemize}
\label{enum:compile:ftn_sources}

\litem{C++ソースのコンパイル} インターフェースプログラムのすべてのC++ファイル(\path{main.cpp}, \path{FDPS_Manipulators.cpp}, \path{FDPS_ftn_if.cpp})を、C++コンパイラでコンパイルし、オブジェクトファイルを生成する。C++はヘッダファイルが存在するため、ファイルの順番を気にする必要はない。したがって、コンパイラを\path{CXX}とすれば、以下のようにコンパイルする:
\begin{Verbatim}[commandchars=\\\{\}]
$ CXX -c FDPS_Manipulators.cpp FDPS_ftn_if.cpp main.cpp
\end{Verbatim}
\label{enum:compile:cpp_sources}

\litem{オブジェクトファイルのリンク} \ref{enum:compile:ftn_sources}, \ref{enum:compile:cpp_sources}で作成したオブジェクトファイル(\path{*.o})を、C++のリンカーでリンクし、実行ファイルを作成する。コンパイラによって、C++リンカーでFortranのオブジェクトファイルC++のオブジェクトにリンクするために、特別なコンパイルオプションが必要となる場合がある。これを\verb|LDFLAGS|とすると、リンクは以下のようにすればよい:
\begin{Verbatim}[commandchars=\\\{\}]
$ CXX *.o [LDFLAGS]
\end{Verbatim}
ここで、[]はその中身がコンパイラによっては省略可能であることを示す記号である。リンクが成功すれば、実行ファイルが作成されるはずである。
\end{enumerate}

上に示した基本手順では、言語仕様を指定するコンパイラオプション等は省略している。また、並列計算や拡張機能を使う際に必要となるライブラリ等もすべて省略している。これらはコンパイラ依存する部分であり、使用するコンパイラに応じて適切に指定する必要がある。

%%%%%%%%%%%%%
\subsubsection{C言語インターフェースを利用する場合}
C++言語とC言語で記述された複数のソースファイルをコンパイルして実行ファイルを得るためには、相互運用可能なC++コンパイラ、C++リンカー、および、Cコンパイラが必要である。前節で述べた理由により、事実上必要となるのは相互運用可能なC++コンパイラとCコンパイラである。CコンパイラはC99 規格 (ISO/IEC 9899:1999(E))に対応していなければならない。また、FDPS 本体のコンパイルのため、C++コンパイラはC++03 標準(ISO/IEC 14882:2003)に対応している必要がある。

第\ref{chap:file_str_and_ftn_if_overview}章で述べた通り、C言語 インターフェースを用いたコードでは\path{main}関数がC++側に存在する。したがって、コンパイルは、まずコンパイラでC言語とC++のソースファイルからオブジェクトファイルを生成し、その後、C++リンカーでオブジェクトファイルをリンクするという手順となる。より詳細には、以下の手順でコンパイルを行う:
\begin{enumerate}[leftmargin=*,label={[\arabic*]}]
\litem{C言語ソースのコンパイル} ユーザが記述したすべてのC言語ソースコードを、Cコンパイラでコンパイルし、オブジェクトファイルを生成する。多くの場合、オブジェクトファイルの生成はコンパイラオプション「\path{-c}」を付けてコンパイルすることよってなされる。すなわち、Cコンパイラを\path{CC}とすれば、以下のようにコンパイルする:
\begin{Verbatim}[commandchars=\\\{\}]
$ CC -c user_code_1.c ... user_code_n.c
\end{Verbatim}
\label{enum:compile:c_sources}

\litem{C++ソースのコンパイル} インターフェースプログラムのすべてのC++ファイル(\path{main.cpp}, \path{FDPS_Manipulators.cpp}, \path{FDPS_ftn_if.cpp})を、C++コンパイラでコンパイルし、オブジェクトファイルを生成する。したがって、コンパイラを\path{CXX}とすれば、以下のようにコンパイルする:
\begin{Verbatim}[commandchars=\\\{\}]
$ CXX -c FDPS_Manipulators.cpp FDPS_ftn_if.cpp main.cpp
\end{Verbatim}
\label{enum:compile:cpp_sources_in_c_if}

\litem{オブジェクトファイルのリンク} \ref{enum:compile:c_sources}, \ref{enum:compile:cpp_sources_in_c_if}で作成したオブジェクトファイル(\path{*.o})を、C++のリンカーでリンクし、実行ファイルを作成する。場合によっては、ライブラリをリンクする必要がある。リンクオプションを\verb|LDFLAGS|とすると、リンクは以下のようにすればよい:
\begin{Verbatim}[commandchars=\\\{\}]
$ CXX *.o [LDFLAGS]
\end{Verbatim}
ここで、[]はその中身が場合によっては省略可能であることを示す記号である。
リンクが成功すれば、実行ファイルが作成されるはずである。
\end{enumerate}

上に示した基本手順では、言語仕様を指定するコンパイラオプション等は省略している。また、並列計算や拡張機能を使う際に必要となるライブラリ等もすべて省略している。これらはコンパイラ依存する部分であり、使用するコンパイラに応じて適切に指定する必要がある。


%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{GCCを用いたコンパイルの仕方}
本節では、例として、GCC (バージョン4.8.3以上)の場合のコンパイルの仕方を記述する。本節を通して、C++コンパイラ、Fortranコンパイラ、Cコンパイラをそれぞれ\path{g++}、\path{gfortran}、\path{gcc}とする。また、MPIに対応したGCCコンパイラをぞれぞれ\path{mpic++}、\path{mpif90}、\path{mpicc}とし、使用するMPIライブラリは\href{https://www.open-mpi.org}{OpenMPI} (バージョン1.6.4以上)であるとする。以下、はじめにFortranインターフェースを利用する場合について述べ、その後、C言語インターフェースを利用する場合について述べる。

%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Fortranインターフェースを利用する場合}
%%%%%%%%
\subsubsubsection{MPIを使用しない場合}
\path{gfortran}でFortranのソースコードをFortran 2003 標準としてコンパイルするためには、コンパイルオプション\path{-std=f2003}が必要である。また、GCCの場合には、C++のオブジェクトファイルとFortranのオブジェクトファイルをリンクするためには、リンク時にオプション\path{-lgfortran}が必要となる。したがって、第\ref{subsec:compile:basic_procedures}節で説明した手順において、\path{FC}、\path{CXX}、\path{LDFLAGS}を、以下のように設定すればよい:
\begin{screen}
\begin{verbatim}
FC      = gfortran -std=f2003
CXX     = g++
LDFLAGS = -lgfortran
\end{verbatim}  
\end{screen}

%%%%%%%%
\subsubsubsection{MPIを使用する場合}
MPIを使用する場合で問題となるのは、Fortranで記述されたユーザコードの中でMPIを使用する場合である。この場合、C++用のMPIライブラリだけでなく、Fortran用のMPIライブラリをリンクする必要がある。それぞれのライブラリの名称が\path{libmpi}と\path{libmpi_f90}であるとすれば、コンパイルは、第\ref{subsec:compile:basic_procedures}節で説明した手順において、\path{FC}、\path{CXX}、\path{LDFLAGS}を、以下のように設定して行えばよい:
\begin{screen}
\begin{Verbatim}[commandchars=\\\{\}]
FC      = mpif90 -std=f2003
CXX     = mpic++
LDFLAGS = -lgfortran -L\vrbit{PATH} -lmpi -lmpi_f90
\end{Verbatim}  
\end{screen}
ここで、\textit{\texttt{PATH}}はMPIライブラリがインストールされているディレクトリの絶対PATHである。

MPIライブラリの名称は当然ユーザの計算機環境ごとに異なりうる。詳細は、ユーザの利用している計算機システムの管理者に問い合わせて確認して頂きたい。

%%%%%%%%%%%%%%%%
\subsubsection{C言語インターフェースを利用する場合}
%%%%%%%%
\subsubsubsection{MPIを使用しない場合}
コンパイルは、第\ref{subsec:compile:basic_procedures}節で説明した手順において、\path{CC}、\path{CXX}、\path{LDFLAGS}を以下のように設定して行えばよい:
\begin{screen}
\begin{verbatim}
CC      = gc
CXX     = g++
LDFLAGS = 
\end{verbatim}  
\end{screen}

%%%%%%%%
\subsubsubsection{MPIを使用する場合}
コンパイルは、第\ref{subsec:compile:basic_procedures}節で説明した手順において、\path{CC}、\path{CXX}、\path{LDFLAGS}を以下のように設定して行えばよい:
\begin{screen}
\begin{Verbatim}[commandchars=\\\{\}]
CC      = mpicc 
CXX     = mpic++
LDFLAGS = -L\vrbit{PATH} -lmpi 
\end{Verbatim}  
\end{screen}
ここで、\textit{\texttt{PATH}}はMPIライブラリがインストールされているディレクトリの絶対PATHである。

MPIライブラリの名称は当然ユーザの計算機環境ごとに異なりうる。詳細は、ユーザの利用している計算機システムの管理者に問い合わせて確認して頂きたい。
\clearpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{コンパイル時マクロ定義}
\label{sec:macro_definition_at_compling}

%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{座標系の指定}
\label{subsec:macro_coordinate}
座標系は直角座標系3次元と直角座標系2次元の選択ができる。以下、それらの選択方法について述べる。

\subsubsection{直角座標系3次元}
デフォルトは直角座標系3次元である。なにも行わなくても直角座標系３次元となる。

\subsubsection{直角座標系2次元}
コンパイル時に\path{PARTICLE_SIMULATOR_TWO_DIMENSION}をマクロ定義すると直交座標系2次元となる。

%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{並列処理の指定}
\label{subsec:macro_parallel}
並列処理に関しては、OpenMPの使用/不使用、MPIの使用/不使用を選択できる。以下、選択の仕方について記述する。

\subsubsection{OpenMPの使用}
デフォルトはOpenMP不使用である。使用する場合は、\path{PARTICLE_SIMULATOR_THREAD_PARALLEL}をマクロ定義すればよい。GCCコンパイラの場合はコンパイラオプションに\texttt{-fopenmp}をつける必要がある。

\subsubsection{MPIの使用}
デフォルトはMPI不使用である。使用する場合は、\path{PARTICLE_SIMULATOR_MPI_PARALLEL}をマクロ定義すればよい。

%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{データ型の精度の指定}
\label{subsec:macro_FP_accuracy}
超粒子型(第4.3節参照)のメンバ変数の型の精度を選択できる。以下、選択の仕方について記述する。

\subsubsection{超粒子型のメンバ変数の型の精度の指定}
デフォルトはすべてのメンバ変数が64ビットである。32ビットにしたい場合、\path{PARTICLE_SIMULATOR_SPMOM_F32}をマクロ定義すればよい。

%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{拡張機能 Particle Meshの使用}
\label{subsec:macro_PM}
拡張機能 Particle Mesh を使用するためには、\path{PARTICLE_SIMULATOR_USE_PM_MODULE}をマクロ定義すればよい。デフォルトではParticle Mesh 機能は使用できない。

%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{デバッグ用出力の指定}
\label{subsec:macro_debug}
デバッグ作業のため、マクロ\path{PARTICLE_SIMULATOR_DEBUG_PRINT}が用意されている。このマクロが定義済みの場合、FDPSの動作ログが出力されるようになる。

\subsection{粒子のソートの方法の変更}
\label{sec:compile_sort_method}

{\tt TreeForForce}クラスの内部では粒子はモートンキーの順でソートされて
いる．デフォルトでは並列ソートアルゴリズムとしてマージソートが使われている
が，\\
PARTICLE\_SIMULATOR\_USE\_RADIX\_SORT\\
をマクロ定義することでソートアルゴリズムを基数ソートに、また、\\
PARTICLE\_SIMULATOR\_USE\_SAMPLE\_SORT\\
をマクロ定義することで
並列サンプルソートに変更できる。

アーキテクチャによっては基数ソートが若干速いかもしれない。また、 A64fx
では並列サンプルソートが速いことが確認されている。
