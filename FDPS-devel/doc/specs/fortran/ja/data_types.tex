FDPS Fortran/C言語 インターフェースでは独自のデータ型が定義されている。データ型には、ベクトル型、対称行列型、超粒子型、時間プロファイル型、列挙型がある。これらに加え、C言語では基本データ型もある。これらのデータ型は第\ref{chap:user_defined}章で説明するユーザ定義型やユーザ定義関数の実装に必要となる他、いくつかの API の引数に指定したり、返り値を受け取る際に必要となる。

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{基本データ型 {\small (C言語のみ)}}
\label{sec:basic_types}
基本データ型はC言語インターフェースでのみ提供されるデータ型で、\path{fdps_s32}, \path{fdps_u32}, \path{fdps_f32}, \path{fdps_s64}, \path{fdps_u64}, \path{fdps_f64}の6種類がある。これらは、FDPSが提供する他の構造体の定義に使用される。\path{src/c_interface/headers/FDPS_basic.h}において、以下のように定義されている。

\begin{lstlisting}[language=C,caption=基本データ型 (C言語のみ)]
#pragma once

/* 32 bit data types */
typedef int          fdps_s32;
typedef unsigned int fdps_u32;
#ifdef PARTICLE_SIMULATOR_ALL_64BIT_PRECISION
typedef double       fdps_f32;
#else
typedef float        fdps_f32;
#endif

/* 64 bit data types */
typedef long long int          fdps_s64;
typedef unsigned long long int fdps_u64;
typedef double                 fdps_f64;
\end{lstlisting}
ただし、マクロ \verb|PARTICLE_SIMULATOR_ALL_64BIT_PRECISION|は現時点では正式にはサポートしておらず、C言語インターフェースが正しく動作するのは、このマクロが未定義の場合のみである。

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{ベクトル型}
\label{sec:vector_types}
ベクトル型は\path{fdps_f32vec}と\path{fdps_f64vec}の2種類がある。これらは、Fortranでは\path{src/fortran_interface/modules/FDPS_vector.F90}、C言語では\path{src/c_interface/headers/FDPS_vecotr.h}で、以下のように定義される。それぞれ、32 bit と 64 bit の浮動小数点数をメンバ変数として持つベクトルを表す。ベクトルの空間次元はデフォルトでは3であり、コンパイル時にマクロ\path{PARTICLE_SIMULATOR_TWO_DIMENSION}が定義されている場合のみ2となる。

\begin{lstlisting}[caption=ベクトル型 (Fortran)]
module fdps_vector
   use, intrinsic :: iso_c_binding
   implicit none
   
   type, public, bind(c) :: fdps_f32vec
#ifdef PARTICLE_SIMULATOR_TWO_DIMENSION 
      real(kind=c_float) :: x,y
#else
      real(kind=c_float) :: x,y,z
#endif
   end type fdps_f32vec

   type, public, bind(c) :: fdps_f64vec
#ifdef PARTICLE_SIMULATOR_TWO_DIMENSION 
      real(kind=c_double) :: x,y
#else
      real(kind=c_double) :: x,y,z
#endif
   end type fdps_f64vec

end module fdps_vector
\end{lstlisting}

\begin{lstlisting}[language=C,caption=ベクトル型 (C言語)]
#pragma once
#include "FDPS_basic.h"

//**** PS::F32vec
typedef struct  {
#ifdef PARTICLE_SIMULATOR_TWO_DIMENSION
   fdps_f32 x,y;
#else
   fdps_f32 x,y,z;
#endif
} fdps_f32vec;

//**** PS::F64vec
typedef struct  {
#ifdef PARTICLE_SIMULATOR_TWO_DIMENSION
   fdps_f64 x,y;
#else
   fdps_f64 x,y,z;
#endif
} fdps_f64vec;
\end{lstlisting}

Fortranにおいては、これらベクトル型に対して、代入(\texttt{=})と演算子(\texttt{+},\texttt{-},\texttt{*},\texttt{/})が表\ref{tbl:op_ext:fdps_vector}のように拡張されている。詳細に関しては、\path{FDPS_vector.F90}を参照して頂きたい。

\begin{table}[H]
\begin{tabularx}{\linewidth}{|c|c|c|X|}
\toprule
\rowcolor{Snow2}
記号 & 左辺 & 右辺 & 定義 \\
\midrule
% 代入記号(=)
\multirow{3}{*}{\texttt{=}} & ベクトル & スカラー$^{\dagger}$ & \multirow{3}{\hsize}{\footnotesize 左辺に右辺を代入する。但し、右辺がスカラーの場合、左辺の各成分すべてに右辺を代入し、右辺が配列の場合、配列の先頭から順に、左辺ベクトルの\texttt{x},\texttt{y}(,\texttt{z})成分に配列要素を代入。} \\
\cmidrule(r){2-3}
 & ベクトル & スカラー値の配列$^{\ddagger}$ &  \\
\cmidrule(r){2-3}
 & ベクトル & ベクトル &  \\
\midrule
% + 演算子
\multirow{4}{*}{\texttt{+}} & ベクトル & スカラー値の配列 & \multirow{3}{\hsize}{\footnotesize 左辺と右辺を加算する。但し、オペランドの1つが配列の場合、配列の各要素は先頭から順番に、ベクトル成分\texttt{x},\texttt{y}(,\texttt{z})に対応するものとする。} \\
\cmidrule(r){2-3}
 & スカラー値の配列 & ベクトル & \\
\cmidrule(r){2-3}
 & ベクトル & ベクトル & \\
\cmidrule(r){2-4}
 & なし & ベクトル & 何も行わない \\
\midrule
% - 演算子
\multirow{4}{*}{\texttt{-}} & ベクトル & スカラー値の配列 & \multirow{3}{\hsize}{\footnotesize 左辺から右辺を減算する。但し、オペランドの1つが配列の場合、配列の各要素は先頭から順番に、ベクトル成分\texttt{x},\texttt{y}(,\texttt{z})に対応するものとする。} \\
\cmidrule(r){2-3}
& スカラー値の配列 & ベクトル &  \\
\cmidrule(r){2-3}
& ベクトル & ベクトル & \\
\cmidrule(r){2-4}
& なし & ベクトル & ベクトルの各成分の符号反転 \\
\midrule
% * 演算子
\multirow{5}{*}{\texttt{*}} & ベクトル & スカラー & \multirow{2}{*}{スカラーベクトル積} \\
\cmidrule(r){2-3}
 & スカラー & ベクトル & \\
\cmidrule(r){2-4}
 & ベクトル & スカラー値の配列 & \multirow{3}{\hsize}{\footnotesize 内積。但し、オペランドの1つが配列の場合、配列の各要素は先頭から順番に、ベクトル成分\texttt{x},\texttt{y}(,\texttt{z})に対応するものとする。} \\
\cmidrule(r){2-3}
 & スカラー値の配列 & ベクトル &  \\
\cmidrule(r){2-3}
 & ベクトル & ベクトル &  \\
\midrule
\texttt{/} & ベクトル & スカラー & 左辺を右辺で除算する \\
\bottomrule
\end{tabularx}
\begin{flushleft}
$^{\dagger}$ ここでスカラー型はFortranの基本データ型である必要がある。\\
$^{\ddagger}$ 配列の要素数は、コンパイル時にマクロ\path{PARTICLE_SIMULATOR_TWO_DIMENSION}が定義されている場合には2、それ以外の場合には3である必要がある。
\end{flushleft}
\caption{ベクトル型に対して拡張された代入と演算子}
\label{tbl:op_ext:fdps_vector}
\end{table}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{対称行列型}
\label{sec:symmetric_matrix_types}
対称行列型には、\path{fdps_f32mat}と\path{fdps_f64mat}の2種類がある。Fortranでは\path{src/fortran_interface/modules/FDPS_matrix.F90}、C言語では\path{src/c_interface/headers/FDPS_matrix.h}において、以下のように定義される。それぞれ、32 bit と 64 bit の浮動小数点数をメンバ変数として持つ対称行列を表す。行列の次元はデフォルトでは3であり、コンパイル時にマクロ\path{PARTICLE_SIMULATOR_TWO_DIMENSION}が定義されている場合のみ2となる。

\begin{lstlisting}[caption=対称行列型 (Fortran)]
module fdps_matrix
   use, intrinsic :: iso_c_binding
   implicit none

   !**** PS::F32mat
   type, public, bind(c) :: fdps_f32mat
#ifndef PARTICLE_SIMULATOR_TWO_DIMENSION
      real(kind=c_float) :: xx,yy,zz,xy,xz,yz
#else
      real(kind=c_float) :: xx,yy,xy
#endif
   end type fdps_f32mat

   !**** PS::F64mat
   type, public, bind(c) :: fdps_f64mat
#ifndef PARTICLE_SIMULATOR_TWO_DIMENSION
      real(kind=c_double) :: xx,yy,zz,xy,xz,yz
#else
      real(kind=c_double) :: xx,yy,xy
#endif
   end type fdps_f64mat

end module fdps_matrix  
\end{lstlisting}

\begin{lstlisting}[language=C,caption=対称行列型 (C言語)]
#pragma once
#include "FDPS_basic.h"

//**** PS::F32mat
typedef struct {
#ifndef PARTICLE_SIMULATOR_TWO_DIMENSION
   fdps_f32 xx,yy,zz,xy,xz,yz;
#else
   fdps_f32 xx,yy,xy;
#endif
} fdps_f32mat;

//**** PS::F64mat
typedef struct {
#ifndef PARTICLE_SIMULATOR_TWO_DIMENSION
   fdps_f64 xx,yy,zz,xy,xz,yz;
#else
   fdps_f64 xx,yy,xy;
#endif
} fdps_f64mat;
\end{lstlisting}

Fortranでは、これら対称行列型に対して、代入(\texttt{=})と演算子(\texttt{+},\texttt{-},\texttt{*},\texttt{-})が表\ref{tbl:op_ext:fdps_matrix}のように拡張されている。詳細に関しては、\path{FDPS_matrix.F90}を参照して頂きたい。

\begin{table}[H]
\begin{tabularx}{\linewidth}{|c|c|c|X|}
\toprule
\rowcolor{Snow2}
記号 & 左辺 & 右辺 & 定義 \\
\midrule
% = 記号
\multirow{2}{*}{\texttt{=}}& 対称行列 & スカラー$^{\dagger}$ & \multirow{2}{\hsize}{\footnotesize 左辺に右辺を代入。但し、右辺がスカラーの場合、左辺の各成分すべてに右辺が代入される。} \\
\cmidrule(r){2-3}
& 対称行列 & 対称行列 & \\
\midrule
% + 演算子
\multirow{2}{*}{\texttt{+}} & 対称行列 & 対称行列 & 左辺に右辺を加算する\\
\cmidrule(r){2-4}
& なし & 対称行列 & 何も行わない\\
\midrule
% - 演算子
\multirow{2}{*}{\texttt{-}} & 対称行列 & 対称行列 & 左辺から右辺を減算する\\
\cmidrule(r){2-4}
& なし & 対称行列 & 行列の各成分の符号反転\\
\midrule
% * 演算子
\multirow{3}{*}{\texttt{*}} & 対称行列 & スカラー & \multirow{2}{*}{スカラー行列積} \\
\cmidrule(r){2-3}
 & スカラー & 対称行列 &  \\
\cmidrule(r){2-4}
 & 対称行列 & 対称行列 & 行列積 \\
\midrule
% / 演算子
\texttt{/} & 対称行列 & スカラー & 左辺を右辺で除算する \\
\bottomrule
\end{tabularx}
\begin{flushleft}
$^{\dagger}$ ここでスカラー型はFortranの基本データ型である必要がある。
\end{flushleft}
\caption{対称行列型に対して拡張された代入と演算子}
\label{tbl:op_ext:fdps_matrix}
\end{table}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{超粒子型}
\label{sec:super_particle_types}
超粒子型は、粒子-超粒子間の相互作用計算を記述するのに必要となるデータ型である。ここで超粒子とは、FDPS 本体で長距離力計算の方法として採用しているツリー法において、力を計算する対象の粒子に対して、十分に遠くにある複数の粒子を1つの粒子として表現したものである。これら超粒子型は、FDPS 本体から超粒子のデータを受け取るのに使用される。

超粒子型には、\path{fdps_spj_monopole}、\path{fdps_spj_quadrupole}、\path{fdps_spj_monopole_geomcen}、\path{fdps_spj_dipole_geomcen}、\path{fdps_spj_quadrupole_geomcen}、\path{fdps_spj_monopole_scatter}、\path{fdps_spj_quadrupole_scatter}、\path{fdps_spj_monopole_symmetry}、\path{fdps_spj_quadrupole_symmetry}、\path{fdps_spj_monopole_cutoff}がある。Fortranでは\path{src/fortran_interface/modules/FDPS_super_particle.F90}、C言語では\path{src/c_interface/headers/FDPS_super_particle.h}において、以下のように定義される。ここで、各超粒子型のメンバ変数には前述したベクトル型および対称行列型が使用されていることに注意されたい。

\begin{lstlisting}[caption=超粒子型 (Fortran)]
module fdps_super_particle
   use, intrinsic :: iso_c_binding
   use fdps_vector
   use fdps_matrix
   implicit none

   !**** PS::SPJMonopole
   type, public, bind(c) :: fdps_spj_monopole
      real(kind=c_double) :: mass
      type(fdps_f64vec) :: pos
   end type fdps_spj_monopole

   !**** PS::SPJQuadrupole
   type, public, bind(c) :: fdps_spj_quadrupole
      real(kind=c_double) :: mass
      type(fdps_f64vec)  :: pos
      type(fdps_f64mat)  :: quad
   end type fdps_spj_quadrupole

   !**** PS::SPJMonopoleGeometricCenter
   type, public, bind(c) :: fdps_spj_monopole_geomcen
      integer(kind=c_long_long) :: n_ptcl
      real(kind=c_double) :: charge
      type(fdps_f64vec) :: pos
   end type fdps_spj_monopole_geomcen

   !**** PS::SPJDipoleGeometricCenter
   type, public, bind(c) :: fdps_spj_dipole_geomcen
      integer(kind=c_long_long) :: n_ptcl
      real(kind=c_double) :: charge
      type(fdps_f64vec) :: pos
      type(fdps_f64vec) :: dipole
   end type fdps_spj_dipole_geomcen

   !**** PS::SPJQuadrupoleGeometricCenter
   type, public, bind(c) :: fdps_spj_quadrupole_geomcen
      integer(kind=c_long_long) :: n_ptcl
      real(kind=c_double) :: charge
      type(fdps_f64vec) :: pos
      type(fdps_f64vec) :: dipole
      type(fdps_f64mat) :: quadrupole
   end type fdps_spj_quadrupole_geomcen

   !**** PS::SPJMonopoleScatter
   type, public, bind(c) :: fdps_spj_monopole_scatter
      real(kind=c_double) :: mass
      type(fdps_f64vec) :: pos
   end type fdps_spj_monopole_scatter

   !**** PS::SPJQuadrupoleScatter
   type, public, bind(c) :: fdps_spj_quadrupole_scatter
      real(kind=c_double) :: mass
      type(fdps_f64vec)  :: pos
      type(fdps_f64mat)  :: quad
   end type fdps_spj_quadrupole_scatter
   
   !**** PS::SPJMonopoleSymmetry
   type, public, bind(c) :: fdps_spj_monopole_symmetry
      real(kind=c_double) :: mass
      type(fdps_f64vec) :: pos
   end type fdps_spj_monopole_symmetry

   !**** PS::SPJQuadrupoleSymmetry
   type, public, bind(c) :: fdps_spj_quadrupole_symmetry
      real(kind=c_double) :: mass
      type(fdps_f64vec) :: pos
      type(fdps_f64mat) :: quad
   end type fdps_spj_quadrupole_symmetry


   !**** PS::SPJMonopoleCutoff
   type, public, bind(c) :: fdps_spj_monopole_cutoff
      real(kind=c_double) :: mass
      type(fdps_f64vec) :: pos
   end type fdps_spj_monopole_cutoff

end module fdps_super_particle   

\end{lstlisting}

\begin{lstlisting}[language=C,caption=超粒子型 (C言語)]
#pragma once
#include "FDPS_basic.h"
#include "FDPS_vector.h"
#include "FDPS_matrix.h"

#ifdef PARTICLE_SIMULATOR_SPMOM_F32
typedef fdps_s32    fdps_sSP;
typedef fdps_f32    fdps_fSP;
typedef fdps_f32vec fdps_fSPvec;
typedef fdps_f32mat fdps_fSPmat;
#else
typedef fdps_s64    fdps_sSP;
typedef fdps_f64    fdps_fSP;
typedef fdps_f64vec fdps_fSPvec;
typedef fdps_f64mat fdps_fSPmat;
#endif

//**** PS::SPJMonopole
typedef struct {
   fdps_fSP mass;
   fdps_fSPvec pos;
} fdps_spj_monopole;

//**** PS::SPJQuadrupole
typedef struct {
   fdps_fSP mass;
   fdps_fSPvec pos;
   fdps_fSPmat quad;
} fdps_spj_quadrupole;

//**** PS::SPJMonopoleGeometricCenter
typedef struct {
   fdps_sSP n_ptcl;
   fdps_fSP charge;
   fdps_fSPvec pos;
} fdps_spj_monopole_geomcen;

//**** PS::SPJDipoleGeometricCenter
typedef struct {
   fdps_sSP n_ptcl;
   fdps_fSP charge;
   fdps_fSPvec pos;
   fdps_fSPvec dipole;
} fdps_spj_dipole_geomcen;

//**** PS::SPJQuadrupoleGeometricCenter
typedef struct {
   fdps_sSP n_ptcl;
   fdps_fSP charge;
   fdps_fSPvec pos;
   fdps_fSPvec dipole;
   fdps_fSPmat quadrupole;
} fdps_spj_quadrupole_geomcen;

//**** PS::SPJMonopoleScatter
typedef struct {
   fdps_fSP mass;
   fdps_fSPvec pos;
} fdps_spj_monopole_scatter;

//**** PS::SPJQuadrupoleScatter
typedef struct {
   fdps_fSP mass;
   fdps_fSPvec pos;
   fdps_fSPmat quad;
} fdps_spj_quadrupole_scatter;

//**** PS::SPJMonopoleSymmetry
typedef struct {
   fdps_fSP mass;
   fdps_fSPvec pos;
} fdps_spj_monopole_symmetry;

//**** PS::SPJQuadrupoleSymmetry
typedef struct {
   fdps_fSP mass;
   fdps_fSPvec pos;
   fdps_fSPmat quad;
} fdps_spj_quadrupole_symmetry;

//**** PS::SPJMonopoleCutoff
typedef struct {
   fdps_fSP mass;
   fdps_fSPvec pos;
} fdps_spj_monopole_cutoff;
\end{lstlisting}

それぞれの超粒子型は、FDPS 本体の相互作用ツリークラスの種類と対応している。したがって、ユーザは生成した相互作用ツリーオブジェクトの種類に応じて、対応する超粒子型を用いる必要がある。相互作用ツリーオブジェクトの種類と超粒子型の対応関係を表\ref{tbl:tree_and_super_particle}に示す。超粒子は長距離力の計算でのみ使用されるため、短距離力用のツリーはこの表に含まれていないことに注意されたい。他の種類の相互作用ツリーおよび相互作用ツリーオブジェクトを生成する方法に関しては、第\ref{chap:API_spec_list}章\ref{sec:tree_APIs}節のツリー用APIの説明とともに行う。

\begin{landscape}
\begin{table}[h]
\begin{tabularx}{\hsize}{lp{5cm}Xl}
\toprule
\rowcolor{Snow2}
ツリーの種別 & モーメント情報の計算方法$^{\dagger}$ & 相互作用範囲 & 超粒子型 \\
\midrule
Long-Monopole 型 & 単極子(重心) & 計算領域全域 & \path{fdps_spj_monopole} \\
\midrule
Long-Quadrupole 型 & 四重極子(重心)まで & 計算領域全域 & \path{fdps_spj_quadrupole} \\
\midrule
Long-MonopoleGeometricCenter 型 & 単極子(幾何中心) & 計算領域全域 & \path{fdps_spj_monopole_geomcen} \\
\midrule
Long-DipoleGeometricCenter 型 & 双極子(幾何中心)まで & 計算領域全域 & \path{fdps_spj_dipole_geomcen} \\
\midrule
Long-QuadrupoleGeometricCenter 型 & 四重極子(幾何中心)まで & 計算領域全域 & \path{fdps_spj_quadrupole_geomcen} \\
\midrule
Long-MonopoleWithScatterSearch 型$^{\ddagger}$ & 単極子(重心) & 計算領域全域  & \path{fdps_spj_monopole_scatter} \\
\midrule
Long-QuadrupoleWithScatterSearch 型$^{\ddagger}$ & 四重極子(重心)まで & 計算領域全域 & \path{fdps_spj_quadrupole_scatter} \\
\midrule
Long-MonopoleWithSymmetrySearch 型$^{\ddagger}$ & 単極子(重心) & 計算領域全域  & \path{fdps_spj_monopole_symmetry} \\
\midrule
Long-QuadrupoleWithSymmetrySearch 型$^{\ddagger}$ & 四重極子(重心)まで & 計算領域全域 & \path{fdps_spj_quadrupole_symmetry} \\
\midrule
Long-MonopoleWithCutoff 型 & 単極子(重心) & カットオフ半径内 & \path{fdps_spj_monopole_cutoff} \\
\bottomrule
\end{tabularx}
\begin{flushleft}
$^{\dagger}$ モーメントを粒子の重心を中心として計算する場合には「(重心)」、幾何中心を中心として計算する場合には「(幾何中心)」を付けて表している。\\
$^{\ddagger}$ ユーザ指定された半径を用いた近傍粒子探索が可能。相互作用計算においては、近傍粒子は超粒子に含めず通常の粒子として扱われるようになる。
\end{flushleft}

\caption{長距離力計算用ツリーの種類と対応する超粒子型}
\label{tbl:tree_and_super_particle}
\end{table}
\end{landscape}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{時間プロファイル型}
\label{sec:time_profile_types}
時間プロファイル型は、FDPS 内部で行われる各種計算に要した時間を取得するのに使用される。時間プロファイル型は\path{fdps_time_profile}の1種類が存在し、Fortranでは\path{src/fortran_interface/modules/FDPS_time_profile.F90}、C言語では\path{src/c_interface/headers/FDPS_time_profile.h}において、以下のように定義される。このデータ型はもっぱら時間取得用 API で使用される(詳細は第\ref{chap:API_spec_list}章参照)。

\begin{lstlisting}[caption=時間プロファイル型 (Fortran)]
module fdps_time_profile
   use, intrinsic :: iso_c_binding
   implicit none

   !**** PS::TimeProfile
   type, public, bind(c) :: fdps_time_prof
      real(kind=c_double) :: collect_sample_particle                                               
      real(kind=c_double) :: decompose_domain                                                      
      real(kind=c_double) :: exchange_particle                                                     
      real(kind=c_double) :: set_particle_local_tree                                               
      real(kind=c_double) :: set_particle_global_tree                                              
      real(kind=c_double) :: make_local_tree                                                       
      real(kind=c_double) :: make_global_tree                                                      
      real(kind=c_double) :: set_root_cell                                                         
      real(kind=c_double) :: calc_force                                                            
      real(kind=c_double) :: calc_moment_local_tree                                                
      real(kind=c_double) :: calc_moment_global_tree                                               
      real(kind=c_double) :: make_LET_1st                                                          
      real(kind=c_double) :: make_LET_2nd                                                          
      real(kind=c_double) :: exchange_LET_1st                                                      
      real(kind=c_double) :: exchange_LET_2nd                                                      
                                                                                                   
      real(kind=c_double) :: morton_sort_local_tree                                                
      real(kind=c_double) :: link_cell_local_tree                                                  
      real(kind=c_double) :: morton_sort_global_tree                                               
      real(kind=c_double) :: link_cell_global_tree                                                 
                                                                                                   
      real(kind=c_double) :: make_local_tree_tot                                                   
      ! = make_local_tree + calc_moment_local_tree                                                 
      real(kind=c_double) :: make_global_tree_tot                                                  
      real(kind=c_double) :: exchange_LET_tot                                                      
      ! = make_LET_1st + make_LET_2nd + exchange_LET_1st + exchange_LET_2nd                        
                                                                                                   
      real(kind=c_double) :: calc_force__core__walk_tree                                           
                                                                                                   
      real(kind=c_double) :: calc_force__make_ipgroup                                              
      real(kind=c_double) :: calc_force__core                                                      
      real(kind=c_double) :: calc_force__copy_original_order                                       
                                                                                                   
      real(kind=c_double) :: exchange_particle__find_particle                                       
      real(kind=c_double) :: exchange_particle__exchange_particle

      real(kind=c_double) :: decompose_domain__sort_particle_1st
      real(kind=c_double) :: decompose_domain__sort_particle_2nd
      real(kind=c_double) :: decompose_domain__sort_particle_3rd
      real(kind=c_double) :: decompose_domain__gather_particle

      real(kind=c_double) :: decompose_domain__setup
      real(kind=c_double) :: decompose_domain__determine_coord_1st
      real(kind=c_double) :: decompose_domain__migrae_particle_1st
      real(kind=c_double) :: decompose_domain__determine_coord_2nd
      real(kind=c_double) :: decompose_domain__determine_coord_3rd
      real(kind=c_double) :: decompose_domain__exchange_pos_domain

      real(kind=c_double) :: exchange_LET_1st__a2a_n
      real(kind=c_double) :: exchange_LET_1st__icomm_sp
      real(kind=c_double) :: exchange_LET_1st__a2a_sp
      real(kind=c_double) :: exchange_LET_1st__icomm_ep
      real(kind=c_double) :: exchange_LET_1st__a2a_ep
   end type fdps_time_prof

end module fdps_time_profile  
\end{lstlisting}

\begin{lstlisting}[language=C,caption=時間プロファイル型 (C言語)]
//**** PS::TimeProfile
typedef struct {
   double collect_sample_particle;
   double decompose_domain;
   double exchange_particle;
   double set_particle_local_tree;
   double set_particle_global_tree;
   double make_local_tree;
   double make_global_tree;
   double set_root_cell;
   double calc_force;
   double calc_moment_local_tree;
   double calc_moment_global_tree;
   double make_LET_1st;
   double make_LET_2nd;
   double exchange_LET_1st;
   double exchange_LET_2nd;
   double write_back;

   double morton_sort_local_tree;
   double link_cell_local_tree;
   double morton_sort_global_tree;
   double link_cell_global_tree;

   double make_local_tree_tot; // = make_local_tree + calc_moment_local_tree
   double make_global_tree_tot;
   double exchange_LET_tot; // = make_LET_1st + make_LET_2nd + exchange_LET_1st + exchange_LET_2nd

   double calc_force__core__walk_tree;
   double calc_force__core__keep_list;
   double calc_force__core__copy_ep;
   double calc_force__core__dispatch;
   double calc_force__core__retrieve;

   double calc_force__make_ipgroup;
   double calc_force__core;
   double calc_force__copy_original_order;

   double exchange_particle__find_particle;
   double exchange_particle__exchange_particle;
   
   double decompose_domain__sort_particle_1st;
   double decompose_domain__sort_particle_2nd;
   double decompose_domain__sort_particle_3rd;
   double decompose_domain__gather_particle;

   double decompose_domain__setup;
   double decompose_domain__determine_coord_1st;
   double decompose_domain__migrae_particle_1st;
   double decompose_domain__determine_coord_2nd;
   double decompose_domain__determine_coord_3rd;
   double decompose_domain__exchange_pos_domain;

   double exchange_LET_1st__a2a_n;
   double exchange_LET_1st__icomm_sp;
   double exchange_LET_1st__a2a_sp;
   double exchange_LET_1st__icomm_ep;
   double exchange_LET_1st__a2a_ep;

   double add_moment_as_sp_local;
   double add_moment_as_sp_global;
} fdps_time_prof;
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{列挙型}
\label{sec:enum_types}
本節では、FDPS Fortran/C言語 インターフェースで定義されている列挙型について記述する。

%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{境界条件型}
\label{subsec:enum_bc}
境界条件型は、境界条件を指定するAPI \path{set_boundary_condition} (Fortran) または \path{fdps_set_boundary_condition} (C言語)で使用される(第\ref{chap:API_spec_list}章\ref{sec:dinfo_APIs}節「領域情報オブジェクト用API」参照)。Fortranでは\path{FDPS_module.F90}において、C言語では\path{src/c_interface/headers/FDPS_enum.h}において、以下のように定義されている。

\begin{lstlisting}[caption=境界条件型 (Fortran)]
module FDPS_module
   use, intrinsic :: iso_c_binding
   implicit none
   
   !* Enum types
   !**** PS::BOUNDARY_CONDITION
   enum, bind(c)
      enumerator :: fdps_bc_open
      enumerator :: fdps_bc_periodic_x
      enumerator :: fdps_bc_periodic_y
      enumerator :: fdps_bc_periodic_z
      enumerator :: fdps_bc_periodic_xy
      enumerator :: fdps_bc_periodic_xz
      enumerator :: fdps_bc_periodic_yz
      enumerator :: fdps_bc_periodic_xyz
      enumerator :: fdps_bc_shearing_box
      enumerator :: fdps_bc_user_defined
   end enum
   
end module FDPS_module
\end{lstlisting}

\begin{lstlisting}[language=C,caption=境界条件型 (C言語)]
typedef enum {
   FDPS_BC_OPEN,
   FDPS_BC_PERIODIC_X,
   FDPS_BC_PERIODIC_Y,
   FDPS_BC_PERIODIC_Z,
   FDPS_BC_PERIODIC_XY,
   FDPS_BC_PERIODIC_XZ,
   FDPS_BC_PERIODIC_YZ,
   FDPS_BC_PERIODIC_XYZ,
   FDPS_BC_SHEARING_BOX,
   FDPS_BC_USER_DEFINED,
} FDPS_BOUNDARY_CONDITION;
\end{lstlisting}

表\ref{tbl:boundary_conditions}に、Fortranの各列挙子に対応する境界条件を示す。C言語の列挙子名は文字の大小を除き、Fortranの列挙子名と同じである。したがって、適切に読み替えて頂きたい。

\begin{table}[h]
\begin{tabularx}{\linewidth}{cX}
\toprule
\rowcolor{Snow2}
列挙子 & 境界条件 \\
\midrule
\path{fdps_bc_open} &  開放境界となる。\textbf{デフォルトではこの境界条件となる}。\\
\midrule
\path{fdps_bc_periodic_x} & $x$軸方向のみ周期境界、その他の軸方向は開放境界となる。周期の境界の下限は閉境界、上限は開境界となっている。この境界の規定はすべての軸方向にあてはまる。 \\
\midrule
\path{fdps_bc_periodic_y} & $y$軸方向のみ周期境界、その他の軸方向は開放境界となる。 \\
\midrule
\path{fdps_bc_periodic_z} & $z$軸方向のみ周期境界、その他の軸方向は開放境界となる。 \\
\midrule
\path{fdps_bc_periodic_xy} & $x$,$y$軸方向のみ周期境界、その他の軸方向は開放境界となる。 \\
\midrule
\path{fdps_bc_periodic_xz} & $x$,$z$軸方向のみ周期境界、その他の軸方向は開放境界となる。 \\
\midrule
\path{fdps_bc_periodic_yz} & $y$,$z$軸方向のみ周期境界、その他の軸方向は開放境界となる。 \\
\midrule
\path{fdps_bc_periodic_xyz} & 全方向周期境界条件。 \\
\midrule
\path{fdps_bc_shearing_box} & シアリングボックス境界条件(\textcolor{red}{現時点では未実装})。 \\
\midrule
\path{fdps_bc_user_defined} & ユーザ定義の境界条件(\textcolor{red}{現時点で未実装})。 \\
\bottomrule
\end{tabularx}
\caption{境界条件型の列挙子に対応する境界条件}
\label{tbl:boundary_conditions}
\end{table}

%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{相互作用リストモード型}
\label{subsec:enum_list_mode}
相互作用リストモード型は、相互作用計算時に相互作用リストを使い回すかどうかを決定するためのデータ型である。これは、Fortranでは、ツリーオブジェクト用API \path{calc_force_all_and_write_back} 及び \path{calc_force_all} において、C言語では、API \path{fdps_calc_force_all_and_write_back} 及び \path{fdps_calc_force_all}において、引数として使われる(第\ref{chap:API_spec_list}章\ref{sec:tree_APIs}節「ツリーオブジェクト用API」参照)。このデータ型は、Fortranでは\path{FDPS_module.F90}において、C言語では\path{src/c_interface/headers/FDPS_enum.h}において、以下のように定義されている。

\begin{lstlisting}[caption=相互作用リストモード型 (Fortran)]
module FDPS_module
   use, intrinsic :: iso_c_binding
   implicit none
   
   !* Enum types
   !**** PS::INTERACTION_LIST_MODE
   enum, bind(c)
      enumerator :: fdps_make_list
      enumerator :: fdps_make_list_for_reuse
      enumerator :: fdps_reuse_list
   end enum
   
end module FDPS_module
\end{lstlisting}

\begin{lstlisting}[language=C,caption=相互作用リストモード型 (C言語)]
typedef enum {
   FDPS_MAKE_LIST,
   FDPS_MAKE_LIST_FOR_REUSE,
   FDPS_REUSE_LIST,
} FDPS_INTERACTION_LIST_MODE;  
\end{lstlisting}

表\ref{tbl:interaction_list_mode}に、Fortanの各列挙子に対応する動作モードを示す。C言語の列挙子名はFortranの列挙子名と文字の大小を除き一致している。したがって、適切に読み替えて頂きたい。

\begin{table}[h]
\begin{tabularx}{\linewidth}{cX}
\toprule
\rowcolor{Snow2}
列挙子 & 機能 \\
\midrule
\path{fdps_make_list} & 相互作用リストを毎回作り相互作用計算を行う場合に用いる。相互作用リストの再利用はできない。\textbf{デフォルトではこの動作が仮定される}。\\
\midrule
\path{fdps_make_list_for_reuse} & 相互作用リストを再利用し相互作用計算を行いたい場合に用いる。このオプションを選択する事で FDPS は相互作用リストを作りそれを保持する。作成した相互作用リストは \path{fdps_make_list_for_reuse}、もしくは、\path{fdps_make_list}を用いて相互作用計算を行った際に破棄される。\\
\midrule
\path{fdps_reuse_list} & 事前に作成された相互作用リストを再利用して相互作用計算を行う。再利用される相互作用リストは\path{fdps_make_list_for_reuse}を選択時に作成した相互作用リストである。相互作用リストに含まれる超粒子のモーメント情報は最新の粒子情報で再計算されたものが使用される。\\
\bottomrule
\end{tabularx}
\caption{相互作用リストモード型の列挙子に対応する動作モード}
\label{tbl:interaction_list_mode}
\end{table}

