In this section, we describe the specifications of APIs related to an object of DomainInfo class in FDPS (see Chap.~\ref{chap:overview}; hereafter, we call it \textbf{DomainInfo object}). In FDPS, DomainInfo object has all information about the size of computational domain and decomposed domains and it provides an API to perform domain decomposition. In FDPS Fortran/C interface, this object is managed by an identification number.

This is the list of APIs to manipulate DomainInfo object:
\begin{screen}
\begin{spverbatim}
(fdps_)create_dinfo
(fdps_)delete_dinfo
(fdps_)init_dinfo
(fdps_)get_dinfo_time_prof
(fdps_)clear_dinfo_time_prof
(fdps_)set_nums_domain
(fdps_)set_boundary_condition
(fdps_)get_boundary_condition
(fdps_)set_pos_root_domain
(fdps_)collect_sample_particle
(fdps_)decompose_domain
(fdps_)decompose_domain_all
\end{spverbatim}  
\end{screen}
where the meaning of \texttt{(fdps\_)} is the same in the previous section.

In the following, we describe the specification of each API in the order shown above.
\clearpage

%=============================================================
\subsection{create\_dinfo}
\subsubsection*{Fortran syntax}
\begin{screen}
\begin{spverbatim}
subroutine fdps_ctrl%create_dinfo(dinfo_num)
\end{spverbatim}
\end{screen}

\subsubsection*{C syntax}
\begin{screen}
\begin{spverbatim}
void fdps_create_dinfo(int *dinfo_num);
\end{spverbatim}
\end{screen}


\subsubsection*{Dummy argument specification}
\begin{table}[h]
\begin{tabularx}{\linewidth}{cccX}
\toprule
\rowcolor{Snow2}
Name & Data type & I/O Characteristics & Definition \\
\midrule
\texttt{dinfo\_num} & integer(kind=c\_int) & Input and output & Variable receiving the identification number of a DomainInfo object. {\setnoko\Euc{Note that users need to pass the address of the variable in C}}. \\
\bottomrule
\end{tabularx}
\end{table}


\subsubsection*{Returned value}
None.

\subsubsection*{Function}
Create a DomainInfo object, and return its identification number.
\clearpage

%=============================================================
\subsection{delete\_dinfo}
\subsubsection*{Fortran syntax}
\begin{screen}
\begin{spverbatim}
subroutine fdps_ctrl%delete_dinfo(dinfo_num)
\end{spverbatim}
\end{screen}

\subsubsection*{C syntax}
\begin{screen}
\begin{spverbatim}
void fdps_delete_dinfo(const int dinfo_num);
\end{spverbatim}
\end{screen}


\subsubsection*{Dummy argument specification}
\begin{table}[h]
\begin{tabularx}{\linewidth}{cccX}
\toprule
\rowcolor{Snow2}
Name & Data type & I/O Characteristics & Definition \\
\midrule
\texttt{dinfo\_num} & integer(kind=c\_int) & Input & Variable giving the identification number of a DomainInfo object. \\
\bottomrule
\end{tabularx}
\end{table}


\subsubsection*{Returned value}
None.

\subsubsection*{Function}
Erase a DomainInfo object indicated by the identification number.

\clearpage

%=============================================================
\subsection{init\_dinfo}
\subsubsection*{Fortran syntax}
\begin{screen}
\begin{spverbatim}
subroutine fdps_ctrl%init_dinfo(dinfo_num,coef_ema)
\end{spverbatim}
\end{screen}

\subsubsection*{C syntax}
\begin{screen}
\begin{spverbatim}
void fdps_init_dinfo(const int dinfo_num,
                     const float coef_ema);
\end{spverbatim}
\end{screen}

\subsubsection*{Dummy argument specification}
\begin{table}[h]
\begin{tabularx}{\linewidth}{cccX}
\toprule
\rowcolor{Snow2}
Name & Data type & I/O Characteristics & Definition \\
\midrule
\texttt{dinfo\_num} & integer(kind=c\_int) & Input & 
Variable giving the identification number of a DomainInfo object.\\
\texttt{coef\_ema} & real(kind=c\_float) & Input & The smoothing factor of an exponential moving average. In Fortran, this argument is optional, and the default value of $1$ is used if the argument is not present. In C, if the value of this argument is either $<0$ or $>1$, the API automatically use the default value in Fortran. \\
\bottomrule
\end{tabularx}
\end{table}

\subsubsection*{Returned value}
None.

\subsubsection*{Function}
Initialize an DomainInfo object. The argument \texttt{coef\_ema} is the smoothing factor of exponential moving average and is a constant real value between 0 and 1. If other values are chosen, FDPS sends an error message and terminates the user program.  A larger \texttt{coef\_ema} weighs newer values rather than older values. In the case of unity, the domains are determined by using the newest values only and in the case of zero, they are determined by using the initial values only. Users call this API only once. The details of this function are described in the paper by Ishiyama, Fukushige \& Makino (2009, Publications of the Astronomical Society of Japan, 61, 1319)

\clearpage

%=============================================================
\subsection{get\_dinfo\_time\_prof}
\subsubsection*{Fortran syntax}
\begin{screen}
\begin{spverbatim}
subroutine fdps_ctrl%get_dinfo_time_prof(dinfo_num,prof)
\end{spverbatim}
\end{screen}

\subsubsection*{C syntax}
\begin{screen}
\begin{spverbatim}
void fdps_get_dinfo_time_prof(const int dinfo_num,
                              fdps_time_prof *prof);
\end{spverbatim}
\end{screen}

\subsubsection*{Dummy argument specification}
\begin{table}[h]
\begin{tabularx}{\linewidth}{cccX}
\toprule
\rowcolor{Snow2}
Name & Data type & I/O Characteristics & Definition \\
\midrule
\texttt{dinfo\_num} & integer(kind=c\_int) & Input & Variable giving the identification number of a DomainInfo object.\\
\texttt{prof} & type(fdps\_time\_prof) & Input and output & Variable receiving time spent by DomainInfo APIs. {\setnoko\Euc{Note that users need to pass the address of the variable in C}}. \\
\bottomrule
\end{tabularx}
\end{table}

\subsubsection*{Returned value}
None.

\subsubsection*{Function}
Set the time spent by DomainInfo APIs \texttt{(fdps\_)collect\_sample\_particle} and
\texttt{(fdps\_)decompose\_domain} to \texttt{collect\_sample\_particles} and \texttt{decompose\_domain}, respectively, which are member variables of type \texttt{fdps\_time\_prof}.

\clearpage

%=============================================================
\subsection{clear\_dinfo\_time\_prof}
\subsubsection*{Fortran syntax}
\begin{screen}
\begin{spverbatim}
subroutine fdps_ctrl%clear_dinfo_time_prof(dinfo_num)
\end{spverbatim}
\end{screen}

\subsubsection*{C syntax}
\begin{screen}
\begin{spverbatim}
void fdps_clear_dinfo_time_prof(const int dinfo_num);
\end{spverbatim}
\end{screen}

\subsubsection*{Dummy argument specification}
\begin{table}[h]
\begin{tabularx}{\linewidth}{cccX}
\toprule
\rowcolor{Snow2}
Name & Data type & I/O Characteristics & Definition \\
\midrule
\texttt{dinfo\_num} & integer(kind=c\_int) & Input & Variable giving the identification number of a DomainInfo object.\\
\bottomrule
\end{tabularx}
\end{table}

\subsubsection*{Returned value}
None.

\subsubsection*{Function}
DomainInfo object has a private variable of TimeProfile class, which is a C++ class corresponding to a derived data type \texttt{fdps\_time\_prof} in FDPS Fortran interface or a structure \texttt{fdps\_time\_prof} in FDPS C interface (for details, see the specification document of FDPS, \texttt{doc\_specs\_cpp\_en.pdf}). This API sets the the member variables \texttt{collect\_sample\_particles} and \texttt{decompose\_domain} of this private variable of the DomainInfo object indicated by \texttt{psys\_num} to 0. Usually, this API is used to reset time measurement.

\clearpage

%=============================================================
\subsection{set\_nums\_domain}
\subsubsection*{Fortran syntax}
\begin{screen}
\begin{spverbatim}
subroutine fdps_ctrl%set_nums_domain(dinfo_num,nx,ny,nz)
\end{spverbatim}
\end{screen}

\subsubsection*{C syntax}
\begin{screen}
\begin{spverbatim}
void fdps_set_nums_domain(const int dinfo_num,
                          const int nx,
                          const int ny,
                          const int nz);
\end{spverbatim}
\end{screen}

\subsubsection*{Dummy argument specification}
\begin{table}[h]
\begin{tabularx}{\linewidth}{cccX}
\toprule
\rowcolor{Snow2}
Name & Data type & I/O Characteristics & Definition \\
\midrule
\texttt{dinfo\_num} & integer(kind=c\_int) & Input & Variable giving the identification number of a DomainInfo object.\\
\texttt{nx} & integer(kind=c\_int) & Input & The number of subdomains along $x$ direction. \\
\texttt{ny} & integer(kind=c\_int) & Input & The number of subdomains along $y$ direction.\\
\texttt{nz} & integer(kind=c\_int) & Input & The number of subdomains along $x$ direction (default: 1).ã€‚\\
\bottomrule
\end{tabularx}
\end{table}


\subsubsection*{Returned value}
None.


\subsubsection*{Function}
Set the numbers of subdomains. If the API is not called: \texttt{nx}, \texttt{ny}, and \texttt{nz} are determined automatically. If the product of \texttt{nx}, \texttt{ny}, and \texttt{nz} is not equal to the total number of MPI processes, FDPS sends an error message and terminates the user program.

\clearpage

%=============================================================
\subsection{set\_boundary\_condition}
\subsubsection*{Fortran syntax}
\begin{screen}
\begin{spverbatim}
subroutine fdps_ctrl%set_boundary_condition(dinfo_num,bc)
\end{spverbatim}
\end{screen}

\subsubsection*{C syntax}
\begin{screen}
\begin{spverbatim}
void fdps_set_boundary_condition(const int dinfo_num,
                                 const int bc);
\end{spverbatim}
\end{screen}

\subsubsection*{Dummy argument specification}
\begin{table}[h]
\begin{tabularx}{\linewidth}{cccX}
\toprule
\rowcolor{Snow2}
Name & Data type & I/O Characteristics & Definition \\
\midrule
\texttt{dinfo\_num} & integer(kind=c\_int) & Input & Variable giving the identification number of a DomainInfo object.\\
\texttt{bc} & integer(kind=c\_int) & Input & Boundary conditions. \\
\bottomrule
\end{tabularx}
\end{table}

\subsubsection*{Returned value}
None.

\subsubsection*{Function}
Set the boundary condition. Input value must be one of the boundary condition types described in \S~\ref{sec:enum_types} of Chap.~\ref{chap:data_types}. Namely, when using Fortran interface, we must choose among \texttt{fdps\_bc\_open}, \texttt{fdps\_bc\_periodic\_x}, \texttt{fdps\_bc\_periodic\_y}, \texttt{fdps\_bc\_periodic\_z}, \texttt{fdps\_bc\_periodic\_xy}, \texttt{fdps\_bc\_periodic\_xz}, \texttt{fdps\_bc\_periodic\_yz}, \texttt{fdps\_bc\_periodic\_xyz}, \texttt{fdps\_bc\_shearing\_box}, and \texttt{fdps\_bc\_user\_defined} (\texttt{fdps\_bc\_shearing\_box} and \texttt{fdps\_bc\_user\_defined} \textcolor{red}{have not been implemented yet}). If the API is not called, the open boundary is used. FDPS C interface defines the corresponding boundary condition types and users must use them.

\clearpage

%=============================================================
\subsection{get\_boundary\_condition}
\subsubsection*{Fortran syntax}
\begin{screen}
\begin{spverbatim}
function fdps_ctrl%get_boundary_condition(dinfo_num)
\end{spverbatim}
\end{screen}

\subsubsection*{C syntax}
\begin{screen}
\begin{spverbatim}
int fdps_get_boundary_condition(const int dinfo_num);
\end{spverbatim}
\end{screen}

\subsubsection*{Dummy argument specification}
\begin{table}[h]
\begin{tabularx}{\linewidth}{cccX}
\toprule
\rowcolor{Snow2}
Name & Data type & I/O Characteristics & Definition \\
\midrule
\texttt{dinfo\_num} & integer(kind=c\_int) & Input & Variable giving the identification number of a DomainInfo object.\\
\bottomrule
\end{tabularx}
\end{table}

\subsubsection*{Returned value}
Type integer(kind=c\_int).

\subsubsection*{Function}
Return the information of the current boundary condition as an integer value. The possible values are integers corresponding to the enumerators of the boundary condition types described in \S~\ref{sec:enum_types} of Chap.~\ref{chap:data_types}.

\clearpage

%=============================================================
\subsection{set\_pos\_root\_domain}
\subsubsection*{Fortran syntax}
\begin{screen}
\begin{spverbatim}
subroutine fdps_ctrl%set_pos_root_domain(dinfo_num,low,high)
\end{spverbatim}
\end{screen}

\subsubsection*{C syntax}
\begin{screen}
\begin{spverbatim}
void fdps_set_pos_root_domain(const int dinfo_num,
                              const fdps_f32vec *low,
                              const fdps_f32vec *high);
\end{spverbatim}
\end{screen}

\subsubsection*{Dummy argument specification}
\begin{table}[h]
\begin{tabularx}{\linewidth}{cp{6cm}cX}
\toprule
\rowcolor{Snow2}
Name & Data type & I/O Characteristics & Definition \\
\midrule
\texttt{dinfo\_num} & integer(kind=c\_int) & Input & Variable giving the identification number of a DomainInfo object.\\
\texttt{low} & In Fortran, one of the followings: & Input & \multirow[t]{6}{\hsize}{Top vertex of the boundary (inclusive).} \\
& real(kind=c\_float), \newline\hspace{1em} dimension(space\_dim) &&\\
& real(kind=c\_double), \newline\hspace{1em}dimension(space\_dim) &&\\
& type(fdps\_f32vec) &&\\
& type(fdps\_f64vec) &&\\
& In C, \textbf{only \texttt{fdps\_f32vec *}} &&\\
\texttt{high} & the same type as \texttt{low} & Input & Bottom vertex of the boundary (exclusive). \\
\bottomrule
\end{tabularx}
\end{table}

\subsubsection*{Returned value}
None.

\subsubsection*{Function}
Set positions of vertexes of top and bottom of root domain. The API does not need to be called under open boundary condition. Every coordinate of \texttt{high} must be greater than the corresponding coordinate of \texttt{low}. Otherwise, FDPS sends a error message and terminates the user program.

\clearpage

%=============================================================
\subsection{collect\_sample\_particle}
\subsubsection*{Fortran syntax}
\begin{screen}
\begin{spverbatim}
subroutine fdps_ctrl%collect_sample_particle(dinfo_num, &
                                             psys_num,  &
                                             clear,     &
                                             weight)
\end{spverbatim}
\end{screen}

\subsubsection*{C syntax}
\begin{screen}
\begin{spverbatim}
void fdps_collect_sample_particle(const int dinfo_num,
                                  const int psys_num,
                                  const _Bool clear,
                                  const float weight);
\end{spverbatim}
\end{screen}
\clearpage

\subsubsection*{Dummy argument specification}
\begin{table}[h]
\begin{tabularx}{\linewidth}{cccX}
\toprule
\rowcolor{Snow2}
Name & Data type & I/O Characteristics & Definition \\
\midrule
\texttt{dinfo\_num} & integer(kind=c\_int) & Input & Variable giving the identification number of a DomainInfo object.\\
\texttt{psys\_num} & integer(kind=c\_int) & Input & Variable giving the identification number of a ParticleSystem object whose particles are sampled for domain decomposition. \\
\texttt{clear} & logical(kind=c\_bool) & Input & A flag whether previously sampled particles are cleared or not. When \texttt{.true.} {\small (in Fortran)}/\texttt{true} {\small (in C)} is given, the API performs clear. In Fortran, this argument is optional and when it is not present, \texttt{.true.} is assumed. \\
\texttt{weight} & real(kind=c\_float) & Input & A weight to determine the number of sampled particles for domain decomposition. In Fortran, this argument is optional and the number of local particles (i.e. the number of particles assigned to the MPI process calling this API) is used when the argument is not present. In C, when a negative value is given, the API automatically uses the default value in Fortran interface. $n_{\mathrm{smpl}}n_{\mathrm{proc}}(w_{i}/\sum_{k}w_{k})$ particles are sampled from process $i$, where $n_{\mathrm{smpl}}$ is the number of sample particles per process, which is set by API \texttt{set\_nptcl\_smpl}, $n_{\mathrm{proc}}$ is the number of MPI processes, and $w_{i}$ is the value of \texttt{weight} of process $i$. \\
\bottomrule
\end{tabularx}
\end{table}

\subsubsection*{Returned value}
None.

\subsubsection*{Function}
Sample particles from an object of {\tt ParticleSystem} class. If \texttt{clear} is true, the data of the samples collected before is cleared. Larger \texttt{weight} leads to give more sample particles.

\clearpage

%=============================================================
\subsection{decompose\_domain}
\subsubsection*{Fortran syntax}
\begin{screen} 
\begin{spverbatim}
subroutine fdps_ctrl%decompose_domain(dinfo_num)
\end{spverbatim}
\end{screen}

\subsubsection*{C syntax}
\begin{screen}
\begin{spverbatim}
void fdps_decompose_domain(const int dinfo_num);
\end{spverbatim}
\end{screen}

\subsubsection*{Dummy argument specification}
\begin{table}[h]
\begin{tabularx}{\linewidth}{cccX}
\toprule
\rowcolor{Snow2}
Name & Data type & I/O Characteristics & Definition \\
\midrule
\texttt{dinfo\_num} & integer(kind=c\_int) & Input & Variable giving the identification number of a DomainInfo object.\\
\bottomrule
\end{tabularx}
\end{table}

\subsubsection*{Returned value}
None.

\subsubsection*{Function}
Decompose calculation domains.

\clearpage

%=============================================================
\subsection{decompose\_domain\_all}
\subsubsection*{Fortran syntax}
\begin{screen}
\begin{spverbatim}
subroutine fdps_ctrl%decompose_domain_all(dinfo_num,psys_num,weight)
\end{spverbatim}
\end{screen}

\subsubsection*{C syntax}
\begin{screen}
\begin{spverbatim}
void fdps_decompose_domain_all(const int dinfo_num, 
                               const int psys_num,  
                               const float weight); 
\end{spverbatim}
\end{screen}


\subsubsection*{Dummy argument specification}
\begin{table}[h]
\begin{tabularx}{\linewidth}{cccX}
\toprule
\rowcolor{Snow2}
Name & Data type & I/O Characteristics & Definition \\
\midrule
\texttt{dinfo\_num} & integer(kind=c\_int) & Input & Variable giving the identification number of a DomainInfo object.\\
\texttt{psys\_num} & integer(kind=c\_int) & Input & Variable giving the identification number of a ParticleSystem object whose particles are sampled for domain decomposition. \\
\texttt{weight} & real(kind=c\_float) & Input & A weight to determine the number of sampled particles for domain decomposition. As for the default value and the meaning of weight, see the description in API \texttt{(fdps\_)collect\_sample\_particle}. \\
\bottomrule
\end{tabularx}
\end{table}

\subsubsection*{Returned value}
None.

\subsubsection*{Function}
Sample particles from \texttt{psys\_num} and decompose domains. This API is the combination of {\tt (fdps\_)collect\_sample\_particle} and {\tt (fdps\_)decompose\_domain}.

\clearpage
