\newcommand{\tlap}[1]{\vbox to 0pt{\vss\hbox{#1}}}
\newcommand{\blap}[1]{\vbox to 0pt{\hbox{#1}\vss}}

In this section, we describe the specifications of APIs related to an object of TreeForForce class in FDPS (see Chap.~\ref{chap:overview}; hereafter, we call it \textbf{Tree object} simply). In FDPS, Tree object provides APIs to perform the calculation of interactions. In FDPS Fortran/C interface, this object is managed by an identification number.

This is the list of APIs to manipulate Tree object:
\begin{screen}
\begin{spverbatim}
(fdps_)create_tree
(fdps_)delete_tree
(fdps_)init_tree
(fdps_)get_tree_info
(fdps_)get_tree_memsize
(fdps_)get_tree_time_prof
(fdps_)clear_tree_time_prof
(fdps_)get_num_interact_ep_ep_loc
(fdps_)get_num_interact_ep_sp_loc
(fdps_)get_num_interact_ep_ep_glb
(fdps_)get_num_interact_ep_sp_glb
(fdps_)clear_num_interact
(fdps_)get_num_tree_walk_loc
(fdps_)get_num_tree_walk_glb
(fdps_)set_particle_local_tree
(fdps_)get_force
(fdps_)calc_force_all_and_write_back
(fdps_)calc_force_all
(fdps_)calc_force_making_tree
(fdps_)calc_force_and_write_back
(fdps_)get_neighbor_list
(fdps_)get_epj_from_id
\end{spverbatim}  
\end{screen}

In the following, we first explain the types of Tree object and then we describe the specification of each API in the order shown above.
\clearpage

%=============================================================
\subsection{Types of Tree objects}
In this section, we explain the types of Tree objects and their definitions. Almost all physical interactions in the nature can be classified into long-range force and short-range force. Based on this fact, FDPS uses different types of Tree object for the calculations of long- and short-range forces. For simplicity, we call these two types \textbf{Long-type} and \textbf{Short-type}, respectively. In FDPS Fortran/C interface, these two types of Tree objects are further classified into subtypes. In the following, we explain them.

%==============================
\subsubsection{Subtypes of Long-type}
\label{subsubsec:tree_kinds_long}
Long-type is classified into ten subtypes depending on the way of the calculation of moments. A Tree object is called \textbf{Monopole type} if it computes only monopole moments of tree nodes taking their centers of mass as the centers of multipole expansions. If a Tree object computes up to quadrupole moments of tree nodes in the same way, we call it \textbf{Quadrupole type}. Multipole moments can be calculated taking the geometric centers of tree nodes as the expansion centers. To support this case, we prepare the following three subtypes of Tree object: \textbf{MonopoleGeometricCenter type}, \textbf{DipoleGeometricCenter type}, and \textbf{QuadrupoleGeometricCenter type}, where their names indicate the highest order of multipole moments calculated by these Tree objects.

In some force calculation methods such as $\mathrm{P^{3}T}$ method\footnote{The abbreviation of Particle-Particle Particle-Tree.}, it is required for users to perform neighbor search. In order to support this, we prepare the following four subtypes of Tree object: \textbf{MonopoleWithScatterSearch type},  \textbf{QuadrupoleWithScatterSearch type}, \textbf{MonopoleWithSymmetrySearch type}, and \textbf{QuadrupoleWithSymmetrySearch type}, by using which we can perform neighbor search (where ``ScatterSearch" means neighbor search with search radii of $j$-particles and ``SymmetrySearch" means that with the larger of search radii of $i$- and $j$-particles). In the above four subtypes, neighbor particles are forcibly treated as normal particles in the calculation of interaction. In other words, any superparticle in an interaction list does not contain any neighbor particle of $i$-particles. The names of these also indicate the highest order of multipole moments calculated in these Tree objects. Depending on a subtype, users need to let EssentialParticleJ, or both EssentialParticleI and EssentialParticleJ have a search radius (see \S~\ref{sec:EPI:FDPS_directives_required_in_specific_cases} and \S~\ref{sec:EPJ:FDPS_directives_required_in_specific_cases}). 

In $\mathrm{P^{3}M}$\footnote{The abbreviation of Particle-Particle Particle-Mesh.} and TreePM methods, the calculation of interactions is performed combining the direct-summation method or the tree method with the particle mesh method. In such cases, we can apply some optimization because we only have to take into account tree structure within the so-called cutoff radius, which is the distance from a particle to split force. \textbf{MonopoleWithCutoff type} is the subtype obtained by applying such optimization to Monopole-type. In this subtype of tree, the cutoff radius must be same for all particles and it is used as search radius (a radius used to collect information on $j$-particles). The search radius needs to be owned by EssentialParticleJ (see \S~\ref{sec:EPJ:FDPS_directives_required_in_specific_cases})

These are all the subtypes of Long-type in FDPS Fortran interface. The list is available in Table.~\ref{tbl:tree_and_super_particle} in \S~\ref{sec:super_particle_types}.


%==============================
\subsubsection{Subtypes of Short-type}
\label{subsubsec:tree_kinds_short}
Short-type is classified into the following three subtypes depending on the type of interaction:
\begin{enumerate}[leftmargin=*]
\litem{Gather type} This type is used when its force decays to zero at a finite distance, and when the distance is determined by the search radius of $i$-particle.
\litem{Scatter type} This type is used when its force decays to zero at a finite distance, and when the distance is determined by the search radius of $j$-particle.
\litem{Symmetry type} This type is used when its force decays to zero at a finite distance, and when the distance is determined by \Eul{the larger of} the search radii of $i$- and $j$-particles.
\end{enumerate}


\clearpage

%=============================================================
% APIÂêç::create_tree()
\subsection{create\_tree}
\subsubsection*{Fortran syntax}
\begin{screen}
\begin{spverbatim}
subroutine fdps_ctrl%create_tree(tree_num,tree_info_in)
\end{spverbatim}
\end{screen}

\subsubsection*{C syntax}
\begin{screen}
\begin{spverbatim}
void fdps_create_tree(int *tree_num,                                                                
                      char *tree_info);
\end{spverbatim}
\end{screen}

\subsubsection*{Dummy argument specification}
\begin{table}[H]
\begin{tabularx}{\linewidth}{cp{4cm}cX}
\toprule
\rowcolor{Snow2}
Name & Data type & I/O Characteristics & Definition \\
\midrule
\verb|tree_num| & integer(kind=c\_int) &  Input and output & Variable receiving the identification number of a Tree object. {\setnoko\Euc{Note that users need to pass the address of the variable in C}}. \\
\verb|tree_info_in| & character \newline (len=*,kind=c\_char) & Input & String to specify the type of a Tree object. \\
\verb|tree_info| & char * & Input & String to specify the type of a Tree object. \\
\bottomrule
\end{tabularx}
\end{table}

\subsubsection*{Returned value}
None.

\subsubsection*{Function}
Create a Tree object and returns its identifier. The type of the Tree object is indicated by string \verb|tree_info_in| {\small (in Fortran)} or \verb|tree_info| {\small (in C)}. To create a Tree object for long-range force, the string must obey the following format:
\begin{screen}
\verb|"Long,<force_type>,<epi_type>,<epj_type>,<tree_mode>"|
\end{screen}
where \verb|<tree_mode>| should be selected from
Monopole,
Quadrupole,
MonopoleGeometricCenter,
DipoleGeometricCenter,
QuadrupoleGeometricCenter,
MonopoleWithScatterSearch,
QuadrupoleWithScatterSearch,
MonopoleWithSymmetrySearch, 
QuadrupoleWithSymmetrySearch, 
MonopoleWithCutoff.
Note that {\setnoko\Euc{all the above keywords including \texttt{Long} are case-sensitive}} and users should not write the angle brackets \verb|<>|.

To create a Tree object for short-range force, the string should be written as
\begin{screen}
\verb|"Short,<force_type>,<epi_type>,<epj_type>,<search_mode>"|
\end{screen}
where \verb|<search_mode>| must be chosen from
Gather,
Scatter,
or
Symmetry.

For both cases, \verb|<force_type>|,\verb|<epi_type>|,\verb|<epj_type>| are user-defined types. Users cannot insert space characters before or after commas and {\setnoko\Euc{must specify the names of user-defined types in lower-case}}.
\clearpage

%=============================================================
\subsection{delete\_tree}
\subsubsection*{Fortran syntax}
\begin{screen}
\begin{spverbatim}
subroutine fdps_ctrl%delete_tree(tree_num)
\end{spverbatim}
\end{screen}

\subsubsection*{C syntax}
\begin{screen}
\begin{spverbatim}
void fdps_delete_tree(const int tree_num);
\end{spverbatim}
\end{screen}

\subsubsection*{Dummy argument specification}
\begin{table}[h]
\begin{tabularx}{\linewidth}{cXcX}
\toprule
\rowcolor{Snow2}
Name & Data type & I/O Characteristics & Definition \\
\midrule
\verb|tree_num| & integer(kind=c\_int) & Input & Variable giving the identification number of a Tree object. \\
\bottomrule
\end{tabularx}
\end{table}


\subsubsection*{Returned value}
None.


\subsubsection*{Function}
Delete a Tree object indicated by the identification number. \\
\clearpage

%=============================================================
\subsection{init\_tree}
\subsubsection*{Fortran syntax}
\begin{screen}
\begin{spverbatim}
subroutine fdps_ctrl%init_tree(tree_num,     &
                               nptcl,theta,  &
                               n_leaf_limit, &
                               n_group_limit)
\end{spverbatim}
\end{screen}

\subsubsection*{C syntax}
\begin{screen}
\begin{spverbatim}
void fdps_init_tree(const int tree_num,
                    const int nptcl,
                    const float theta,
                    const int n_leaf_limit,
                    const int n_group_limit);
\end{spverbatim}
\end{screen}

\clearpage

\subsubsection*{Dummy argument specification}
\begin{table}[h]
\begin{tabularx}{\linewidth}{cccX}
\toprule
\rowcolor{Snow2}
Name & Data type & I/O Characteristics & Definition \\
\midrule
\verb|tree_num|      & integer(kind=c\_int) & Input & Variable giving the identification number of a Tree object. \\
\verb|nptcl|         & integer(kind=c\_int) & Input & Upper limit for the total number of particles. \\
\verb|theta|         & real(kind=c\_float)  & Input & Opening criterion for the tree. In Fortran, this argument is optional and the value $0.7$ is used when the argument is not present. In C, when a negative value is given, the API automatically adopts the default value in Fortran. \\
\verb|n_leaf_limit|  & integer(kind=c\_int) & Input & Maximum number of particles in a leaf cell. In Fortran, this argument is optional and $8$ is used when the argument is not present. In C, when a negative integer is given, the API automatically adopts the default value in Fortran. \\ 
\verb|n_group_limit| & integer(kind=c\_int) & Input & Maximum number of particles which share the same interaction list. In Fortran, this argument is optional and $64$ is used when the argument is not present. In C, when a negative integer is given, the API automatically adopts the default value in Fortran. \\ 
\bottomrule
\end{tabularx}
\end{table}


\subsubsection*{Returned value}
None.


\subsubsection*{Function}
Initialize a Tree object indicated by the identification number.
\clearpage

%=============================================================
\subsection{get\_tree\_info}
\subsubsection*{Fortran syntax}
\begin{screen}
\begin{spverbatim}
subroutine fdps_ctrl%get_tree_info(tree_num,tree_info)
\end{spverbatim}
\end{screen}

\subsubsection*{C syntax}
\begin{screen}
\begin{spverbatim}
void fdps_get_tree_info(const int tree_num,
                        char *tree_info,
                        size_t *charlen);
\end{spverbatim}
\end{screen}

\subsubsection*{Dummy argument specification}
\begin{table}[h]
\begin{tabularx}{\linewidth}{cp{4cm}cX}
\toprule
\rowcolor{Snow2}
Name & Data type & I/O Characteristics & Definition \\
\midrule
\verb|tree_num|  & integer(kind=c\_int) & Input & Variable giving the identification number of a Tree object. \\
\verb|tree_info| & character \newline (len=*,kind=c\_char) & Input and Output & String variable receiving a string showing the type of the Tree object. {\setnoko\Euc{Note that users need to pass the address of the variable in C}}. \\
\verb|charlen| & size\_t * & Input and Output & The length of a string of characters substituted into the variable \verb|tree_into|. \\
\bottomrule
\end{tabularx}
\end{table}


\subsubsection*{Returned value}
None.


\subsubsection*{Function}
Obtain a string showing the type of the Tree object indicated by the identification number.
\clearpage

%=============================================================
\subsection{get\_tree\_memsize}
\subsubsection*{Fortran syntax}
\begin{screen}
\begin{spverbatim}
function fdps_ctrl%get_tree_memsize(tree_num)
\end{spverbatim}
\end{screen}

\subsubsection*{C syntax}
\begin{screen}
\begin{spverbatim}
long long int fdps_get_tree_memsize(const int tree_num);
\end{spverbatim}
\end{screen}


\subsubsection*{Dummy argument specification}
\begin{table}[h]
\begin{tabularx}{\linewidth}{cXcX}
\toprule
\rowcolor{Snow2}
Name & Data type & I/O Characteristics & Definition \\
\midrule
\verb|tree_num|  & integer(kind=c\_int)  & Input   & Variable giving the identification number of a Tree object. \\
\bottomrule
\end{tabularx}
\end{table}


\subsubsection*{Returned value}
Type \verb|integer(kind=c_long_long)|.


\subsubsection*{Function}
Return the size of memory used in the Tree object in bytes.

\clearpage

%=============================================================
\subsection{get\_tree\_time\_prof}
\subsubsection*{Fortran syntax}
\begin{screen}
\begin{spverbatim}
subroutine fdps_ctrl%get_tree_time_prof(tree_num,prof)
\end{spverbatim}
\end{screen}

\subsubsection*{C syntax}
\begin{screen}
\begin{spverbatim}
void fdps_get_tree_time_prof(const int tree_num,                                                    
                             fdps_time_prof *prof);
\end{spverbatim}
\end{screen}

\subsubsection*{Dummy argument specification}
\begin{table}[h]
\begin{tabularx}{\linewidth}{cXcX}
\toprule
\rowcolor{Snow2}
Name & Data type & I/O Characteristics & Definition \\
\midrule
\verb|tree_num|  & integer(kind=c\_int)   & Input     & Variable giving the identification number of a Tree object. \\
\verb|prof|      & type(fdps\_time\_prof)  & Input and output   & Structure to receive the time spent in tree APIs. {\setnoko\Euc{Note that users need to pass the address of the variable in C}}. \\
\bottomrule
\end{tabularx}
\end{table}


\subsubsection*{Returned value}
None.


\subsubsection*{Function}
Store the execution time recorded in milliseconds for
creation of local tree, 
creation of global tree, 
evaluation of force, 
evaluation of momenta of local tree, 
evaluation of momenta of global tree, 
creation of LET,
and exchange LET
to appropriate private members of type \texttt{fdps\_time\_prof},
\texttt{make\_local\_tree}, 
\texttt{make\_global\_tree},
\texttt{calc\_force},
\texttt{calc\_moment\_local\_tree},
\texttt{calc\_moment\_global\_tree},
\texttt{make\_LET\_1st\_, make\_LET\_2nd},
\texttt{exchange\_LET\_1st},
\texttt{exchange\_LET\_2nd}.

When the LET exchanging is one-step --- that in a long-range tree or a scatter mode --- the fields \texttt{make\_LET\_2nd} and \texttt{exchange\_LET\_2nd} are not stored.
\clearpage

%=============================================================
\subsection{clear\_tree\_time\_prof}
\subsubsection*{Fortran syntax}
\begin{screen}
\begin{spverbatim}
subroutine fdps_ctrl%clear_tree_time_prof(tree_num)
\end{spverbatim}
\end{screen}

\subsubsection*{C syntax}
\begin{screen}
\begin{spverbatim}
void fdps_clear_tree_time_prof(const int tree_num); 
\end{spverbatim}
\end{screen}

\subsubsection*{Dummy argument specification}
\begin{table}[h]
\begin{tabularx}{\linewidth}{cXcX}
\toprule
\rowcolor{Snow2}
Name & Data type & I/O Characteristics & Definition \\
\midrule
\verb|tree_num| & integer(kind=c\_int) & Input & Variable giving the identification number of a Tree object. \\
\bottomrule
\end{tabularx}
\end{table}

\subsubsection*{Returned value}
None.

\subsubsection*{Function}
Tree object has a private variable of TimeProfile class, which is a C++ class corresponding to a derived data type \texttt{fdps\_time\_prof} in FDPS Fortran interface or a structure \texttt{fdps\_time\_prof} in FDPS C interface (for details, see the specification document of FDPS, \texttt{doc\_specs\_cpp\_en.pdf}). This API sets the the member variables \texttt{make\_local\_tree}, \texttt{make\_global\_tree}, \texttt{calc\_force}, \texttt{calc\_moment\_local\_tree}, \texttt{calc\_moment\_global\_tree}, \texttt{make\_LET\_1st}, \texttt{make\_LET\_2nd}, \texttt{exchange\_LET\_1st}, and \texttt{exchange\_LET\_2nd} of this private variable of the Tree object indicated by \texttt{tree\_num} to 0. Usually, this API is used to reset time measurement.

\clearpage

%=============================================================
\subsection{get\_num\_interact\_ep\_ep\_loc}
\subsubsection*{Fortran syntax}
\begin{screen}
\begin{spverbatim}
function fdps_ctrl%get_num_interact_ep_ep_loc(tree_num)
\end{spverbatim}
\end{screen}

\subsubsection*{C syntax}
\begin{screen}
\begin{spverbatim}
long long int fdps_get_num_interact_ep_ep_loc(const int tree_num); 
\end{spverbatim}
\end{screen}

\subsubsection*{Dummy argument specification}
\begin{table}[h]
\begin{tabularx}{\linewidth}{cccX}
\toprule
\rowcolor{Snow2}
Name & Data type & I/O Characteristics & Definition \\
\midrule
\verb|tree_num|  & integer(kind=c\_int) & Input  & Variable giving the identification number of a Tree object. \\
\bottomrule
\end{tabularx}
\end{table}

\subsubsection*{Returned value}
Type integer(kind=c\_long\_long).

\subsubsection*{Function}
Return the number of interactions between EPI and EPJ in the MPI process calling this API.
\clearpage

%=============================================================
\subsection{get\_num\_interact\_ep\_sp\_loc}
\subsubsection*{Fortran syntax}
\begin{screen}
\begin{spverbatim}
function fdps_ctrl%get_num_interact_ep_sp_loc(tree_num)
\end{spverbatim}
\end{screen}

\subsubsection*{C syntax}
\begin{screen}
\begin{spverbatim}
long long int fdps_get_num_interact_ep_sp_loc(const int tree_num); 
\end{spverbatim}
\end{screen}

\subsubsection*{Dummy argument specification}
\begin{table}[h]
\begin{tabularx}{\linewidth}{cccX}
\toprule
\rowcolor{Snow2}
Name & Data type & I/O Characteristics & Definition \\
\midrule
\verb|tree_num|  & integer(kind=c\_int) & Input & Variable giving the identification number of a Tree object. \\
\bottomrule
\end{tabularx}
\end{table}

\subsubsection*{Returned value}
Type integer(kind=c\_long\_long).

\subsubsection*{Function}
Return the number of interactions between EPI and SPJ in the MPI process calling this API.
\clearpage

%=============================================================
\subsection{get\_num\_interact\_ep\_ep\_glb}
\subsubsection*{Fortran syntax}
\begin{screen}
\begin{spverbatim}
function fdps_ctrl%get_num_interact_ep_ep_glb(tree_num)
\end{spverbatim}
\end{screen}

\subsubsection*{C syntax}
\begin{screen}
\begin{spverbatim}
long long int fdps_get_num_interact_ep_ep_glb(const int tree_num);
\end{spverbatim}
\end{screen}

\subsubsection*{Dummy argument specification}
\begin{table}[h]
\begin{tabularx}{\linewidth}{cccX}
\toprule
\rowcolor{Snow2}
Name & Data type & I/O Characteristics & Definition \\
\midrule
\verb|tree_num|  & integer(kind=c\_int)   & Input     & Variable giving the identification number of a Tree object. \\
\bottomrule
\end{tabularx}
\end{table}

\subsubsection*{Returned value}
Type integer(kind=c\_long\_long).

\subsubsection*{Function}
Return the number of interactions between EPI and EPJ, evaluated in all the processes.
\clearpage

%=============================================================
\subsection{get\_num\_interact\_ep\_sp\_glb}
\subsubsection*{Fortran syntax}
\begin{screen}
\begin{spverbatim}
function fdps_ctrl%get_num_interact_ep_sp_glb(tree_num)
\end{spverbatim}
\end{screen}

\subsubsection*{C syntax}
\begin{screen}
\begin{spverbatim}
long long int fdps_get_num_interact_ep_sp_glb(const int tree_num);
\end{spverbatim}
\end{screen}

\subsubsection*{Dummy argument specification}
\begin{table}[h]
\begin{tabularx}{\linewidth}{cXcX}
\toprule
\rowcolor{Snow2}
Name & Data type & I/O Characteristics & Definition \\
\midrule
\verb|tree_num|  & integer(kind=c\_int) & Input & Variable giving the identification number of a Tree object. \\
\bottomrule
\end{tabularx}
\end{table}

\subsubsection*{Returned value}
Type integer(kind=c\_long\_long).

\subsubsection*{Function}
Return the number of interactions between EPI and SPJ, evaluated in all the processes.
\clearpage

%=============================================================
\subsection{clear\_num\_interact}
\subsubsection*{Fortran syntax}
\begin{screen}
\begin{spverbatim}
subroutine fdps_ctrl%clear_num_interact(tree_num)
\end{spverbatim}
\end{screen}

\subsubsection*{C syntax}
\begin{screen}
\begin{spverbatim}
void fdps_clear_num_interact(const int tree_num);
\end{spverbatim}
\end{screen}

\subsubsection*{Dummy argument specification}
\begin{table}[h]
\begin{tabularx}{\linewidth}{cXcX}
\toprule
\rowcolor{Snow2}
Name & Data type & I/O Characteristics & Definition \\
\midrule
\verb|tree_num|  & integer(kind=c\_int) & Input  & Variable giving the identification number of a Tree object. \\
\bottomrule
\end{tabularx}
\end{table}

\subsubsection*{Returned value}
None.

\subsubsection*{Function}
Zero clear the all EP-EP/EP-SP and local/global interaction counters.

\clearpage

%=============================================================
\subsection{get\_num\_tree\_walk\_loc}
\subsubsection*{Fortran syntax}
\begin{screen}
\begin{spverbatim}
function fdps_ctrl%get_num_tree_walk_loc(tree_num)
\end{spverbatim}
\end{screen}

\subsubsection*{C syntax}
\begin{screen}
\begin{spverbatim}
long long int fdps_get_num_tree_walk_loc(const int tree_num);
\end{spverbatim}
\end{screen}

\subsubsection*{Dummy argument specification}
\begin{table}[h]
\begin{tabularx}{\linewidth}{cXcX}
\toprule
\rowcolor{Snow2}
Name & Data type & I/O Characteristics & Definition \\
\midrule
\verb|tree_num|  & integer(kind=c\_int) & Input & Variable giving the identification number of a Tree object. \\
\bottomrule
\end{tabularx}
\end{table}

\subsubsection*{Returned value}
Type integer(kind=c\_long\_long).

\subsubsection*{Function}
Return the number of tree traverses for the MPI process calling this API.

\clearpage

%=============================================================
\subsection{get\_num\_tree\_walk\_glb}
\subsubsection*{Fortran syntax}
\begin{screen}
\begin{spverbatim}
function fdps_ctrl%get_num_tree_walk_glb(tree_num)
\end{spverbatim}
\end{screen}

\subsubsection*{C syntax}
\begin{screen}
\begin{spverbatim}
long long int fdps_get_num_tree_walk_glb(const int tree_num);
\end{spverbatim}
\end{screen}

\subsubsection*{Dummy argument specification}
\begin{table}[h]
\begin{tabularx}{\linewidth}{cccX}
\toprule
\rowcolor{Snow2}
Name & Data type & I/O Characteristics & Definition \\
\midrule
\verb|tree_num| & integer(kind=c\_int) & Input & Variable giving the identification number of a Tree object. \\
\bottomrule
\end{tabularx}
\end{table}

\subsubsection*{Returned value}
Type integer(kind=c\_long\_long).

\subsubsection*{Function}
Return the number of tree traverses for all the processes.
\clearpage

%=============================================================
\subsection{set\_particle\_local\_tree}
\subsubsection*{Fortran syntax}
\begin{screen}
\begin{spverbatim}  
subroutine fdps_ctrl%set_particle_local_tree(tree_num, &
                                             psys_num, &
                                             clear)
\end{spverbatim}
\end{screen}

\subsubsection*{C syntax}
\begin{screen}
\begin{spverbatim}  
void fdps_set_particle_local_tree(const int tree_num,                                               
                                  const int psys_num,                                               
                                  const _Bool clear);
\end{spverbatim}
\end{screen}

\subsubsection*{Dummy argument specification}
\begin{table}[h]
\begin{tabularx}{\linewidth}{cccX}
\toprule
\rowcolor{Snow2}
Name & Data type & I/O Characteristics & Definition \\
\midrule
\verb|tree_num| & integer(kind=c\_int) & Input & Variable giving the identification number of a Tree object.\\
\verb|psys_num| & integer(kind=c\_int) & Input & Variable giving the identification number of a ParticleSystem object.\\
\verb|clear| & logical(kind=c\_bool) & Input & A flag to clear the data of particles stored in the given Tree object. The data is cleared if it is \texttt{.true.} {\small (in Fortran)} or \texttt{true} {\small (in C)}. In Fortran, this argument is optional and the default value is \texttt{.true.}.\\
\bottomrule
\end{tabularx}
\end{table}

\subsubsection*{Returned value}
None.

\subsubsection*{Function}
It performs copying of data of particles from a ParticleSystem object specified by \texttt{psys\_num} to a Tree object specified by \texttt{tree\_num} in order to make arrays of local particles of types EPI and EPJ in the Tree object. If the argument \texttt{clear} is \texttt{.true.} {\small (in Fortran)} /\texttt{true} {\small (in C)}, this API clears all of the particle data copied so far before performing copying. If it is \texttt{.false.} {\small (in Fortran)}/\texttt{false} {\small (in C)}, the API does not clear the particle data and a new data will be copied just after (in memory) the data read so far. 
\clearpage

%=============================================================
\subsection{get\_force}
\subsubsection*{Fortran syntax}
\begin{screen}
\begin{spverbatim}  
subroutine fdps_ctrl%get_force(tree_num, &
                               i, &
                               force)
\end{spverbatim}
\end{screen}

\subsubsection*{C syntax}
\begin{screen}
\begin{spverbatim}  
void fdps_get_force(const int tree_num,                                                             
                    const fdps_s32 i,                                                               
                    const void *cptr_to_force);
\end{spverbatim}
\end{screen}

\subsubsection*{Dummy argument specification}
\begin{table}[h]
\begin{tabularx}{\linewidth}{cccX}
\toprule
\rowcolor{Snow2}
Name & Data type & I/O Characteristics & Definition \\
\midrule
\verb|tree_num| & integer(kind=c\_int) & Input & Variable giving the identification number of a Tree object.\\
\verb|i| & integer(kind=c\_int) & Input & Index of array of particles.\\
\verb|force| & Force type & Input and Output & Variable receiving the result of interaction calculation of the $i$th particle read by this Tree object. \\
\verb|cptr_to_force| & void * & Input and Output & The address of variable receiving the result of interaction calculation of the $i$th particle read by this Tree object.\\
\bottomrule
\end{tabularx}
\end{table}

\subsubsection*{Returned value}
None.

\subsubsection*{Function}
It gets the result of interaction calculation of the $i$th particle read by the Tree object specified by \texttt{tree\_num} with API \texttt{(fdps\_)set\_particle\_local\_tree} and substitutes it into the argument \texttt{force} in Fortran or the variable pointed by \verb|cptr_to_force| in C. The minimum possible value of \texttt{i} is 1 in Fortran and 0 in C. The data types of \texttt{force} and the variable pointed by \verb|cptr_to_force| must be consistent with the derived data type and the structure, respectively, employed for Force when creating the Tree object.
\clearpage

%=============================================================
\subsection{calc\_force\_all\_and\_write\_back}
\subsubsection*{Fortran syntax (for short-range force)}
\begin{screen}
\begin{spverbatim}
subroutine fdps_ctrl%calc_force_all_and_write_back(tree_num,    &
                                                   pfunc_ep_ep, &
                                                   psys_num,    &
                                                   dinfo_num,   &
                                                   list_mode)
\end{spverbatim}
\end{screen}

\subsubsection*{Dummy argument specification}
\begin{table}[h]
\begin{tabularx}{\linewidth}{clcX}
\toprule
\rowcolor{Snow2}
Name & Data type & I/O Characteristics & Definition \\
\midrule
\verb|tree_num|    & integer(kind=c\_int)   & Input     & Variable giving the identification number of a Tree object. \\
\verb|pfunc_ep_ep| & type(c\_funptr)        & Input     & Pointer to a function calculating the interactions between EPI and EPJ. \\
\verb|psys_num|    & integer(kind=c\_int)   & Input     & Variable giving the identification number of a ParticleSystem object. \\
\verb|dinfo_num|   & integer(kind=c\_int)   & Input     & Variable giving the identification number of a DomainInfo object. \\
\verb|list_mode|   & integer(kind=c\_int)   & Input     & Variable determining whether interaction lists are reused (see below for details).\\
\bottomrule
\end{tabularx}
\end{table}


\subsubsection*{Returned value}
None.


\subsubsection*{Function}
This is an API for short-range force. It calculates all the interactions over all the particles in the ParticleSystem object and write back the result to the object. The function passed to this API must have the interface described in \S~\ref{subsec:calcForceEpEp}.

The data type of the argument \texttt{list\_mode} is interaction list mode type explained in \S~\ref{subsec:enum_list_mode}. This argument controls the behavior of the API with respect to the reuse of interaction lists. The value must be either of \texttt{fdps\_make\_list}, \texttt{fdps\_make\_list\_for\_reuse}, or \texttt{fdps\_reuse\_list}. The action of the API is not determined for other values. If \texttt{fdps\_make\_list} is given, FDPS makes interaction lists newly and performs interaction calculations using them. FDPS does not store these interaction lists. Hence, we cannot reuse these lists in the next interaction calculation (in the next call of the API). If \texttt{fdps\_make\_list\_for\_reuse} is given, FDPS makes interaction lists newly and stores them internally for future reuse. Then, FDPS performs interaction list calculation. Therefore, we can reuse the interaction lists in the next interaction calculation. When \texttt{fdps\_reuse\_list} is given, FDPS performs interaction calculation using the interaction lists created previously with \texttt{fdps\_make\_list\_for\_reuse}. If \texttt{list\_mode} is omitted, FDPS acts as if \texttt{fdps\_make\_list} is given.
\clearpage

\subsubsection*{Fortran syntax (for long-range force)}
\begin{screen}
\begin{spverbatim}
subroutine fdps_ctrl%calc_force_all_and_write_back(tree_num,    &
                                                   pfunc_ep_ep, &
                                                   pfunc_ep_sp, &
                                                   psys_num,    &
                                                   dinfo_num,   &
                                                   list_mode)
\end{spverbatim}
\end{screen}

\subsubsection*{Dummy argument specification}
\begin{table}[h]
\begin{tabularx}{\linewidth}{clcX}
\toprule
\rowcolor{Snow2}
Name & Data type & I/O Characteristics & Definition \\
\midrule
\verb|tree_num|    & integer(kind=c\_int)   & Input     & Variable giving the identification number of a Tree object. \\
\verb|pfunc_ep_ep| & type(c\_funptr)        & Input     & Pointer to a function calculating the interactions between EPI and EPJ. \\
\verb|pfunc_ep_sp| & type(c\_funptr)        & Input     & Pointer to a function calculating the interactions between EPI and SPJ. \\
\verb|psys_num|    & integer(kind=c\_int)   & Input     & Variable giving the identification number of a ParticleSystem object. \\
\verb|dinfo_num|   & integer(kind=c\_int)   & Input     & Variable giving the identification number of a DomainInfo object. \\
\verb|list_mode|   & integer(kind=c\_int)   & Input     & Variable determining whether interaction lists are reused (see the descriptions in ``Fortran syntax (for short-range force)" for details).\\
\bottomrule
\end{tabularx}
\end{table}


\subsubsection*{Returned value}
None.


\subsubsection*{Function}
This is an API for long-range force and is identical to the short-range version except it takes an additional function pointer for particle-superparticle interactions.
\clearpage


\subsubsection*{C syntax (for both short- and long-range forces)}
\begin{screen}
\begin{spverbatim}
void fdps_calc_force_all_and_write_back(const int tree_num,
                                        void *(pfunc_ep_ep)(void *, int, void *, int, void *),
                                        void *(pfunc_ep_sp)(void *, int, void *, int, void *),
                                        const int psys_num,
                                        const int dinfo_num,
                                        const _Bool clear,
                                        const int list_mode);
\end{spverbatim}
\end{screen}

\subsubsection*{Dummy argument specification}
\begin{table}[h]
\begin{tabularx}{\linewidth}{cX}
\toprule
\rowcolor{Snow2}
Name & Definition \\
\midrule
\verb|tree_num|    & Variable giving the identification number of a Tree object.\\
\verb|pfunc_ep_ep| & Pointer to a function calculating the interactions between EPI and EPJ. \\
\verb|pfunc_ep_sp| & Pointer to a function calculating the interactions between EPI and SPJ. When a Tree object specified by \verb|tree_num| is a Tree object for short-range force, this argument is not used. In this case, pass \texttt{NULL} pointer. \\
\verb|psys_num|    & Variable giving the identification number of a ParticleSystem object.\\
\verb|dinfo_num|   & Variable giving the identification number of a DomainInfo object.\\
\verb|clear|       & A flag determining whether the result of the previous interaction calculation is cleared or not. If it is \texttt{true}, the previous result is cleared. \\
\verb|list_mode|   & Variable determining whether interaction lists are reused (see the descriptions in ``Fortran syntax (for short-range force)" for details). The following points should be noted. (i) The argument cannot be abbreviated. If a negative integer is given, the API automatically adopts the default mode in Fortran. (ii) Users must specify the interaction list mode types in C. \\
\bottomrule
\end{tabularx}
\end{table}

\subsubsection*{Returned value}
None.

\subsubsection*{Function}
See the descriptions for API for Fortran.

\clearpage

%=============================================================
\subsection{calc\_force\_all}
\subsubsection*{Fortran syntax (for short-range force)}
\begin{screen}
\begin{spverbatim}
subroutine fdps_ctrl%calc_force_all(tree_num,    &
                                    pfunc_ep_ep, &
                                    psys_num,    &
                                    dinfo_num,   &
                                    list_mode)
\end{spverbatim}
\end{screen}

\subsubsection*{Dummy argument specification}
\begin{table}[h]
\begin{tabularx}{\linewidth}{clcX}
\toprule
\rowcolor{Snow2}
Name & Data type & I/O Characteristics & Definition \\
\midrule
\verb|tree_num|    & integer(kind=c\_int)   & Input     & Variable giving the identification number of a Tree object. \\
\verb|pfunc_ep_ep| & type(c\_funptr)        & Input     & Pointer to a function calculating the interactions between EPI and EPJ. \\
\verb|psys_num|    & integer(kind=c\_int)   & Input     & Variable giving the identification number of a ParticleSystem object. \\
\verb|dinfo_num|   & integer(kind=c\_int)   & Input     & Variable giving the identification number of a DomainInfo object. \\
\verb|list_mode|   & integer(kind=c\_int)   & Input     & Variable determining whether interaction lists are reused (see the descriptions in ``Fortran syntax (for short-range force)" of API \texttt{(fdps\_)calc\_force\_all\_and\_write\_back} for details).\\

\bottomrule
\end{tabularx}
\end{table}

\subsubsection*{Returned value}
None.

\subsubsection*{Function}
This is an API for short-range force. This API works similarly as the API \texttt{(fdps\_)calc\_force\_all\_and\_write\_back}, but without writing back the result.
\clearpage

\subsubsection*{Fortran syntax (for long-range force)}
\begin{screen}
\begin{spverbatim}
subroutine fdps_ctrl%calc_force_all(tree_num,    &
                                    pfunc_ep_ep, &
                                    pfunc_ep_sp, &
                                    psys_num,    &
                                    dinfo_num,   &
                                    list_mode)
\end{spverbatim}
\end{screen}

\subsubsection*{Dummy argument specification}
\begin{table}[h]
\begin{tabularx}{\linewidth}{clcX}
\toprule
\rowcolor{Snow2}
Name & Data type & I/O Characteristics & Definition \\
\midrule
\verb|tree_num|    & integer(kind=c\_int)   & Input     & Variable giving the identification number of a Tree object. \\
\verb|pfunc_ep_ep| & type(c\_funptr)        & Input     & Pointer to a function calculating the interactions between EPI and EPJ. \\
\verb|pfunc_ep_sp| & type(c\_funptr)        & Input     & Pointer to a function calculating the interactions between EPI and SPJ. \\
\verb|psys_num|    & integer(kind=c\_int)   & Input     & Variable giving the identification number of a ParticleSystem object. \\
\verb|dinfo_num|   & integer(kind=c\_int)   & Input     & Variable giving the identification number of a DomainInfo object. \\
\verb|list_mode|   & integer(kind=c\_int)   & Input     & Variable determining whether interaction lists are reused (see the descriptions in ``Fortran syntax (for short-range force)" of API \texttt{(fdps\_)calc\_force\_all\_and\_write\_back} for details).\\
\bottomrule
\end{tabularx}
\end{table}


\subsubsection*{Returned value}
None.

\subsubsection*{Function}
This is an API for long-range force and it is identical to the short-range version except for the second function pointer in the arguments.
\clearpage


\subsubsection*{C syntax (for both short- and long-range forces)}
\begin{screen}
\begin{spverbatim}
void fdps_calc_force_all(const int tree_num,
                         void *(pfunc_ep_ep)(void *, int, void *, int, void *),
                         void *(pfunc_ep_sp)(void *, int, void *, int, void *),
                         const int psys_num,
                         const int dinfo_num,
                         const _Bool clear,
                         const int list_mode);
\end{spverbatim}
\end{screen}

\subsubsection*{Dummy argument specification}
\begin{table}[h]
\begin{tabularx}{\linewidth}{cX}
\toprule
\rowcolor{Snow2}
Name & Definition \\
\midrule
\verb|tree_num|    & Variable giving the identification number of a Tree object.\\
\verb|pfunc_ep_ep| & Pointer to a function calculating the interactions between EPI and EPJ.\\
\verb|pfunc_ep_sp| & Pointer to a function calculating the interactions between EPI and SPJ. When a Tree object specified by \verb|tree_num| is a Tree object for short-range force, this argument is not used. In this case, pass \texttt{NULL} pointer.\\
\verb|psys_num|    & Variable giving the identification number of a ParticleSystem object.\\
\verb|dinfo_num|   & Variable giving the identification number of a DomainInfo object.\\
\verb|clear|       & A flag determining whether the result of the previous interaction calculation is cleared or not. If it is \texttt{true}, the previous result is cleared.\\
\verb|list_mode|   & Variable determining whether interaction lists are reused (see the descriptions in ``C syntax (for both short- and long-range forces)" of API \texttt{(fdps\_)calc\_force\_all\_and\_write\_back} for details).\\

\bottomrule
\end{tabularx}
\end{table}

\subsubsection*{Returned value}
None.

\subsubsection*{Function}
See the descriptions for API for Fortran.
\clearpage

%=============================================================
\subsection{calc\_force\_making\_tree}
\subsubsection*{Fortran syntax (for short-range force)}
\begin{screen}
\begin{spverbatim}
subroutine fdps_ctrl%calc_force_making_tree(tree_num,    &
                                            pfunc_ep_ep, &
                                            dinfo_num)
\end{spverbatim}
\end{screen}

\subsubsection*{Dummy argument specification}
\begin{table}[h]
\begin{tabularx}{\linewidth}{clcX}
\toprule
\rowcolor{Snow2}
Name & Data type & I/O Characteristics & Definition \\
\midrule
\verb|tree_num|    & integer(kind=c\_int)   & Input     & Variable giving the identification number of a Tree object. \\
\verb|pfunc_ep_ep| & type(c\_funptr)        & Input     & Pointer to a function calculating the interactions between EPI and EPJ. \\
\verb|pfunc_ep_sp| & type(c\_funptr)        & Input     & Pointer to a function calculating the interactions between EPI and SPJ. \\
\verb|dinfo_num|   & integer(kind=c\_int)   & Input     & Variable giving the identification number of a DomainInfo object. \\
\bottomrule
\end{tabularx}
\end{table}

\subsubsection*{Returned value}
None.

\subsubsection*{Function}
This is an API for short-range force. This API works similarly as the API \texttt{calc\_force\_all\_and\_write\_back}, but without reading the particles from the ParticleSystem object, neither writing back the result to it. This API does not take an identification number for a ParticleSystem object.
\clearpage

\subsubsection*{Fortran syntax (for long-range force)}
\begin{screen}
\begin{spverbatim}
subroutine fdps_ctrl%calc_force_making_tree(tree_num,    &
                                            pfunc_ep_ep, &
                                            pfunc_ep_sp, &
                                            dinfo_num)
\end{spverbatim}
\end{screen}

\subsubsection*{Dummy argument specification}
\begin{table}[h]
\begin{tabularx}{\linewidth}{clcX}
\toprule
\rowcolor{Snow2}
Name & Data type & I/O Characteristics & Definition \\
\midrule
\verb|tree_num|    & integer(kind=c\_int)   & Input     & Variable giving the identification number of a Tree object. \\
\verb|pfunc_ep_ep| & type(c\_funptr)        & Input     & Pointer to a function calculating the interactions between EPI and EPJ. \\
\verb|pfunc_ep_sp| & type(c\_funptr)        & Input     & Pointer to a function calculating the interactions between EPI and SPJ. \\
\verb|dinfo_num|   & integer(kind=c\_int)   & Input     & Variable giving the identification number of a DomainInfo object. \\
\bottomrule
\end{tabularx}
\end{table}


\subsubsection*{Returned value}
None.

\subsubsection*{Function}
This is an API for long-range force and it is identical to the short-range version except for the second function pointer in the arguments.

\clearpage

\subsubsection*{C syntax (for both short- and long-range forces)}
\begin{screen}
\begin{spverbatim}
void fdps_calc_force_making_tree(const int tree_num,
                                 void *(pfunc_ep_ep)(void *, int, void *, int, void *),
                                 void *(pfunc_ep_sp)(void *, int, void *, int, void *),
                                 const int dinfo_num,
                                 const _Bool clear);
\end{spverbatim}
\end{screen}

\subsubsection*{Dummy argument specification}
\begin{table}[h]
\begin{tabularx}{\linewidth}{cX}
\toprule
\rowcolor{Snow2}
Name & Definition \\
\midrule
\verb|tree_num|    & Variable giving the identification number of a Tree object.\\
\verb|pfunc_ep_ep| & Pointer to a function calculating the interactions between EPI and EPJ.\\
\verb|pfunc_ep_sp| & Pointer to a function calculating the interactions between EPI and SPJ. When a Tree object specified by \verb|tree_num| is a Tree object for short-range force, this argument is not used. In this case, pass \texttt{NULL} pointer.\\
\verb|dinfo_num|   & Variable giving the identification number of a DomainInfo object.\\
\verb|clear|       & A flag determining whether the result of the previous interaction calculation is cleared or not. If it is \texttt{true}, the previous result is cleared.\\
\bottomrule
\end{tabularx}
\end{table}

\subsubsection*{Returned value}
None.

\subsubsection*{Function}
See the descriptions for API for Fortran.
\clearpage

%=============================================================
\subsection{calc\_force\_and\_write\_back}
\subsubsection*{Fortran syntax (for short-range force)}
\begin{screen}
\begin{spverbatim}
subroutine fdps_ctrl%calc_force_and_write_back(tree_num,   &
                                               func_ep_ep, &
                                               psys_num)
\end{spverbatim}
\end{screen}

\subsubsection*{Dummy argument specification}
\begin{table}[h]
\begin{tabularx}{\linewidth}{clcX}
\toprule
\rowcolor{Snow2}
Name & Data type & I/O Characteristics & Definition \\
\midrule
\verb|tree_num|    & integer(kind=c\_int)   & Input     & Variable giving the identification number of a Tree object. \\
\verb|pfunc_ep_ep| & type(c\_funptr)        & Input     & Pointer to a function calculating the interactions between EPI and EPJ. \\
\verb|psys_num|    & integer(kind=c\_int)   & Input     & Variable giving the identification number of a ParticleSystem object. \\
\bottomrule
\end{tabularx}
\end{table}

\subsubsection*{Returned value}
None.

\subsubsection*{Function}
This is an API for short-range force. This API works similarly as the API \texttt{calc\_force\_all\_and\_write\_back}, without reading particle from a particle-system object, making the local tree, making global tree, and calculating moments of global tree. This API does not take an identification number of a DomainInfo object.
\clearpage

\subsubsection*{Fortran syntax (for long-range force)}
\begin{screen}
\begin{spverbatim}
subroutine fdps_ctrl%calc_force_and_write_back(tree_num,    &
                                               pfunc_ep_ep, &
                                               pfunc_ep_sp, &
                                               psys_num)
\end{spverbatim}
\end{screen}

\subsubsection*{Dummy argument specification}
\begin{table}[h]
\begin{tabularx}{\linewidth}{clcX}
\toprule
\rowcolor{Snow2}
Name & Data type & I/O Characteristics & Definition \\
\midrule
\verb|tree_num|    & integer(kind=c\_int)   & Input     & Variable giving the identification number of a Tree object. \\
\verb|pfunc_ep_ep| & type(c\_funptr)        & Input     & Pointer to a function calculating the interactions between EPI and EPJ. \\
\verb|pfunc_ep_sp| & type(c\_funptr)        & Input     & Pointer to a function calculating the interactions between EPI and SPJ. \\
\verb|psys_num|    & integer(kind=c\_int)   & Input     & Variable giving the identification number of a ParticleSystem object. \\
\bottomrule
\end{tabularx}
\end{table}


\subsubsection*{Returned value}
None.

\subsubsection*{Function}
This is an API for long-range force and it is identical to the short-range version except for the second function pointer in the arguments.
\clearpage

\subsubsection*{C syntax (for both short- and long-range forces)}
\begin{screen}
\begin{spverbatim}
void fdps_calc_force_and_write_back(const int tree_num,                                             
                                    void *(pfunc_ep_ep)(void *, int, void *, int, void *),          
                                    void *(pfunc_ep_sp)(void *, int, void *, int, void *),          
                                    const int psys_num,                                             
                                    const _Bool clear);
\end{spverbatim}
\end{screen}

\subsubsection*{Dummy argument specification}
\begin{table}[h]
\begin{tabularx}{\linewidth}{cX}
\toprule
\rowcolor{Snow2}
Name & Definition \\
\midrule
\verb|tree_num|    & Variable giving the identification number of a Tree object.\\
\verb|pfunc_ep_ep| & Pointer to a function calculating the interactions between EPI and EPJ.\\
\verb|pfunc_ep_sp| & Pointer to a function calculating the interactions between EPI and SPJ. When a Tree object specified by \verb|tree_num| is a Tree object for short-range force, this argument is not used. In this case, pass \texttt{NULL} pointer.\\
\verb|dinfo_num|   & Variable giving the identification number of a DomainInfo object.\\
\verb|clear|       & A flag determining whether the result of the previous interaction calculation is cleared or not. If it is \texttt{true}, the previous result is cleared.\\
\bottomrule
\end{tabularx}
\end{table}

\subsubsection*{Returned value}
None.

\subsubsection*{Function}
See the descriptions for API for Fortran.
\clearpage

%=============================================================
\subsection{get\_neighbor\_list}
\subsubsection*{Fortran syntax}
\begin{screen}
\begin{spverbatim}
subroutine fdps_ctrl%get_neighbor_list(tree_num, &
                                       pos,      &
                                       r_search, &
                                       num_epj,  &
                                       fptr_to_EPJ)
\end{spverbatim}
\end{screen}

\subsubsection*{C syntax}
\begin{screen}
\begin{spverbatim}
void fdps_get_neighbor_list(const int tree_num,                                                     
                            const fdps_f64vec *pos,                                                 
                            const fdps_f64 r_search,                                                
                            int *num_epj,                                                           
                            void **cptr_to_epj);
\end{spverbatim}
\end{screen}
\clearpage


\subsubsection*{Dummy argument specification}
\begin{table}[h]
\begin{tabularx}{\linewidth}{cp{4cm}cX}
\toprule
\rowcolor{Snow2}
Name & Data type & I/O characteristics & Definition \\
\midrule
\verb|tree_num|  & integer(kind=c\_int) & Input & Variable giving the identification number of a Tree object.\\
\verb|pos|  & type(fdps\_f64vec) & Input & The position of a particle for which neighbor particles are searched. {\setnoko\Euc{Note that users need to pass the address of the variable in C}}. \\
\verb|r_search|  & real(kind=c\_double) & Input & The search radius of a particle for which neighbor particles are searched. \\
\verb|num_epj|  & integer(kind=c\_int)   & Input and Output & The number of neighbor particles. {\setnoko\Euc{Note that users need to pass the address of the variable in C}}.\\
\verb|fptr_to_EPJ|  & EssentialParticleJ type, dimension(:), \newline pointer & Input and Output & The pointer to the array of neighbor particles of EssentialParticleJ type.\\
\verb|cptr_to_epj| & void ** & Input and Output & The address of variable receiving the address of an array of particles of EssentialParticleJ type that are identified as neighbor particles (users need to pass the address of variable which can store the value of type \texttt{void *} because the API returns the address of an array of neighbor particles as \texttt{void *} type). \\

\bottomrule
\end{tabularx}
\end{table}

\subsubsection*{Returned value}
None.

\subsubsection*{Function}
Using the Tree object indicated by \texttt{tree\_num}, search the neighbor particles of a particle whose position and search radius are given by \texttt{pos} and \texttt{r\_search}, and store the number of the neighbor particles and the pointer to the array of particles of EssentialParticleJ type. {\setnoko\Euc{This EssentialParticleJ type must be the same as that used to create this Tree object}}.
\clearpage

%=============================================================
\subsection{get\_epj\_from\_id}
\subsubsection*{Fortran syntax}
\begin{screen}
\begin{spverbatim}
subroutine fdps_ctrl%get_epj_from_id(tree_num, &
                                     id,       &
                                     fptr_to_EPJ)
\end{spverbatim}
\end{screen}

\subsubsection*{C syntax}
\begin{screen}
\begin{spverbatim}
void * fdps_get_epj_from_id(const int tree_num,
                            const fdps_s64 id);
\end{spverbatim}
\end{screen}


\subsubsection*{Dummy argument specification}
\begin{table}[h]
\begin{tabularx}{\linewidth}{cXcX}
\toprule
\rowcolor{Snow2}
Name & Data type & I/O characteristics & Definition \\
\midrule
\verb|tree_num|  & integer(kind=c\_int)   & Input     & Variable giving the identification number of a Tree object.\\
\verb|id|  & type(kind=c\_long\_long)   & Input     & Identification number of particle you want to get.\\
\verb|fptr_to_EPJ|  & EssentialParticleJ type, \newline pointer   & Input and output     & Pointer to a EssentialParticleJ variable.\\
\bottomrule
\end{tabularx}
\end{table}


\subsubsection*{Returned value}
None in Fortran. Type \verb|void *| in C.


\subsubsection*{Function}
This API is usable \textit{only when} EssentialParticleJ type has a member variable representing particle ID (a member variable corresponding to particle ID must be specified through a FDPS directive; see \S~\ref{subsec:EssentialParticleJ}). Note that this EssentialParticleJ type must be the same data type that was specified as an argument at the creation of tree object \texttt{tree\_num} (see the description of API \texttt{(fdps\_)create\_tree}). In Fortran, this API sets the pointer to a EPJ whose particle ID is \texttt{id} to \texttt{fptr\_to\_EPJ}. If \texttt{id} is not in the list of EPJ, \texttt{fptr\_to\_EPJ} is set to \texttt{NULL()}(you can check the status of \texttt{fptr\_to\_EPJ} using the intrinsic function \texttt{associated}). The action of the API is not determined for the case that EPJ more than one have the same ID. The following is an example:
\begin{lstlisting}[caption=Example]
integer(kind=c_long_long) :: id
type(essential_particle_j), pointer :: epj

call fdps_ctrl%get_epj_from_id(tree_num,id,epj)
if (associated(epj)) then
   ! Do something using epj
   write(*,*)'id = ',epj%id
else 
   write(*,*)'epj is NULL'
end if
\end{lstlisting}
In C, this API returns the address of a EPJ whose particle ID is \texttt{id}. If \texttt{id} is not in the list of EPJ, it returns \texttt{NULL}.

\clearpage