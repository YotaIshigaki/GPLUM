In this chapter, we describe the details of \textbf{user-defined types} (derived data types (Fortran) or structures (C) that users must define) and \textbf{user-defined functions} (subroutines (Fortran) and functions (C) that users must define). The user-defined types include FullParticle type, EssentialParticleI type, EssentialParticleJ type, and Force type. The user-defined functions include calcForceEpEp defining particle-particle interaction and calcForceEpSp defining particle-superparticle interaction. This chapter describes how these types and functions should be implemented. FDPS requires that the user-defined types have quantities necessary to perform particle simulation such as the position of particle, etc. Users must tell FDPS which member variable of the user-defined types corresponds to which necessary quantity. FDPS internally performs data copy between these user-defined types according to  the ways specified by users. Therefore, users must describe their ways in the users' codes. In FDPS Fortran/C interface, all the instructions to FDPS are done by describing special directives in users' codes (hereafter, we call them (\textbf{FDPS directives}). In the following, we first describe the user-defined types and then the user-defined functions are explained.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{User-defined types}
\label{sec:user_defined_types}
We first outline user-defined types. A FullParticle type is a derived data type {\small (in Fortran)} or structure {\small (in C)} that contains all informations of a particle and it is used to create ParticleSystem object (see step 0 in \S~\ref{sec:overview_action} of Chap.~\ref{chap:overview}). EssentialParticleI type, EssentialParticleJ type, and Force type are derived data types {\small (in Fortran)} or structures {\small (in C)} that support for defining the interactions between two particles. EssentialParticleI and EssentialParticleJ types contain the quantities of $i$- and $j$- particles used for the calculation of interactions. A Force type contains the quantities of an $i$-particle used to store the results of the calculations of interactions. Since these types contain part of information of FullParticle type, it is possible to use FullParticle in place of these types. However, FullParticle type may contain other values which are not used to evaluate the calculations of interactions. It is recommended to use these types when high performance is desirable.

In the following, we first describe common rules to be satisfied when users define user-defined types. Then, we explain how to implement user-defined types in order of FullParticle type, EssentialParticleI type, EssentialParticleJ type, and Force type.

%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Common rules}
\label{subsec:common_rules_for_user_defined_types}
%%%%
\subsubsection{Requirements for Fortran syntax}
\label{s2sec:requirements_for_fortran_grammer}
In this section, we describe the minimum requirements for Fortran syntax that must be satisfied for a Fortran derived data type to be a user-defined type. As described in Chap.~\ref{chap:file_str_and_ftn_if_overview}, the Fortran interface programs send data to FDPS or receive data from FDPS through the C interface of FDPS. Hence, all the user-defined types must be \textbf{interoperable} with C according to Fortran 2003 standard. More specifically, a derived data type that is to be a user-defined type must satisfy the following conditions:
\begin{enumerate}[leftmargin=*,itemsep=-1ex,label=(\arabic*)]
\item The derived data type has the \path{bind(c)} attribute.
\item The data types of all member variables must be interoperable with C. A list of the data types interoperable with C in Fortran 2003 standard (ISO/IEC 1539-1:2004(E)) can be found at \S~15 ``Interoperability with C" of the specification document of Fortran 2003 standard\footnote{ As of writing this, it seems that we can buy the specification document of Fortran 2008 Standard (ISO/IEC 1539-1:2010(E)) only from \href{http://www.iso.org/iso/home.htm}{ISO} (International Organization for Standardization).}, unofficial documents\footnote{drafts for the documents of language specification} introduced in the page \href{https://gcc.gnu.org/wiki/GFortranStandards}{GFortranStandards} of the site \href{https://gcc.gnu.org/wiki/HomePage}{GCC Wiki}, and \href{https://gcc.gnu.org/onlinedocs/gfortran/ISO_005fC\_005fBINDING.html#ISO\_005fC\_005fBINDING}{the online document} of GNU gfortran. It is allowed that a derived data type that is interoperable with C becomes a member variable.
\item All member variables do not have the \path{allocatable} attribute.
\item All member variables do not have the \path{pointer} attribute.
\item The derived data type does not have member functions or member subroutines.
\end{enumerate}
In addition, FDPS Fortran interface requires the following conditions:
\begin{enumerate}[leftmargin=*,itemsep=-1ex,label=(\arabic*),resume]
\item The derived data type must be defined in a Fortran module.
\item The derived data type must have the \path{public} attribute.
\item Vector types and symmetric matrix types defined in Chap.~\ref{chap:data_types} are the only derived data types that can be member variables of an user-defined type.
\item The derived data type cannot have multidimensional arrays as member variables (this limitation will be removed in future).
\item When specifying the shape of a (one-dimensional) member array, users must specify it \underbold{either} of by using the \texttt{dimension} statement or by adding a string \texttt{(\textit{size})} to the right of the name of the member variable, where \textit{\texttt{size}} is the number of elements of the array.
\end{enumerate}

These are the minimum requirements that a derived data type must satisfy to be a user-defined type. In addition to these, users must specify both the type of user-defined types (FullParticle, EssentialParticleI, EssentialParticleJ, and Force) and member variables corresponding to the necessary quantities using FDPS directives explained in the next section (\S~\ref{subsubsec:FDPS_directives}). 

%%%%
\subsubsection{Requirements for C syntax}
In this section, we describe the minimum requirements for C syntax that must be satisfied for a C structure to be a user-defined type. As described in Chap.~\ref{chap:file_str_and_ftn_if_overview}, \path{FDPS_ftn_if.cpp}, one of the C interface programs, is also used in the Fortran interface. Hence, users cannot freely define a structure for a user-defined type and are subject to the limitations described in the previous section \ref{s2sec:requirements_for_fortran_grammer} when defining a user-defined type. More specifically, a structure that is to be a user-defined type must satisfy the following conditions:
\begin{enumerate}[leftmargin=*,itemsep=-1ex,label=(\arabic*)]
\item The structure must have a tag name and all characters in the tag name must be lower-case.
\item The data types of all member variables must be one of the followings. (i) Data type that corresponds to data type of Fortran which is interoperable with C in the sense of Fortran 2003 Standard (ISO/IEC 1539-1:2004(E)) (for details, see (2) in \S~\ref{s2sec:requirements_for_fortran_grammer}, or Table~\ref{tbl:interoperable_data_types} in this document).  (ii) Vector types. (iii) Symmetric matrix types. \textbf{Especially, users cannot use unsigned integer types and any pointer for data types of member variables}.
\item The structure cannot have multidimensional arrays as member variables (this limitation will be removed in future).
\item The names of all member variables must be lower-case.
\end{enumerate}

As is the case with Fortran, in addition to these conditions, users must write FDPS directives explained in the next section (\S~\ref{subsubsec:FDPS_directives}).

\subsubsection{FDPS directives usable for all the user-defined types}
\label{subsubsec:FDPS_directives}
In this section, we present the summary of FDPS directives that can be used for all of the user-defined types and how to describe them. FDPS directives specific for each user-defined type is explained in \S~\ref{subsec:FullParticle} - \ref{subsec:Force}.

There are three kinds of FDPS directives:
\begin{enumerate}[leftmargin=*,itemsep=-1ex,label=(\alph*)]
\item The directive specifying the type of a user-defined type. \label{enum:FDPS_str_dir}
\item The directives specifying which member variable corresponds to which necessary quantity. \label{enum:FDPS_mbr_dir}
\item The directives specifying the ways of data copy between different user-defined types. \label{enum:FDPS_meth_dir}
\end{enumerate}
Among them, the first two items \ref{enum:FDPS_str_dir},\ref{enum:FDPS_mbr_dir} are explained as follows.

\subsubsubsection{FDPS directive specifying the type of an user-defined type}
In order to specify which user-defined type a derived data type \textit{\texttt{type\_name}} corresponds to, users must describe directive in the following format:
\begin{screen}
\begin{Verbatim}[commandchars=\\\{\}]
type, public, bind(c) :: \vrbit{type_name} !\$fdps \vrbit{keyword}
end type [\vrbit{type_name}]
\end{Verbatim}
\end{screen}

or,

\begin{screen}
\begin{Verbatim}[commandchars=\\\{\}]
!\$fdps \vrbit{keyword}
type, public, bind(c) :: \vrbit{type_name}
end type [\vrbit{type_name}]
\end{Verbatim}
\end{screen}
where \texttt{[]} are the symbols that represents that users can omit descriptions inside the brackets (users must not write the bracket symbols \texttt{[]} in practice). All the FDPS directives start with a string \verb|!$fdps|, of which all the alphabetical characters must be lower case. As it can be seen from the fact that the string starts with !, FDPS directive is just a comment and it does not affect a Fortran program. Only the interface-generating script interprets it as a directive or an instruction by a user. \textit{\texttt{keyword}}, which follows \verb|!$fdps| with separated by one or more space character(s), is the keyword to specify the type of this user-defined type. Possible keywords include \path{FP}, \path{EPI}, \path{EPJ}, and \path{Force}, and all of these are case-sensitive. They correspond to FullParticle type, EssentialParticleI type, EssentialParticleJ type, and Force type, respectively. This directive must be described either of at the right of the name of the derived data type or at the previous line of the type definition. Users cannot start a new line in the directive. As described in \S~\ref{sec:user_defined_types}, EssentialParticleI type, EssentialParticleJ type, and Force type are subsets of FullParticle type. Hence, FullParticle type can serve as these types. In this case, please specify all relevant keywords with separating them by comma as shown in Listing~\ref{listing:FDPS_str_dir_example}:
\begin{lstlisting}[caption=An example of cases where FullParticle type serves as the others types,label=listing:FDPS_str_dir_example]
type, public, bind(c) :: full_particle !$fdps FP,EPI,EPJ,Force
end type full_particle
\end{lstlisting}
It is possible that FullParticle type serves as EssentialParticleI type only.

In order to specify which user-defined type a structure  \textit{\texttt{tag\_name}} corresponds to, users must describe directive in the following format:
\begin{screen}
\begin{Verbatim}[commandchars=\\\{\}]
struct \vrbit{tag_name} \{ //\$fdps \vrbit{keyword}
\};
\end{Verbatim}
\end{screen}

or,

\begin{screen}
\begin{Verbatim}[commandchars=\\\{\}]
//\$fdps \vrbit{keyword}
struct \vrbit{tag_name} \{
\};
\end{Verbatim}
\end{screen}

How to write a directive is almost the same as the way for Fortran case. Here we present only differences:
\begin{itemize}[leftmargin=*]
\item A comment is interpreted as a FDPS directive if a string of characters that is obtained by removing the comment symbols and all of leading blank characters from the comment starts with an isolated string of characters \verb|$fdps|. The pseudocode shown above uses comment symbol \texttt{//}. But, uses can write a FDPS directive using another comment symbols \texttt{/*},\texttt{*/} like \texttt{/* \$fdps */}.
\item A directive just before \texttt{struct} or a first directive which appears after \textit{\texttt{tag\_name}} will be interpreted as Directive \ref{enum:FDPS_str_dir} by the script. Users must describe a directive at either position, but not both.
\end{itemize}


\subsubsubsection{FDPS directives specifying the type of a member variable}
Next, we explain the FDPS directives \ref{enum:FDPS_mbr_dir}, specifying which necessary quantity a member variable corresponds to. The necessary quantities in FDPS include the charge (or mass) of particle and the position of particle. In addition, depending on the type of particle simulation, the search radius is required. In order to specify which necessary quantity member variable \textit{\texttt{mbr\_name}} of derived data type \textit{\texttt{type\_name}} corresponds to, users must describe FDPS directive(s) in the following format:
\begin{screen}
\begin{Verbatim}[commandchars=\\\{\}]
type, public, bind(c) :: \vrbit{type_name}
   \vrbit{data_type} :: \vrbit{mbr_name} !\$fdps \vrbit{keyword}
end type [\vrbit{type_name}]
\end{Verbatim}
\end{screen}

or,

\begin{screen}
\begin{Verbatim}[commandchars=\\\{\}]
type, public, bind(c) :: \vrbit{type_name}
   !\$fdps \vrbit{keyword}
   \vrbit{data_type} :: \vrbit{mbr_name} 
end type [\vrbit{type_name}]
\end{Verbatim}
\end{screen}
where we have omitted the directive specifying the type of an user-defined type for brevity. The directive starts with a string \verb|!$fdps| and, after one or more space characters, \textit{\texttt{keyword}} follows. Possible keywords include \path{id}, \path{charge}, \path{position}, \path{rsearch}, and  \path{velocity}\footnote{Note that the keyword \path{velocity} is just a reserved word in the current version and it does not change the interface programs generated.}. They correspond to the identification number of particle, the charge (mass) of particle, the position of particle, the search radius of particle, and the velocity of particle, respectively. The keywords must be lower-case. This directive must be matched with a single member variable and be described either of at the right of the name of a member variable or at the previous line of the variable declaration statement for a target member variable. 

The data type of a member variable, \textit{\texttt{data\_type}}, must match that of the corresponding necessary quantity. In the following table, we summarize the data types of the necessary quantities in FDPS:
\begin{table}[H]
\begin{tabularx}{\linewidth}{cX}
\toprule
\rowcolor{Snow2}
Name & Possible data types \\
\midrule
Identification number & \texttt{integer(kind=c\_long\_long)} \\
\midrule
\multirow{2}{*}{Charge (mass) and search radius} & \texttt{real(kind=c\_float)} \\
 & \texttt{real(kind=c\_double)} \\
\midrule
\multirow{4}{*}{Position and velocity} & \texttt{type(fdps\_f32vec)} \\
& \texttt{real(kind=c\_float), dimension(space\_dim)}$^{\dagger}$ \\
& \texttt{type(fdps\_f64vec)} \\
& \texttt{real(kind=c\_double), dimension(space\_dim)}$^{\dagger}$ \\
\bottomrule
\end{tabularx}
\begin{flushleft}
$^{\dagger}$ \texttt{space\_dim} is the spatial dimension of the simulation. If macro \path{PARTICLE_SIMULATOR_TWO_DIMENSION} is defined at the compilation, \texttt{space\_dim} is 2. Otherwise, 3 (see Chap.~\ref{chap:compile_and_macro}).
\end{flushleft}
\caption{The data types of the necessary quantities}
\end{table}

In order to specify which necessary quantity member variable \textit{\texttt{mbr\_name}} of structure \textit{\texttt{tag\_name}} corresponds to, users must describe FDPS directive(s) in the following format:
\begin{screen}
\begin{Verbatim}[commandchars=\\\{\}]
struct \vrbit{tag_name} \{
   \vrbit{data_type} \vrbit{mbr_name}; //\$fdps \vrbit{keyword}
\};
\end{Verbatim}
\end{screen}

or,

\begin{screen}
\begin{Verbatim}[commandchars=\\\{\}]
struct \vrbit{tag_name} \{
   //\$fdps \vrbit{keyword}
   \vrbit{data_type} \vrbit{mbr_name};
\};
\end{Verbatim}
\end{screen}

How to write a directive is almost the same as the way for Fortran case. Users can find data type required for each necessary quantity by replacing Fortran data type in the table by the corresponding C data type using Table~\ref{tbl:interoperable_data_types}.

\subsubsubsection{Example of writing FDPS directives}
Finally, we show examples of the implementations of FullParticle types (Listings~\ref{listing:FP_example} and \ref{listing:FP_example_in_C}). Please check the usage of two FDPS directives,  \ref{enum:FDPS_str_dir} and \ref{enum:FDPS_mbr_dir}. Note that FDPS directive \ref{enum:FDPS_meth_dir}, which is not explained here, is used in this example. For this, see the following sections.

\begin{lstlisting}[caption=An example of the implementation of an user-defined type (Fortran),label=listing:FP_example]
module user_defined_types
   use, intrinsic :: iso_c_binding
   use :: fdps_vector
   implicit none
   
   !**** Full particle type
   type, public, bind(c) :: full_particle !$fdps FP,EPI,EPJ,Force
      !$fdps copyFromForce full_particle (pot,pot) (acc,acc)
      !$fdps copyFromFP full_particle (id,id) (mass,mass) (eps,eps) (pos,pos) 
      integer(kind=c_long_long) :: id
      real(kind=c_double) :: mass !$fdps charge
      real(kind=c_double) :: eps
      type(fdps_f64vec) :: pos !$fdps position
      type(fdps_f64vec) :: vel !$fdps velocity
      real(kind=c_double) :: pot
      type(fdps_f64vec) :: acc
   end type full_particle

end module user_defined
\end{lstlisting}

\begin{lstlisting}[language=C,caption=An example of the implementation of an user-defined type (C),label=listing:FP_example_in_C]
#include "FDPS_c_if.h"
   
//**** Full particle type
typedef struct full_particle { //$fdps FP,EPI,EPJ,Force
   //$fdps copyFromForce full_particle (pot,pot) (acc,acc)
   //$fdps copyFromFP full_particle (id,id) (mass,mass) (eps,eps) (pos,pos) 
   long long int id; //$fdps id
   double mass; //$fdps charge
   double eps;
   fdps_f64vec pos; //$fdps position
   fdps_f64vec vel; //$fdps velocity
   double pot;
   fdps_f64vec acc;
} Full_particle;
\end{lstlisting}

In the following, we explain how to define each user-defined type as well as FDPS directive specific for each.

%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{FullParticle type}
\label{subsec:FullParticle}
The FullParticle type contains all information of a particle and it is required to create a ParticleSystem object (see step 0 in \S~\ref{sec:overview_action} of Chap.~\ref{chap:overview}). Users can define arbitrary member variables. However, users must specify member variables corresponding to the necessary quantities and the way of data copy between FullParticle type and the other user-defined types using FDPS directives. Below, we first describe FDPS directives always required. Then, FDPS directives required in some specific cases are described.
%%%
\subsubsection{FDPS directives always required and how to describe them}
\label{subsubsec:FP:FDPS_directives:always_required}
FDPS directives always required are as follows:
\begin{itemize}[leftmargin=*,itemsep=-1ex]
\item Directive specifying a member variable corresponding to the charge (mass) of particle.
\item Directive specifying a member variable corresponding to the position of particle.
\item Directive specifying the way of data copy from Force type, which store the results of the calculation of interactions, to FullParticle type.
\end{itemize}
The first two can be described by the method explained in \S~\ref{subsubsec:FDPS_directives}. As for the third directive, users must describe it in the following format:

\begin{screen}
\begin{Verbatim}[commandchars=\\\{\}]
type, public, bind(c) :: FP
   !\$fdps copyFromForce \vrbit{force} (\vrbit{src_mbr},\vrbit{dst_mbr}) (\vrbit{src_mbr},\vrbit{dst_mbr}) ...
end type FP
\end{Verbatim}
\end{screen}
The directive starts with a string \verb|!$fdps|. After one or more space characters follows it, users must describe the keyword \texttt{copyFromForce}. This keyword tells the interface-generating script that this directive specifies the way of data copy from Force type to FullParticle type. After the keyword \texttt{copyFromForce}, users must describe the name of the derived data type corresponding to Force type, \textit{\texttt{force}}. One or more space characters are needed between \texttt{copyFromForce} and \textit{\texttt{force}}. Then, one or more pairs of member variable names (\textit{\texttt{src\_mbr}},\textit{\texttt{dst\_mbr}}) are described. The delimiter is space characters. Each pair specifies the names of source and destination variables of copy operation. \textit{\texttt{src\_mbr}} and \textit{\texttt{dst\_mbr}} are the names of member variables of Force type and FullParticle type, respectively. Users cannot start a new line in the directive.

In C, users must describe a directive in the following format:
\begin{screen}
\begin{Verbatim}[commandchars=\\\{\}]
struct fp \{
   //\$fdps copyFromForce \vrbit{force} (\vrbit{src_mbr},\vrbit{dst_mbr}) (\vrbit{src_mbr},\vrbit{dst_mbr}) ...
\}
\end{Verbatim}
\end{screen}
How to write a directive is the same as the way for Fortran case.


In some particle simulations, users may have to define multiple interactions, hence multiple corresponding Force types for a single FullParticle type. In such cases, users must describe this FDPS directive for each Force type.

An example of this FDPS directive is shown in Listing~\ref{listing:FP_example} and please check it.


%%%
\subsubsection{FDPS directives required in specific cases and how to describe them}
In this section, we describe FDPS directives in the following cases:
\begin{enumerate}[leftmargin=*,itemsep=-1ex,label=(\roman*)]
\item Cases where the following types of Tree objects are used:
\begin{itemize}
\item Long-MonopoleWithScatterSearch type
\item Long-QuadrupoleWithScatterSearch type
\item Long-MonopoleWithSymmetrySearch type
\item Long-QuadrupoleWithSymmetrySearch type
\item Long-MonopoleWithCutoff type
\item All Short types
\end{itemize}\item Case that users use the extended feature ``Particle Mesh"
\item Case that FullParticle type serves as other user-defined types
\end{enumerate}

In case (i), users must specify a member variable corresponding to the search radius (for the types of Tree objects, see Chap.~\ref{chap:API_spec_list}). This can be specified by the method described in \S~\ref{subsubsec:FDPS_directives}.

In case (ii), users must specify the way of copying the results of force calculation performed in the Particle Mesh module of FDPS to FullParticle type. This can be done by the following FDPS directive:
\begin{screen}
\begin{Verbatim}[commandchars=\\\{\}]
type, public, bind(c) :: FP
   !\$fdps copyFromForcePM \vrbit{mbr_name}
end type FP
\end{Verbatim}
\end{screen}
The FDPS directive begins with a string \verb|!$fdps|, which is followed by the keyword \texttt{copyFromForcePM} after the lapse of one or more space characters. This keyword tells FDPS that this directive specifies the way of copying data from the Particle Mesh module of FDPS to FullParticle type. Next to the keyword, users must describe the name of a member variable of FullParticle type, \textit{\texttt{mbr\_name}}, to receive data from the Particle Mesh module. One or more space characters should be needed between \texttt{copyFromForcePM} and \textit{\texttt{mbr\_name}}. The data type of this member variable must be vector type defined Chap.~\ref{chap:data_types}. Users cannot start a new line in the FDPS directive.
% [TODO] コピー先が要素数2or3の配列で機能するかを確認。

In C, users must describe a directive in the following format:
\begin{screen}
\begin{Verbatim}[commandchars=\\\{\}]
struct FP \{
   //\$fdps copyFromForcePM \vrbit{mbr_name}
\};
\end{Verbatim}
\end{screen}
How to write a directive is the same as the way for Fortran case.


In case (iii), users must describe all FDPS directives that are required in other user-defined types. Please see the sections of the corresponding user-defined types on these points.

%%%%%%%%%%%%%%%%%%%%%%%%%%%\subsection{EssentialParticleI type}
\label{subsec:EssentialParticleI}
The EssentialParticleI type should contain all information of an $i$-particle and it is necessary to define subroutines calculating interaction and to create Tree objects. EssentialParticleI type is a subset of FullParticle type (\S~\ref{subsec:FullParticle}). Users must specify member variables corresponding to the necessary quantities and the way of copying data from FullParticle type to EssentialParticleI type. Below, we first describe FDPS directives always required. Then, FDPS directives required in some specific cases are described.

%%%
\subsubsection{FDPS directives always required and how to describe them}
\label{subsubsec:EPI:FDPS_directives:always_required}
FDPS directives always required are as follows:
\begin{itemize}[leftmargin=*,itemsep=-1ex]
\item Directive specifying a member variable corresponding to the charge (mass) of particle.
\item Directive specifying a member variable corresponding to position of particle.
\item Directive specifying the way of data copy from FullParticle type to EssentialParticleI type.
\end{itemize}
The first two can be described by the method explained in \S~\ref{subsubsec:FDPS_directives}. As for the third directive, users must describe it in the following format:
\begin{screen}
\begin{Verbatim}[commandchars=\\\{\}]
type, public, bind(c) :: EPI
   !\$fdps copyFromFP \vrbit{fp} (\vrbit{src_mbr},\vrbit{dst_mbr}) (\vrbit{src_mbr},\vrbit{dst_mbr}) ...
end type EPI
\end{Verbatim}
\end{screen}
The format of this directive is the same as that of the \texttt{copyFromForce} directive described in \S~\ref{subsubsec:FP:FDPS_directives:always_required} except (i) that the keyword following a string \verb|!$fdps| is \texttt{copyFromFP} and (ii) that \textit{\texttt{fp}} is the name of a derived data type corresponding to FullParticle type. Note that \textit{\texttt{src\_mbr}} is the name of a member variable of FullParticle type in this case.

In C, users must describe a directive in the following format:
\begin{screen}
\begin{Verbatim}[commandchars=\\\{\}]
struct epi \{
   //\$fdps copyFromFP \vrbit{fp} (\vrbit{src_mbr},\vrbit{dst_mbr}) (\vrbit{src_mbr},\vrbit{dst_mbr}) ...
\};
\end{Verbatim}
\end{screen}
How to write a directive is the same as the way for Fortran case.


%%%
\subsubsection{FDPS directives required in specific cases and how to describe them}
\label{sec:EPI:FDPS_directives_required_in_specific_cases}
In this section, we describe FDPS directives in the following cases:
\begin{enumerate}[leftmargin=*,itemsep=-1ex,label=(\roman*)]
\item Cases where the following types of Tree objects are used:
\begin{itemize}
\item Long-MonopoleWithSymmetrySearch type
\item Long-QuadrupoleWithSymmetrySearch type
\item Short-Gather type
\item Short-Symmetry type
\end{itemize}
\item Case that EssentialParticleI type serves as other user-defined types
\end{enumerate}

In case (i), users must specify a member variable corresponding to the search radius (for the types of Tree objects, see Chap.~\ref{chap:API_spec_list}). This can be done by the method explained in \S~\ref{subsubsec:FDPS_directives}.

In case (ii), users must describe all FDPS directives that are required in other user-defined types. Please see the sections of the corresponding user-defined types on these points.


%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{EssentialParticleJ type}
\label{subsec:EssentialParticleJ}
The EssentialParticleJ type should contain all information of an $j$-particle and it is necessary to define subroutines calculating interaction and to create Tree objects. EssentialParticleJ type is a subset of FullParticle type (\S~\ref{subsec:FullParticle}). Users must specify member variables corresponding to the necessary quantities and the way of copying data from FullParticle type to EssentialParticleJ type. Below, we first describe FDPS directives always required. Then, FDPS directives required in some cases are described.

%%%
\subsubsection{FDPS directives always required and how to describe them}
FDPS directives always required are as follows:
\begin{itemize}[leftmargin=*,itemsep=-1ex]
\item Directive specifying a member variable corresponding to the charge (mass) of particle.
\item Directive specifying a member variable corresponding to position of particle.
\item Directive specifying the way of data copy from FullParticle type to EssentialParticleJ type.
\end{itemize}
The first two can be described by the method explained in \S~\ref{subsubsec:FDPS_directives}. The third directive must be described by the \texttt{copyFromFP} directive explained in \S~\ref{subsubsec:EPI:FDPS_directives:always_required}.

%%%
\subsubsection{FDPS directives required in specific cases and how to describe them}
\label{sec:EPJ:FDPS_directives_required_in_specific_cases}
In this section, we describe FDPS directives in the following cases:
\begin{enumerate}[leftmargin=*,itemsep=-1ex,label=(\roman*)]
\item Cases where the following types of Tree objects are used:
\begin{itemize}
\item Long-MonopoleWithScatterSearch type
\item Long-QuadrupoleWithScatterSearch type
\item Long-MonopoleWithSymmetrySearch type
\item Long-QuadrupoleWithSymmetrySearch type
\item Long-MonopoleWithCutoff type
\item All Short types
\end{itemize}
\item Case that EssentialParticleJ serves as other user-defined types
\item Case that you want to get data of particle of type EssentialParticleJ having a particular particle ID (In other words, case that you want to use API \texttt{(fdps\_)get\_epj\_from\_id}; Only the name of API for C has the prefix \texttt{fdps\_})
\end{enumerate}

In case (i), users must specify a member variable corresponding to the search radius (for the types of Tree objects, see Chap.~\ref{chap:API_spec_list}). This can be described by the method explained in \S~\ref{subsubsec:FDPS_directives}.

In case (ii), users must describe all FDPS directives that are required in other user-defined types. Please see the sections of the corresponding user-defined types on these points.

In case (iii), users must specify a member variable giving particle ID using a FDPS directive. How to write has already been explained in \S~\ref{subsubsec:FDPS_directives}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Force type}
\label{subsec:Force}
The Force type contains the results of the calculation of interactions and it is necessary to define subroutines {\small (in Fortran)} or functions {\small (in C)} that calculates interaction and to create Tree objects. Below, we first describe FDPS directives always required. Then, FDPS directives required in some cases are described.

%%%
\subsubsection{FDPS directives always required and their description methods}
FDPS directive always required is the directive specifying how to initialize Force type before the calculation of interactions. There are \uline{three ways} to specify the way of initialization. Users must specify the initialization method by one method. Below, we explain each format.

\begin{enumerate}[leftmargin=*,label=(\arabic*)]
% すべてのメンバ変数をデフォルト初期化する場合  
\litem{Case that one wants to initialize all member variables by the default initialization of FDPS} If users do not describe anything about the initialization, FDPS Fortran/C interface automatically applies the FDPS's default initialization, which sets integers and floating point numbers to 0, logical variables to \texttt{.false.}/\texttt{false}, and all the components of vector types and symmetric matrix types defined in Chap.~\ref{chap:data_types} to 0.
% 個別に指定したい場合
\litem{Case that one wants to initialize member variables individually}
In Fortran, users can specify the initial values of member variables individually by the following directive:
\begin{screen}
\begin{Verbatim}[commandchars=\\\{\}]
type, public, bind(c) :: Force
   !\$fdps clear [\vrbit{mbr}=\vrbit{val}, \vrbit{mbr}=keep, ...] 
end type Force
\end{Verbatim}
\end{screen}
where \texttt{Force} is the name of a derived data type corresponding to Force type. For brevity, we have omitted FDPS directive specifying that this derived data type is Force type. A string \texttt{!\$fdps} shows the beginning of the directive. After one or more space characters, the keyword \texttt{clear} follows. This keyword tells FDPS that this directive specifies the way of initialization of Force type. Brackets \texttt{[]} after the keyword \texttt{clear} is the symbols that represents that users can omit descriptions inside of the brackets. Do not describe the bracket symbols \texttt{[]} in actual users' codes.

The way of the initialization of each member variable is described after the keyword \texttt{clear}. FDPS Fortran interface automatically applies the FDPS's default initialization for the member variables not specified here. There are two syntaxes to specify the way to initialize. In the following, we explain them.

In order to set member variable \textit{\texttt{mbr}} to value \textit{\texttt{val}}, users must use the \texttt{\textit{mbr}=\textit{val}} syntax, where we can insert one or more space characters before or after the symbol \texttt{=}. The data type of \textit{\texttt{val}} must be consistent with that of \textit{\texttt{mbr}}. Furthermore, \textit{\texttt{val}} must be described according to the language specification of Fortran. For instance, if \textit{\texttt{mbr}} is logical type, \textit{\texttt{val}} must be either \texttt{.true.} or \texttt{.false.}. If \textit{\texttt{mbr}} is a vector or a symmetric matrix, only the initialization that sets all the components to the same value is allowed, and \textit{\texttt{val}} must be scalar value. If you want to set each component of vector or symmetric matrix to a different value, please use the FDPS directive explained in the next item.

To avoid the initialization of member variable \textit{\texttt{mbr}}, users should use the \texttt{\textit{mbr}=keep} syntax. The word \texttt{keep} in the right-hand side instructs FDPS to skip the initialization of a member variable written in the left-hand side. Again, we can insert one or more space characters before or after the symbol \texttt{=}.

Users can specify the ways of initialization of several member variables. In that case, please describe the syntaxes in a line with separating them by comma.

In C, users can specify the initial values of member variables individually by the following directive:
\begin{screen}
\begin{Verbatim}[commandchars=\\\{\}]
struct force \{
   //\$fdps clear [\vrbit{mbr}=\vrbit{val}, \vrbit{mbr}=keep, ...] 
\};
\end{Verbatim}
\end{screen}
How to write a directive is the same as the way for Fortran case.


% 複雑な初期化を行いたい場合
\litem{Case that one wants to initialize in a more complex way}
A more complex initialization can be performed by using a Fortran subroutine. In this case, users must describe the following directive:
\begin{screen}
\begin{Verbatim}[commandchars=\\\{\}]
type, public, bind(c) :: Force
   !\$fdps clear subroutine \vrbit{subroutine_name}
end type Force
\end{Verbatim}
\end{screen}
where \textit{\texttt{subroutine\_name}} is the name of a Fortran subroutine used to initialize Force type. This subroutine must be defined in the global region or the global namespace. In other words, this subroutine must not be defined in a Fortran module or as an internal procedure. It must have the following interface:
\begin{screen}
\begin{Verbatim}[commandchars=\\\{\}]
subroutine \vrbit{subroutine_name}(f) bind(c)
   use, intrinsic :: iso_c_binding
   implicit none
   type(Force), intent(inout) :: f
   
   ! Initialize Force
   
end subroutine [\vrbit{subroutine_name}]
\end{Verbatim}
\end{screen}
where \texttt{[]} is the same symbols used in the previous item.

In C, the directive must be written in the following format:
\begin{screen}
\begin{Verbatim}[commandchars=\\\{\}]
struct force \{
   //\$fdps clear function \vrbit{function_name}
\};
\end{Verbatim}
\end{screen}
How to write a directive is the same as the way for Fortran case. This function must be defined in the global region or the global namespace. It must have the following interface:
\begin{screen}
\begin{Verbatim}[commandchars=\\\{\}]
void \vrbit{function_name}(struct force *f) \{
   
   // Initialize Force
   
\}
\end{Verbatim}
\end{screen}

\end{enumerate}

%%%
\subsubsection{FDPS directives required in specific cases and how to describe them}
None.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{User-defined functions}
\label{sec:user_defined_function}
We first outline user-defined functions. Functions calcForceEpEp and calcForceSpEp are the functions that calculate action from $j$-particles to $i$-particle and action from superparticles to $i$-particle, respectively. The function pointers of these functions are passed to APIs for Tree objects as arguments. If the type of interaction is short-range force, superparticle is not required. In this case, users do not need to define calcForceEpSp.

%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Common rules}
%%%%
\subsubsection{Requirements for Fortran syntax}
\label{s2sec:requirements_for_ftn_grammer_for_udt_func}
In this section, we describe the minimum requirements for Fortran syntax that must be satisfied for a Fortran subroutine to be a user-defined function. To explain this, we first summarize the procedures to be followed when users perform the calculation of interaction using FDPS Fortran interface. Assuming that the interface programs are successfully generated, the procedures are as follows:
\begin{enumerate}[leftmargin=*,itemsep=-1ex,label=(\Roman*)]
\item Implement Fortran subroutine(s) that define interaction between particles.
\item Prepare variables to store the C addresses of Fortran subroutines in user's codes. The data type of them must be the derived data type \path{type(c_funloc)}, which is defined in the module \path{iso_c_binding} introduced in Fortran 2003 standard. \label{enum:user_defined_func_proc2}
\item Get the C addresses of the Fortran subroutines that are used in the interaction calculation by using the function \path{c_funloc}, which is also provided by the module \path{iso_c_binding}, and store them in the variables prepared in the step \ref{enum:user_defined_func_proc2}. \label{enum:user_defined_func_proc3}
\item Call a Fortran API to perform the interaction calculation, where the variables storing the C addresses (see the step \ref{enum:user_defined_func_proc3}) are passed to the API as arguments.
\item FDPS interprets or regards the Fortran subroutines specified by the C addresses as C functions and performs the interaction calculation.
\end{enumerate}
In the step \ref{enum:user_defined_func_proc3}, the Fortran subroutines must be interoperable with C in order to get their C addresses by using the function \path{c_funloc}. More specifically, a Fortran subroutine can be a user-defined function if the following conditions are satisfied:
\begin{enumerate}[leftmargin=*,itemsep=-1ex,label=(\arabic*)]
\item a Fortran subroutine must have the \path{bind(c)} attribute.
\item All the data types of dummy arguments must be the data types that are interoperable with C. More information for such data types can be found in \S~\ref{subsec:common_rules_for_user_defined_types}.
\end{enumerate}

In addition to the conditions described in the previous section, there are some requirements due to the the specification of FDPS itself. They are as follows:
\begin{enumerate}[leftmargin=*,itemsep=-1ex,label=(\arabic*),resume]
\item The dummy arguments corresponding to the numbers of $i$-particles and $j$-particles must have the \path{value} attribute, which is an attribute introduced in Fortran 2003 standard and which specifies that an argument is a pass-by-value argument. 
\end{enumerate}

These are the minimum requirements that a user-defined function must satisfy. To help users to understand, we show the implementation of the user-defined function used in the $N$-body sample code in Listing~\ref{listing:user_defined_func_example} as an example. Because we have not yet explained the detail of the method of describing user-defined functions, please confirm the locations of the \path{bind(c)} attribute and the \path{value} attribute only for now. 

\begin{lstlisting}[caption=An example of the implementation of an user-defined function defining particle-particle interaction in $N$-body simulation,label=listing:user_defined_func_example]
subroutine calc_gravity_pp(ep_i,n_ip,ep_j,n_jp,f) bind(c)
   integer(c_int), intent(in), value :: n_ip,n_jp
   type(full_particle), dimension(n_ip), intent(in) :: ep_i
   type(full_particle), dimension(n_jp), intent(in) :: ep_j
   type(full_particle), dimension(n_ip), intent(inout) :: f
   !* Local variables
   integer(c_int) :: i,j
   real(c_double) :: eps2,poti,r3_inv,r_inv
   type(fdps_f64vec) :: xi,ai,rij
      
   do i=1,n_ip
      eps2 = ep_i(i)%eps * ep_i(i)%eps
      xi%x = ep_i(i)%pos%x
      xi%y = ep_i(i)%pos%y
      xi%z = ep_i(i)%pos%z
      ai%x = 0.0d0
      ai%y = 0.0d0
      ai%z = 0.0d0
      poti = 0.0d0
      do j=1,n_jp
         rij%x  = xi%x - ep_j(j)%pos%x
         rij%y  = xi%y - ep_j(j)%pos%y
         rij%z  = xi%z - ep_j(j)%pos%z
         r3_inv = rij%x*rij%x &
                + rij%y*rij%y &
                + rij%z*rij%z &
                + eps2
         r_inv  = 1.0d0/sqrt(r3_inv)
         r3_inv = r_inv * r_inv
         r_inv  = r_inv * ep_j(j)%mass
         r3_inv = r3_inv * r_inv
         ai%x   = ai%x - r3_inv * rij%x
         ai%y   = ai%y - r3_inv * rij%y
         ai%z   = ai%z - r3_inv * rij%z
         poti   = poti - r_inv
      end do
      f(i)%pot   = f(i)%pot   + poti
      f(i)%acc%x = f(i)%acc%x + ai%x
      f(i)%acc%y = f(i)%acc%y + ai%y
      f(i)%acc%z = f(i)%acc%z + ai%z
   end do

end subroutine calc_gravity_pp
\end{lstlisting}

%%%%
\subsubsection{Requirements for C syntax}
Unlike the Fortran case (see \S~\ref{s2sec:requirements_for_ftn_grammer_for_udt_func}), users can obtain addresses of functions freely. Hence, there is no limitation with respect to the C grammar when writing a user-defined function by a \texttt{void} function. However, the interface of user-defined function is fixed by the C++ core part of FDPS and therefore a user-defined function written in C must fulfill its specification described in the next section.



%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{calcForceEpEp}
\label{subsec:calcForceEpEp}
Function calcForceEpEp defines the interaction between two particles and it is required for the calculation of interactions. Users must define function calcForceEpEp according to the following format:

\subsubsection*{Fortran syntax}
\begin{screen}
\begin{Verbatim}[commandchars=\\\{\}]
subroutine calc_force_ep_ep(ep_i,n_ip,ep_j,n_jp,f) bind(c)
   use, intrinsic :: iso_c_binding
   implicit none
   integer(kind=c_int), intent(in), value :: n_ip,n_jp
   type(essential_particle_i), dimension(n_ip), intent(in) :: ep_i
   type(essential_particle_j), dimension(n_jp), intent(in) :: ep_j
   type(force), dimension(n_ip), intent(inout) :: f
   
end subroutine calc_force_ep_ep
\end{Verbatim}
\end{screen}

\subsubsection*{C syntax}
\begin{screen}
\begin{Verbatim}[commandchars=\\\{\}]
void calc_force_ep_ep(struct essential_particle_i *ep_i,
                      int n_ip,
                      struct essential_particle_j *ep_j,
                      int n_jp,
                      force *f) \{
                        
\}
\end{Verbatim}
\end{screen}


% 仮引数
\subsubsection*{Dummy argument specification}
\begin{table}[H]
\begin{tabularx}{\linewidth}{cccX}
\toprule
\rowcolor{Snow2}
Name & Data type & I/O characteristics & Definition \\
\midrule
\texttt{n\_ip} & integer(kind=c\_int) & Input & The number of $i$-particles. \\
\texttt{n\_jp} & integer(kind=c\_int) & Input & The number of $j$-particles. \\
\texttt{ep\_i} & essential\_particle\_i type$^{\dagger}$ & Input & Array of $i$-particles. \\
\texttt{ep\_j} & essential\_particle\_j type$^{\dagger}$ & Input & Array of $j$-particles. \\
\texttt{f} & force type$^{\dagger}$ & Input and Output & Array of the results of interaction of $i$-particles. \\
\bottomrule
\end{tabularx}
\begin{flushleft}
$^{\dagger}$ The names of derived data types {\small (Fortran)} or structures {\small (C)} of EssentialParticleI type, EssentialParticleJ type, and Force types, respectively. In Fortran, if these derived data types are defined in Fortran modules different from the module that defines calcForceEpEp, users must \path{use} these modules in calcForceEpEp. Similarly, necessary header files must be included in the file defining calcForceEpEp.
\end{flushleft}
\end{table}


% 返り値
\subsubsection*{Returned value}
None.

% 機能
\subsubsection*{Function}
Calculates the interaction to $i$-particle from $j$-particle.


%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{calcForceEpSp}
\label{subsec:calcForceEpSP}
Function calcForceEpSp defines the interaction to a particle from superparticle and it is required for the calculation of interactions. Users must define function calcForceEpSp according to the following format:

\subsubsection*{Fortran syntax}
\begin{screen}
\begin{Verbatim}[commandchars=\\\{\}]
subroutine calc_force_ep_sp(ep_i,n_ip,ep_j,n_jp,f) bind(c)
   use, intrinsic :: iso_c_binding
   use :: fdps_super_particle
   implicit none
   integer(kind=c_int), intent(in), value :: n_ip,n_jp
   type(essential_particle_i), dimension(n_ip), intent(in) :: ep_i
   type(super_particle_j), dimension(n_jp), intent(in) :: ep_j
   type(force), dimension(n_ip), intent(inout) :: f
   
end subroutine calc_force_ep_sp
\end{Verbatim}
\end{screen}

\subsubsection*{C syntax}
\begin{screen}
\begin{Verbatim}[commandchars=\\\{\}]
void calc_force_ep_sp(struct essential_particle_i *ep_i,
                      int n_ip,
                      struct super_particle_j *ep_j,
                      int n_jp,
                      force *f) \{
   
\}
\end{Verbatim}
\end{screen}

% 仮引数
\subsubsection*{Dummy argument specification}
\begin{table}[H]
\begin{tabularx}{\linewidth}{cccX}
\toprule
\rowcolor{Snow2}
Name & Data type & I/O characteristics & Definition \\
\midrule
\texttt{n\_ip} & integer(kind=c\_int) & Input & The number of $i$-particles. \\
\texttt{n\_jp} & integer(kind=c\_int) & Input & The number of superparticles. \\
\texttt{ep\_i} & essential\_particle\_i type$^{\dagger}$ & Input & Array of $i$-particles. \\
\texttt{ep\_j} & super\_particle\_j type$^{\ddagger}$ & Input & Array of superparticles.\\
\texttt{f} & force type$^{\dagger}$ & Input and Output & Array of the results of interaction of $i$-particles. \\
\bottomrule
\end{tabularx}
\begin{flushleft}
$^{\dagger}$ The names of derived data types {\small (Fortran)} or structures {\small (C)} of EssentialParticleI type and Force type. In Fortran, if these derived data types are defined in Fortran modules different from the module that defines calcForceEpSp, user must \path{use} these modules in calcForceEpSp. Similarly, necessary header files must be included in the file defining calcForceEpSp. \\
$^{\ddagger}$ \texttt{super\_particle\_j} type must be one of superparticle types defined in \S~\ref{sec:super_particle_types} of Chap.~\ref{chap:data_types}.
\end{flushleft}
\end{table}


% 返り値
\subsubsection*{Returned value}
None.

% 機能
\subsubsection*{Function}
Calculate interactions from superparticle to $i$-particle.