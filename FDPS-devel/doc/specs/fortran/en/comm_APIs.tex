In this section, we describe the specifications of APIs to perform MPI communications. The list of the APIs explained here is shown below:
\begin{screen}
\begin{spverbatim}
(fdps_)get_rank
(fdps_)get_rank_multi_dim
(fdps_)get_num_procs
(fdps_)get_num_procs_multi_dim
(fdps_)get_logical_and
(fdps_)get_logical_or
get_min_value (Fortran only)
fdps_get_min_value_s32 (C only)
fdps_get_min_value_s64 (C only)
fdps_get_min_value_f32 (C only)
fdps_get_min_value_f64 (C only)
fdps_get_min_value_w_id_f32 (C only)
fdps_get_min_value_w_id_f64 (C only)
get_max_value (Fortran only)
fdps_get_max_value_s32 (C only)
fdps_get_max_value_s64 (C only)
fdps_get_max_value_f32 (C only)
fdps_get_max_value_f64 (C only)
fdps_get_max_value_w_id_f32 (C only)
fdps_get_max_value_w_id_f64 (C only)
get_sum (Fortran only)
fdps_get_sum_s32 (C only)
fdps_get_sum_s64 (C only)
fdps_get_sum_f32 (C only)
fdps_get_sum_f64 (C only)
broadcast (Fortran only)
fdps_broadcast_scalar_s32 (C only)
fdps_broadcast_array_s32 (C only)
fdps_broadcast_scalar_s64 (C only)
fdps_broadcast_array_s64 (C only)
fdps_broadcast_scalar_f32 (C only)
fdps_broadcast_array_f32 (C only)
fdps_broadcast_scalar_f64 (C only)
fdps_broadcast_array_f64 (C only)
(fdps_)get_wtime
(fdps_)barrier
\end{spverbatim}
\end{screen}

In the following, we describe the specification of each API in the order above. Note, however, that we will describe APIs together in a single section if the names of APIs matches the following regular expressions: \texttt{*get\_min\_value*}, \texttt{*get\_max\_value*}, \texttt{*get\_sum*}, \texttt{*broadcast*}.
\clearpage

%=============================================================
\subsection{get\_rank}
\subsubsection*{Fortran syntax}
\begin{screen}
\begin{spverbatim}
integer(kind=c_int) fdps_ctrl%get_rank()
\end{spverbatim}
\end{screen}

\subsubsection*{C syntax}
\begin{screen}
\begin{spverbatim}
int fdps_get_rank();
\end{spverbatim}
\end{screen}

\subsubsection*{Dummy argument specification}
None.

\subsubsection*{Returned value}
Type integer(kind=c\_int). Returns the rank of the calling process.

\subsubsection*{Function}
Returns the rank of the calling process.
\clearpage

%=============================================================
\subsection{get\_rank\_multi\_dim}
\subsubsection*{Fortran syntax}
\begin{screen}
\begin{spverbatim}  
integer(kind=c_int) fdps_ctrl%get_rank_multi_dim(id)
\end{spverbatim}
\end{screen}

\subsubsection*{C syntax}
\begin{screen}
\begin{spverbatim}  
int fdps_get_rank_multi_dim(const int id);
\end{spverbatim}
\end{screen}

\subsubsection*{Dummy argument specification}
\begin{table}[h]
\begin{tabularx}{\linewidth}{cXcX}
\toprule
\rowcolor{Snow2}
Name & Data type & I/O characteristics & Definition \\
\midrule
\verb|id| & integer(kind=c\_int) & Input & Id of axes. x-axis:0, y-axis:1, z-axis:2.\\
\bottomrule
\end{tabularx}
\end{table}

\subsubsection*{Returned value}
Type integer(kind=c\_int). 

\subsubsection*{Function}
The rank of the calling process along {\tt id}-th axis. In the case of two dimensional simulations, FDPS returns 1 for {\tt id}=2.
\clearpage

%=============================================================
\subsection{get\_num\_procs}
\subsubsection*{Fortran syntax}
\begin{screen}
\begin{spverbatim}
integer(kind=c_int) fdps_ctrl%get_num_procs()
\end{spverbatim}
\end{screen}

\subsubsection*{C syntax}
\begin{screen}
\begin{spverbatim}
int fdps_get_num_procs();
\end{spverbatim}
\end{screen}

\subsubsection*{Dummy argument specification}
None.

\subsubsection*{Returned value}
Type integer(kind=c\_int).

\subsubsection*{Function}
Returns the total number of processes.
\clearpage

%=============================================================
\subsection{get\_num\_procs\_multi\_dim}
\subsubsection*{Fortran syntax}
\begin{screen}
\begin{spverbatim}
integer(kind=c_int) fdps_ctrl%get_num_procs_multi_dim(id)
\end{spverbatim}
\end{screen}

\subsubsection*{C syntax}
\begin{screen}
\begin{spverbatim}
int fdps_get_num_procs_multi_dim(const int id);
\end{spverbatim}
\end{screen}

\subsubsection*{Dummy argument specification}
\begin{table}[h]
\begin{tabularx}{\linewidth}{cXcX}
\toprule
\rowcolor{Snow2}
Name & Data type & I/O characteristics & Definition \\
\midrule
\verb|id| & integer(kind=c\_int) & Input & Id of axes. x-axis:0, y-axis:1, z-axis:2.\\
\bottomrule
\end{tabularx}
\end{table}

\subsubsection*{Returned value}
Type integer(kind=c\_int).

\subsubsection*{Function}
The rank of the calling process along {\tt id}-th axis. In the case of two dimensional simulations, FDPS returns 1 for {\tt id}=2.
\clearpage

%=============================================================
\subsection{get\_logical\_and}
\subsubsection*{Fortran syntax}
\begin{screen}
\begin{spverbatim}
subroutine fdps_ctrl%get_logical_and(f_in, &
                                     f_out)
\end{spverbatim}
\end{screen}

\subsubsection*{C syntax}
\begin{screen}
\begin{spverbatim}
_Bool fdps_get_logical_and(const _Bool in);
\end{spverbatim}
\end{screen}

\subsubsection*{Dummy argument specification}
\begin{table}[h]
\begin{tabularx}{\linewidth}{cXcX}
\toprule
\rowcolor{Snow2}
Name & Data type & I/O characteristics & Definition \\
\midrule
\verb|f_in| & logical(kind=c\_bool) & Input & Input logical value\\
\verb|f_out| & logical(kind=c\_bool) & Input and Output & Output logical value\\
\verb|in| & const \_Bool & Input & Input logical value\\
\bottomrule
\end{tabularx}
\end{table}

\subsubsection*{Returned value}
None in Fortran. Type \_Bool in C.

\subsubsection*{Function}
In Fortran, Sets the logical product of {\tt f\_in} over all processes to \texttt{f\_out}. In C, returns the logical product of \texttt{in} over all processes.
\clearpage

%=============================================================
\subsection{get\_logical\_or}
\subsubsection*{Fortran syntax}
\begin{screen}
\begin{spverbatim}
subroutine fdps_ctrl%get_logical_or(f_in, &
                                     f_out)
\end{spverbatim}
\end{screen}

\subsubsection*{C syntax}
\begin{screen}
\begin{spverbatim}
_Bool fdps_get_logical_or(const _Bool in);
\end{spverbatim}
\end{screen}

\subsubsection*{Dummy argument specification}
\begin{table}[h]
\begin{tabularx}{\linewidth}{cXcX}
\toprule
\rowcolor{Snow2}
Name & Data type & I/O characteristics & Definition \\
\midrule
\verb|f_in| & logical(kind=c\_bool) & Input & Input logical value\\
\verb|f_out| & logical(kind=c\_bool) & Input and Output & Output logical value\\
\verb|in| & const \_Bool & Input & Input logical value\\
\bottomrule
\end{tabularx}
\end{table}

\subsubsection*{Returned value}
None in Fortran. Type \_Bool in C.

\subsubsection*{Function}
In Fortran, Sets the logical sum of {\tt f\_in} over all processes to \texttt{f\_out}. In C, returns the logical sum of \texttt{in} over all processes.
\clearpage

%=============================================================
\subsection{get\_min\_value}
\subsubsection*{Fortran syntax (1)}
\begin{screen}
\begin{spverbatim}
subroutine fdps_ctrl%get_min_value(f_in, &
                                   f_out)
\end{spverbatim}
\end{screen}

\subsubsection*{C syntax (1)}
\begin{screen}
\begin{spverbatim}
fdps_s32 fdps_get_min_value_s32(const fdps_s32 f_in);
fdps_s64 fdps_get_min_value_s64(const fdps_s64 f_in);
fdps_u32 fdps_get_min_value_u32(const fdps_u32 f_in);
fdps_u64 fdps_get_min_value_u64(const fdps_u64 f_in);
fdps_f32 fdps_get_min_value_f32(const fdps_f32 f_in);
fdps_f64 fdps_get_min_value_f64(const fdps_f64 f_in);
\end{spverbatim}
\end{screen}

\subsubsection*{Dummy argument specification}
\begin{table}[h]
\begin{tabularx}{\linewidth}{cp{5cm}cX}
\toprule
\rowcolor{Snow2}
Name & Data type & I/O characteristics & Definition \\
\midrule
\verb|f_in| & In Fortran, one of the followings: & Input & Input value\\
            & integer(kind=c\_int) &&\\
            & integer(kind=c\_long\_long)&&\\
            & real(kind=c\_float)&&\\
            & real(kind=c\_double)&&\\
            & In C, one of the followings: &&\\
            & fdps\_s32, fdps\_s64 && \\
            & fdps\_u32, fdps\_u64 && \\
            & fdps\_f32, fdps\_f64 && \\
 \verb|f_out| & Same as \verb|f_in| &inout  &Output value\\
\bottomrule
\end{tabularx}
\end{table}

\subsubsection*{Returned value}
None in Fortran. The same type as input data in C.

\subsubsection*{Function}
In Fortran, the minimum value of {\tt f\_in} of all processes is stored to {\tt f\_out}. In C, the API returns the minimum value of \texttt{f\_in} of all processes.
\clearpage


This function has alternative API in which the index associated to
the minimum value is also returned. It is as follows:
\subsubsection*{Fortran syntax (2)}
\begin{screen}
\begin{spverbatim}
subroutine fdps_ctrl%get_min_value(f_in, &
                                   i_in, &  
                                   f_out,&
                                   i_out)
\end{spverbatim}
\end{screen}

\subsubsection*{C syntax (2)}
\begin{screen}
\begin{spverbatim}
void fdps_get_min_value_w_id_f32(const fdps_f32 f_in,
                                 const int i_in,
                                 fdps_f32 *f_out,
                                 int *i_out);
void fdps_get_min_value_w_id_f64(const fdps_f64 f_in,
                                 const int i_in,
                                 fdps_f64 *f_out,
                                 int *i_out);
\end{spverbatim}
\end{screen}

\subsubsection*{Dummy argument specification}
\begin{table}[h]
\begin{tabularx}{\linewidth}{cXcX}
\toprule
\rowcolor{Snow2}
Name & Data type & I/O characteristics & Definition \\
\midrule
\verb|f_in| &real(kind=c\_float)  & Input & Input value\\
 & real(kind=c\_double)&&\\
\verb|i_in| &integer(kind=c\_int)  & Input & Index associated to Input value\\
\verb|f_out| & Same as \verb|f_in|&inout  & Output value\\
\verb|i_out| &integer(kind=c\_int)  & inout & Index associated to Output value\\
\bottomrule
\end{tabularx}
\end{table}

\subsubsection*{Returned value}
None.

\subsubsection*{Function}
The minimum value of {\tt f\_in} of all processes is stored to {\tt
f\_out}. In addition, the value of {\tt i\_in} corresponding to the minimum is stored to {\tt i\_out}.
\clearpage
  
%=============================================================
\subsection{get\_max\_value}
\subsubsection*{Fortran syntax (1)}
\begin{screen}
\begin{spverbatim}
subroutine fdps_ctrl%get_max_value(f_in, &
                                   f_out)
\end{spverbatim}
\end{screen}

\subsubsection*{C syntax (1)}
\begin{screen}
\begin{spverbatim}
fdps_s32 fdps_get_max_value_s32(const fdps_s32 f_in);
fdps_s64 fdps_get_max_value_s64(const fdps_s64 f_in);
fdps_u32 fdps_get_max_value_u32(const fdps_u32 f_in);
fdps_u64 fdps_get_max_value_u64(const fdps_u64 f_in);
fdps_f32 fdps_get_max_value_f32(const fdps_f32 f_in);
fdps_f64 fdps_get_max_value_f64(const fdps_f64 f_in);
\end{spverbatim}
\end{screen}

\subsubsection*{Dummy argument specification}
\begin{table}[h]
\begin{tabularx}{\linewidth}{cp{5cm}cX}
\toprule
\rowcolor{Snow2}
Name & Data type & I/O characteristics & Definition \\
\midrule
\verb|f_in| & In Fortran, one of the followings: & Input & Input value\\
            & integer(kind=c\_int) &&\\
            & integer(kind=c\_long\_long)&&\\
            & real(kind=c\_float)&&\\
            & real(kind=c\_double)&&\\
            & In C, one of the followings: &&\\
            & fdps\_s32, fdps\_s64 &&\\
            & fdps\_u32, fdps\_u64 &&\\
            & fdps\_f32, fdps\_f64 &&\\
 \verb|f_out| & Same as \verb|f_in| &inout  &Output value\\
\bottomrule
\end{tabularx}
\end{table}

\subsubsection*{Returned value}
None in Fortran. The same type as input data in C.

\subsubsection*{Function}
In Fortran, the maximum value of {\tt f\_in} of all processes is stored to {\tt f\_out}. In C, the API returns the maximum value of \texttt{f\_in} of all processes.
\clearpage

This function has alternative API in which the index associated to
the maximum value is also returned. It is as follows:

\subsubsection*{Fortran syntax (2)}
\begin{screen}
\begin{spverbatim}
subroutine fdps_ctrl%get_max_value(f_in, &
                                   i_in, &  
                                   f_out,&
                                   i_out)
\end{spverbatim}
\end{screen}

\subsubsection*{C syntax (2)}
\begin{screen}
\begin{spverbatim}
void fdps_get_max_value_w_id_f32(const fdps_f32 f_in,
                                 const int i_in,
                                 fdps_f32 *f_out,
                                 int *i_out);
void fdps_get_max_value_w_id_f64(const fdps_f64 f_in,
                                 const int i_in,
                                 fdps_f64 *f_out,
                                 int *i_out);
\end{spverbatim}
\end{screen}


\subsubsection*{Dummy argument specification}
\begin{table}[h]
\begin{tabularx}{\linewidth}{cXcX}
\toprule
\rowcolor{Snow2}
Name & Data type & I/O characteristics & Definition \\
\midrule
\verb|f_in| &real(kind=c\_float)  & Input & Input value\\
 & real(kind=c\_double)&&\\
\verb|i_in| &integer(kind=c\_int)  & Input & Index associated to Input value\\
\verb|f_out| & Same as \verb|f_in|&inout  & Output value\\
\verb|i_out| &integer(kind=c\_int)  & inout & Index associated to Output value\\
\bottomrule
\end{tabularx}
\end{table}

\subsubsection*{Returned value}
None.

\subsubsection*{Function}
The maximum value of {\tt f\_in} of all processes is stored to {\tt
f\_out}. In addition, the value of {\tt i\_in} corresponding to the maximum is stored to {\tt i\_out}.
\clearpage

%=============================================================
\subsection{get\_sum}
\subsubsection*{Fortran syntax}
\begin{screen}
\begin{spverbatim}
subroutine fdps_ctrl%get_sum(f_in, &
                             f_out)
\end{spverbatim}
\end{screen}

\subsubsection*{C syntax}
\begin{screen}
\begin{spverbatim}
fdps_s32 fdps_get_sum_s32(const fdps_s32 f_in);
fdps_s64 fdps_get_sum_s64(const fdps_s64 f_in);
fdps_u32 fdps_get_sum_u32(const fdps_u32 f_in);
fdps_u64 fdps_get_sum_u64(const fdps_u64 f_in);
fdps_f32 fdps_get_sum_f32(const fdps_f32 f_in);
fdps_f64 fdps_get_sum_f64(const fdps_f64 f_in);
\end{spverbatim}
\end{screen}

\subsubsection*{Dummy argument specification}
\begin{table}[h]
\begin{tabularx}{\linewidth}{cp{5cm}cX}
\toprule
\rowcolor{Snow2}
Name & Data type & I/O characteristics & Definition \\
\midrule
\verb|f_in| & In Fortran, one of the followings: & Input & Input value\\
            & integer(kind=c\_int) &&\\
            & integer(kind=c\_long\_long)&&\\
            & real(kind=c\_float)&&\\
            & real(kind=c\_double)&&\\
            & In C, one of the followings: &&\\
            & fdps\_s32, fdps\_s64 &&\\
            & fdps\_u32, fdps\_u64 &&\\
            & fdps\_f32, fdps\_f64 &&\\
\verb|f_out| & Same as \verb|f_in| &inout  & Output value\\
\bottomrule
\end{tabularx}
\end{table}

\subsubsection*{Returned value}
None in Fortran. The same type as input data in C.

\subsubsection*{Function}
In Fortran, Stores the sum of {\tt f\_in} over all processes to \texttt{f\_out}. In C, returns the sum of \texttt{f\_in} over all processes.
\clearpage

%=============================================================
\subsection{broadcast}
\subsubsection*{Fortran syntax}
\begin{screen}
\begin{spverbatim}
 subroutine fdps_ctrl%broadcast(val, &
                                n,   &
                                src)
\end{spverbatim}
\end{screen}

\subsubsection*{C syntax}
\begin{screen}
\begin{spverbatim}
void fdps_broadcast_s32(fdps_s32 *val, int n, int src);
void fdps_broadcast_s64(fdps_s64 *val, int n, int src);
void fdps_broadcast_u32(fdps_u32 *val, int n, int src);
void fdps_broadcast_u64(fdps_u64 *val, int n, int src);
void fdps_broadcast_f32(fdps_f32 *val, int n, int src);
void fdps_broadcast_f64(fdps_f64 *val, int n, int src);
\end{spverbatim}
\end{screen}

\subsubsection*{Dummy argument specification}
\begin{table}[h]
\begin{tabularx}{\linewidth}{cp{5cm}cX}
\toprule
\rowcolor{Snow2}
Name & Data type & I/O characteristics & Definition \\
\midrule
\verb|val| & In Fortran, a variable or array with one of the following data types: & Input and Output & Input value. {\setnoko\Euc{Note that users need to pass the address of a variable or array in C}}. \\
           & integer(kind=c\_int) &&\\
           & integer(kind=c\_long\_long)&&\\
           & real(kind=c\_float)&&\\
           & real(kind=c\_double)&&\\
           & In C, a variable or array with one of the following data types: &&\\
           & fdps\_s32, fdps\_s64 &&\\
           & fdps\_u32, fdps\_u64 &&\\
           & fdps\_f32, fdps\_f64 &&\\
 \verb|n| & integer(kind=c\_int) &Input  & Number of input data. If \verb|val| is a scalar, \verb|n| must be 1. \\
 \verb|src| & integer(kind=c\_int) &Input  & Rank number of the source MPI process. \\
\bottomrule
\end{tabularx}
\end{table}

\subsubsection*{Returned value}
None.

\subsubsection*{Function}
Broadcast {\tt val} for the {\tt src}-th process.
\clearpage

%=============================================================
\subsection{get\_wtime}
\subsubsection*{Fortran syntax}
\begin{screen}
\begin{spverbatim}
real(kind=c_double) fdps_ctrl%get_wtime()
\end{spverbatim}
\end{screen}

\subsubsection*{C syntax}
\begin{screen}
\begin{spverbatim}
double fdps_get_wtime();
\end{spverbatim}
\end{screen}

\subsubsection*{Dummy argument specification}
None.

\subsubsection*{Returned value}
Type real(kind=c\_double).

\subsubsection*{Function}
Returns wall-clock time in seconds. 
\clearpage

%=============================================================
\subsection{barrier}
\subsubsection*{Fortran syntax}
\begin{screen}
\begin{spverbatim}
subroutine fdps_ctrl%barrier()
\end{spverbatim}
\end{screen}

\subsubsection*{C syntax}
\begin{screen}
\begin{spverbatim}
void fdps_barrier();
\end{spverbatim}
\end{screen}

\subsubsection*{Dummy argument specification}
None.

\subsubsection*{Returned value}
None.

\subsubsection*{Function}
Synchronize MPI processes.