%本節では、領域クラスについて記述する。このクラスは領域情報の保持や領域
%の分割を行うモジュールである。まずオブジェクトの生成方法を記述し、その
%後APIを記述する。

This section describes {\tt DomainInfo} class. This class handles
the decomposition of computational domains and keeps their data.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\subsubsubsection{オブジェクトの生成}
\subsubsubsection{Creation of Object}

%領域クラスは以下のように宣言されている。

{\tt DomainInfo} class is declared as below.

\begin{lstlisting}[caption=DomainInfo0]
namespace ParticleSimulator {
    class DomainInfo;
}
\end{lstlisting}

%領域クラスのオブジェクトの生成は以下のように行う。ここではdinfoという
%オブジェクトを生成している。

Next example shows how to create an object of {\tt DomainInfo} class.
Here, the object is named ``dinfo".

\begin{screen}
\begin{verbatim}
PS::DomainInfo dinfo;
\end{verbatim}
\end{screen}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsubsection{API}

%領域クラスには初期設定関連のAPI、領域分割関連のAPIがある。以下、各節に
%分けて記述する。

{\tt DomainInfo} class has the APIs for initialization and
decomposition of domain. The following subsections describe them.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\subsubsubsubsection{初期設定}
\subsubsubsubsection{Initial Setup}

%初期設定関連のAPIの宣言は以下のようになっている。このあと各APIについて
%記述する。

The APIs for the initial setup of {\tt DomainInfo} class are declared
below.

\begin{lstlisting}[caption=DomainInfo1]
namespace ParticleSimulator {
    class DomainInfo{
    public:
        DomainInfo();
        void initialize(const F32 coef_ema=1.0);
        void setNumberOfDomainMultiDimension(const S32 nx,
                                             const S32 ny,
                                             const S32 nz=1);
        void setBoundaryCondition(enum BOUNDARY_CONDITION bc);
        S32 getBoundaryCondition();
        void setPosRootDomain(const F32vec & low,
                              const F32vec & high);
    };
}
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\subsubsubsubsubsection{コンストラクタ}
\subsubsubsubsubsection{Constructor}

\begin{screen}
\begin{verbatim}
void PS::DomainInfo::DomainInfo();
\end{verbatim}
\end{screen}

\begin{itemize}

\item {\bf arguments}

void.

\item {\bf returned value}

void.

\item {\bf function}

%領域クラスのオブジェクトを生成する。
Create an object of {\tt DomainInfo} class.

\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsubsubsubsection{PS::DomainInfo::initialize}

\begin{screen}
\begin{verbatim}
void PS::DomainInfo::initialize(const PS::F32 coef_ema=1.0);
\end{verbatim}
\end{screen}

\begin{itemize}

\item {\bf arguments}

\texttt{coef\_ema}: input. Type const {\tt PS::F32}. The smoothing factor of an
exponential moving average.

\item {\bf returned value}

void.

\item {\bf function}

Initialize an object of the domain information class. The argument
\texttt{coef\_ema} is the smoothing factor of exponential moving
average and is a constant real value between 0 and 1. If other values
are chosen, FDPS sends an error message and terminates the user
program.  A larger \texttt{coef\_ema} weighs newer values rather
than older values. In the case of unity, the domains are determined by
using the newest values only and in the case of zero, they are
determined by using the initial values only. Users call this API only
once. The details of this function are described in the paper by
Ishiyama, Fukushige \& Makino (2009, Publications of the Astronomical
Society of Japan, 61, 1319)

%領域クラスのオブジェクトを初期化する。指数移動平均の平滑化係数を設定
%する。この係数の許される値は0から1である。大きくなるほど、最新の粒子
%分布の情報が領域分割に反映されやすい。1の場合、最新の粒子分布の情報の
%み反映される。0の場合、最初の粒子分布の情報のみ反映される。１度は呼ぶ
%必要がある。過去の粒子分布の情報を領域分割に反映する必要がある理由に
%ついては、Ishiyama, Fukushige \& Makino (2009, Publications of the
%Astronomical Society of Japan, 61, 1319)を参照のこと。

\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsubsubsubsection{PS::DomainInfo::setNumberOfDomainMultiDimension}

\begin{screen}
\begin{verbatim}
void PS::DomainInfo::setNumberOfDomainMultiDimension
                 (const PS::S32 nx,
                  const PS::S32 ny,
                  const PS::S32 nz=1);
\end{verbatim}
\end{screen}

\begin{itemize}

\item {\bf arguments}

{\tt nx}: Input. Type const {\tt PS::S32}. The number of subdomains along x direction.

{\tt ny}: Input. Type const {\tt PS::S32}. The number of subdomains along y direction.

{\tt nz}: Input. Type const {\tt PS::S32}. The number of subdomains along z direction. The default value is 1.

%ny: 入力。 const PS::S32型。y軸方向のルートドメインの分割数。
%nz: 入力。 const PS::S32型。z軸方向のルートドメインの分割数。デフォル
%ト1。

%nx: 入力。 const PS::S32型。x軸方向のルートドメインの分割数。
%ny: 入力。 const PS::S32型。y軸方向のルートドメインの分割数。
%nz: 入力。 const PS::S32型。z軸方向のルートドメインの分割数。デフォル
%ト1。

\item {\bf returned value}

void.

\item {\bf function}

Set the numbers of subdomains. If the API is not
called: \texttt{nx}, \texttt{ny} and \texttt{nz} are determined
automatically. If the product of \texttt{nx}, \texttt{ny}
and \texttt{nz} is not equal to the total number of MPI processes,
FDPS sends an error message and terminates the user program.

%計算領域の分割する方法を設定する。nx, ny, nzはそれぞれx軸、y軸、z軸方
%向の計算領域の分割数である。呼ばなければ自動的にnx, ny, nzが決まる。呼
%んだ場合に入力するnx, ny, nzの総積がMPIプロセス数と等しくなければ、例
%外が送出される。

\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsubsubsubsection{PS::DomainInfo::setBoundaryCondition}

\begin{screen}
\begin{verbatim}
void PS::DomainInfo::setBoundaryCondition
                 (enum PS::BOUNDARY_CONDITION bc);
\end{verbatim}
\end{screen}

\begin{itemize}

\item {\bf arguments}

%bc: 入力。 列挙型。境界条件。

\texttt{bc}: input. Type enum \texttt{PS::BOUNDARY\_CONDITION}. Boundary conditions.

\item {\bf returned value}

void.

\item {\bf function}

Set the boundary condition. FDPS allows boundary conditions defined
in Section \ref{sec:datatype_enum_boundarycondition}
(BOUNDARY\_CONDITION\_SHEARING\_BOX and
BOUNDARY\_CONDITION\_USER\_DEFINED have not been implemented yet). If
the API is not called, the open boundary is used.

%境界条件の設定をする。許される入力は、
%\ref{sec:datatype_enum_boundarycondition}で挙げた列挙型のみ(ただし
%BOUNDARY\_CONDITION\_SHEARING\_BOX, BOUNDARY\_CONDITION\_USER\_DEFINED
%は未実装)。呼ばない場合は、開放境界となる。

\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsubsubsubsection{PS::DomainInfo::getBoundaryCondition}

\begin{screen}
\begin{verbatim}
S32 PS::DomainInfo::getBoundaryCondition();
\end{verbatim}
\end{screen}

\begin{itemize}

\item {\bf arguments}

void.

\item {\bf returned value}

Type \texttt{PS::S32}.

\item {\bf function}

Return an integer value corresponding to the current boundary condition.
The possible values are integers corresponding to the enumerators of PS::BOUNDARY\_CONDITION.

\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsubsubsubsection{PS::DomainInfo::setPosRootDomain}

\begin{screen}
\begin{verbatim}
void PS::DomainInfo::setPosRootDomain
                 (const PS::F32vec & low,
                  const PS::F32vec & high);
\end{verbatim}
\end{screen}

\begin{itemize}

\item {\bf arguments}

\texttt{low}: input. Type const {\tt PS::F32vec}. Top vertex of the boundary (inclusive).

\texttt{high}: input. Type const {\tt PS::F32vec}. Bottom vertex of the boundary (exclusive).

%low: 入力。 PS::F32vec型。計算領域の下限(閉境界)。

%high: 入力。 PS::F32vec型。計算領域の上限(解境界)。

\item {\bf returned value}

void.

\item {\bf function}

Set positions of vertexes of top and bottom of root domain. The API do
not need to be called under open boundary condition. Every coordinate
of \texttt{high} must be greater than the corresponding coordinate
of \texttt{low}. Otherwise, FDPS sends a error message and terminates
the user program.

%計算領域の下限と上限を設定する。開放境界条件の場合は呼ぶ必要はない。そ
%れ以外の境界条件の場合は、呼ばなくても動作するが、その結果が正しいこと
%は保証できない。

\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\subsubsubsubsection{領域分割}
\subsubsubsubsection{Decomposition of Domain}

%領域分割関連のAPIの宣言は以下のようになっている。このあと各APIについて
%記述する。

The APIs of decomposition of domain are declared below:

\begin{lstlisting}[caption=DomainInfo2]
namespace ParticleSimulator {
    class DomainInfo{
    public:
        template<class Tpsys>
        void collectSampleParticle(Tpsys & psys,
                                   const bool clear,
                                   const F32 weight);
        template<class Tpsys>
        void collectSampleParticle(Tpsys & psys,
                                   const bool clear);
        template<class Tpsys>
        void collectSampleParticle(Tpsys & psys);
        
        void decomposeDomain();
        
        template<class Tpsys>
        void decomposeDomainAll(Tpsys & psys,
                                const F32 weight);
        template<class Tpsys>
        void decomposeDomainAll(Tpsys & psys);
    };
}
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsubsubsubsection{PS::DomainInfo::collectSampleParticle}

\begin{screen}
\begin{verbatim}
template<class Tpsys>
void PS::DomainInfo::collectSampleParticle
                 (Tpsys & psys,
                  const bool clear,
                  const PS::F32 weight);
\end{verbatim}
\end{screen}

\begin{itemize}

\item {\bf arguments}

\texttt{psys}: input. Type {\tt ParticleSystem \&}. {\tt ParticleSystem} class
for giving sample particles to decompose domain.

\texttt{clear}: input. Type \texttt{const bool}. A flag to clear the data of sample
particles, if set to \texttt{true}.

\texttt{weight}: input. Type const {\tt PS::F32}. A weight to determine the
number of sample particles.


%psys: 入力。 Tpsys \&型。領域分割のためのサンプル粒子を提供する粒子群
%クラス。

%clear: 入力。 bool型。前にサンプルされた粒子情報をクリアするかどうかを
%決定するフラグ。trueでクリアする。

%weight: 入力。 const PS::F32型。領域分割のためのサンプル粒子数を決める
%ためのウェイト。

\item {\bf returned value}

void.

\item {\bf function}

Sample particles from an object of {\tt ParticleSystem} class. If
\texttt{clear} is true, the data of the samples collected before is
cleared. Larger \texttt{weight} leads to give more sample particles.
More specifically, $n_{\mathrm{smpl}}n_{\mathrm{proc}}(w_{i}/\sum_{k}w_{k})$
particles are sampled from process $i$, where $n_{\mathrm{smpl}}$ is the
number of sampled particles per process, which is set by API\\
\texttt{setAverateTargetNumberOfSampleParticlePerProcess},\\
$n_{\mathrm{proc}}$ is the number of MPI processes, and $w_{i}$ is
\texttt{weight} of process $i$. For better load balance, \texttt{weight}
should be a quantity that reflects the calculation time of each process.



%粒子群クラスのオブジェクトpsysから粒子をサンプルする。clearによってこ
%れより前にサンプルした粒子の情報を消すかどうか決める。weightによってそ
%のMPIプロセスからサンプルする粒子の量を調整する(weightが大きいほどサン
%プル粒子数が多い)。

\end{itemize}

\begin{screen}
\begin{verbatim}
template<class Tpsys>
void PS::DomainInfo::collectSampleParticle
                 (Tpsys & psys,
                  const bool clear);
\end{verbatim}
\end{screen}

\begin{itemize}

\item {\bf arguments}

%psys: 入力。 Tpsys \&型。領域分割のためのサンプル粒子を提供する粒子群
%クラス。

%clear: 入力。 bool型。前にサンプルされた粒子情報をクリアするかどうかを
%決定するフラグ。trueでクリアする。

\texttt{psys}: input. Type {\tt ParticleSystem \&}. An object of {\tt
ParticleSystem} class for giving sample particles to decompose domain.

\texttt{clear}: input. Type \texttt{const bool}. A flag to clear the data of particles,
if set to 'true'.

\item {\bf returned value}

void.

\item {\bf function}

Sample particles from {\tt psys}. If \texttt{clear} is true, the data
are cleared.

%粒子群クラスのオブジェクトpsysから粒子をサンプルする。clearによってこ
%れより前にサンプルした粒子の情報を消すかどうか決める。

\end{itemize}

\begin{screen}
\begin{verbatim}
template<class Tpsys>
void PS::DomainInfo::collectSampleParticle
                 (Tpsys & psys);
\end{verbatim}
\end{screen}

\begin{itemize}

\item {\bf arguments}

%psys: 入力。 Tpsys \&型。領域分割のためのサンプル粒子を提供する粒子群
%クラス。

\texttt{psys}: input. Type {\tt ParticleSystem \&}. An object of {\tt ParticleSystem} class
for giving sample particles to decompose domain.

\item {\bf returned value}

void.

\item {\bf functions}

Sample particles from {\tt psys}.
%粒子群クラスのオブジェクトpsysから粒子をサンプルする。

\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsubsubsubsection{PS::DomainInfo::decomposeDomain}

\begin{screen}
\begin{verbatim}
void PS::DomainInfo::decomposeDomain();
\end{verbatim}
\end{screen}

\begin{itemize}

\item {\bf arguments}

void.

\item {\bf returned value}

void.

\item {\bf function}

Decompose calculation domains.
%計算領域の分割を実行する。

\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsubsubsubsection{PS::DomainInfo::decomposeDomainAll}

\begin{screen}
\begin{verbatim}
template<class Tpsys>
void PS::DomainInfo::decomposeDomainAll
                 (Tpsys & psys,
                  const PS::F32 weight);
\end{verbatim}
\end{screen}

\begin{itemize}

\item {\bf arguments}

\texttt{psys}: input. Type {\tt ParticleSystem \&}. The particle system class
giving sample particles for the domain decomposition.
%psys: 入力。 Tpsys \&型。領域分割のためのサンプル粒子を提供する粒子群
%クラス。

\texttt{weight}: input. Type \texttt{const PS::F32}. The sampling weight.
%weight: 入力。 const PS::F32型。領域分割のためのサンプル粒子数を決める
%ためのウェイト。

\item {\bf returned value}

%なし
void.

\item {\bf function}

Sample particles from \texttt{psys} and decompose domains.  This API
is the combination of {\tt PS::DomainInfo::collectSampleParticle} and
{\tt PS::DomainInfo::decomposeDomain}.

%粒子群クラスのオブジェクトpsysから粒子をサンプルし、続けてルートドメイ
%ンの分割を行う。PS::DomainInfo::collectSampleParticleと
%PS::DomainInfo::decomposeDomainが行うことを一度に行う。weightの意味は
%PS::DomainInfo::collectSampleParticleと同じ。

\end{itemize}

\begin{screen}
\begin{verbatim}
template<class Tpsys>
void PS::DomainInfo::decomposeDomainAll
                 (Tpsys & psys);
\end{verbatim}
\end{screen}

\begin{itemize}

\item {\bf arguments}

psys: input. Type {\tt ParticleSystem} \&. The particle system class for giving samples.
%psys: 入力。 Tpsys \&型。領域分割のためのサンプル粒子を提供する粒子群
%クラスのオブジェクト。

\item {\bf returned value}

%なし
void.

\item {\bf function}

Sample particles from ``psys" and decompose domains. This API is the
combination of {\tt PS::DomainInfo::collectSampleParticle} and {\tt
PS::DomainInfo::decomposeDomain}.

%粒子群クラスのオブジェクトpsysから粒子をサンプルし、続けてルートドメイ
%ンの分割を行う。PS::DomainInfo::collectSampleParticleと
%PS::DomainInfo::decomposeDomainが行うことを一度に行う。

\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsubsubsection{Time Measurment}

The member functions of collecting information of an object are
declared below. When a member function is called, its execution time
is set to the private member of {\tt TimeProfile} class
\texttt{time\_profile\_}. Until the method \texttt{clearTimeProfile()} is called,
execution times are accumulated.

%クラス内の情報取得関連のAPIの宣言は以下のようになっている。自クラスの
%主要なメソッドを呼び出すとそれにかかった時間をプライベートメンバの
%time\_profile\_の該当メンバに書き込む。メソッドclearTimeProfile()を呼
%ばない限り時間は足しあわされていく。

\begin{lstlisting}[caption=DomainInfo3]
namespace ParticleSimulator {
    class DomainInfo{
    public:
        TimeProfile getTimeProfile();
        void clearTimeProfile();
    };
}
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsubsubsubsection{PS::DomainInfo::getTimeProfile}
\begin{screen}
\begin{verbatim}
PS::TimeProfile PS::DomainInfo::getTimeProfile();
\end{verbatim}
\end{screen}

\begin{itemize}

\item {\bf arguments}

void.

\item {\bf returned value}

Type \texttt{PS::TimeProfile}.

\item {\bf function}

Return the copy of the member variable {\tt time\_profile\_}.

%メンバ関数collectSampleParticleとdecomposeDomainにかかった時間（ミリ秒
%単位）をTimeProfile型のメンバ変数collect\_sample\_particles\_と
%decompose\_domain\_に格納する。

\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsubsubsubsection{PS::DomainInfo::clearTimeProfile}
\begin{screen}
\begin{verbatim}
void PS::DomainInfo::clearTimeProfile();
\end{verbatim}
\end{screen}

\begin{itemize}

\item {\bf arguments}

void.

\item {\bf returned value}

void.

\item {\bf function}

Set all member variables of {\tt time\_profile\_} to 0.

%領域情報クラスのTimeProfile型のプライベートメンバ変数のメンバ変数
%collect\_sample\_particles\_とdecompose\_domain\_の値を０クリアする。

\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsubsubsection{Obtain Information}

The APIs of obtaining information is deleared bellow.

\begin{lstlisting}[caption=DomainInfo3]
namespace ParticleSimulator {
    class DomainInfo{
    public:
        S64 getMemSizeUsed();
    };
}
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsubsubsubsection{PS::DomainInfo::getMemSizeUsed}
\begin{screen}
\begin{verbatim}
PS::S64 PS::DomainInfo::getMemSizeUsed();
\end{verbatim}
\end{screen}

\begin{itemize}

\item {\bf arguments}

void.
%なし。

\item {\bf returned value}

Type \texttt{PS::S64}. Size of used memory of the calling object in
the unit of byte.

\item {\bf function}

Return the size of used memory of the calling object in the unit of byte.

%対象のオブジェクトが使用しているメモリー量をByte単位で返す。

\end{itemize}



%%\subsubsubsubsubsubsection{getNumberofDomainOneAxis}

%%\subsubsubsubsubsubsection{getDomain}
