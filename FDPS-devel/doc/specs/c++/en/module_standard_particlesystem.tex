
This section describes {\tt ParticleSystem} class. This class is used
to keep the information of particles for the exchange of particles.

%本節では、粒子群クラスについて記述する。このクラスは粒子情報の保持や
%MPIプロセス間で粒子情報の交換を行うモジュールである。まずオブジェクト
%の生成方法を記述し、その後APIを記述する。

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\subsubsubsection{オブジェクトの生成}
\subsubsubsection{Creation of Object}

The particle system class is declared below.
%粒子群クラスは以下のように宣言されている。

\begin{lstlisting}[caption=ParticleSystem0]
namespace ParticleSimulator {
    template<class Tptcl>
    class ParticleSystem;
}
\end{lstlisting}

The template argument is user-defined {\tt FullParticle} class

%テンプレート引数Tptclはユーザー定義のFullParticleクラスである。
%粒子群クラスのオブジェクトの生成は以下のように行う。ここではsystemとい
%うオブジェクトを生成している。

Next example shows how to create an object of {\tt ParticleSystem} class.
Here, the object is named {\tt system}.

\begin{screen}
\begin{verbatim}
PS::ParticleSystem<FP> system;
\end{verbatim}
\end{screen}

%テンプレート引数FPはユーザー定義のFullParticleクラスの１例であるFPクラ
%スである。

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsubsection{API}

%このモジュールには初期設定関連のAPI、オブジェクト情報取得設定関連のAPI、
%ファイル入出力関連のAPI、粒子交換関連のAPIがある。以下、各節に分けて記
%述する。

{\tt DomainInfo} class has APIs for initialization, obtaining
information, file I/O and exchanging particles. The following
subsections describe them.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\subsubsubsubsection{初期設定}
\subsubsubsubsection{Initial Setup}

%初期設定関連のAPIの宣言は以下のようになっている。このあと各APIについて
%記述する。

The APIs of initialization are declared below.

\begin{lstlisting}[caption=ParticleSystem1]
namespace ParticleSimulator {
    template<class Tptcl>
    class ParticleSystem{
    public:
        ParticleSystem();
        void initialize();
        void setAverageTargetNumberOfSampleParticlePerProcess
                        (const S32 & nsampleperprocess);
    };
}
\end{lstlisting}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\subsubsubsubsubsection{コンストラクタ}
\subsubsubsubsubsection{Constructor}

\begin{screen}
\begin{verbatim}
template <class Tptcl>
void PS::ParticleSystem<Tptcl>::ParticleSystem();
\end{verbatim}
\end{screen}

\begin{itemize}

\item {\bf arguments}

void.

\item {\bf returned value}

void.

\item {\bf function}

Create an object of {\tt ParticleSystem} class.

\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsubsubsubsection{PS::ParticleSystem::initialize}

\begin{screen}
\begin{verbatim}
template <class Tptcl> 
void PS::ParticleSystem<Tptcl>::initialize();
\end{verbatim}
\end{screen}

\begin{itemize}

\item {\bf arguments}

void.

\item {\bf returned value}

void.

\item {\bf function}

Initialize an object of {\tt ParticleSystem} class. Users must call
this API once.

%粒子群クラスのオブジェクトを初期化する。１度は呼ぶ必要があるが、２度呼
%ぶと例外が送出される。

\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsubsubsubsection{PS::ParticleSystem::\\setAverageTargetNumberOfSampleParticlePerProcess}

\begin{screen}
\begin{verbatim}
template <class Tptcl>
void PS::ParticleSystem<Tptcl>::setAverageTargetNumberOfSampleParticlePerProcess
                 (const PS::S32 & nsampleperprocess);
\end{verbatim}
\end{screen}

\begin{itemize}

\item {\bf arguments}

{\tt nsampleperprocess}: input. Type {\tt const PS::S32 \&}. The
average number of sample particles per MPI process.

%nsampleperprocess: 入力。const PS::S32 \&型。１つのMPIプロセスでサンプル
%する粒子数目標。

\item {\bf returned value}

void.

\item {\bf function}

Set the average number of sample particles per MPI process. If this
function is not called, the average number is 30.

%１つのMPIプロセスでサンプルする粒子数の目標を設定する。呼び出さなくて
%もよいが、呼び出さないとこの目標数が30となる。

\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\subsubsubsubsection{オブジェクト情報の取得設定}
\subsubsubsubsection{Obtain Information}

%オブジェクト情報取得関連のAPIの宣言は以下のようになっている。このあと
%各APIについて記述する。

The APIs of obtaining information are declared below.

\begin{lstlisting}[caption=ParticleSystem2]
namespace ParticleSimulator {
    template<class Tptcl>
    class ParticleSystem{
    public:
        Tptcl & operator [] (const S32 id);
        S32 getNumberOfParticleLocal() const;
        S32 getNumberOfParticleGlobal() const;
        S64 getMemSizeUsed() const;
    };
}
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsubsubsubsection{PS::ParticleSystem::operator []}

\begin{screen}
\begin{verbatim}
template <class Tptcl>
Tptcl & PS::ParticleSystem<Tptcl>::operator []
             (const PS::S32 id);
\end{verbatim}
\end{screen}

\begin{itemize}

\item {\bf arguments}

{\tt id}: input. Type {\tt const PS::S32}. Index of the particle array in the calling object.
%n: 入力。const PS::S32型。粒子配列のインデックス。

\item {\bf returned value}

Type {\tt FullParticle \&}.

%Tptcl \&型。Tptcl型のオブジェクト。

\item {\bf function}

Return the reference of the {\tt id}-th object of {\tt FullParticle} class.

%Tptcl型のオブジェクトを返す。

\end{itemize}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsubsubsubsection{PS::ParticleSystem::getNumberOfParticleLocal}

\begin{screen}
\begin{verbatim}
template <class Tptcl>
PS::S32 PS::ParticleSystem<Tptcl>::getNumberOfParticleLocal();
\end{verbatim}
\end{screen}

\begin{itemize}

\item {\bf arguments}

void.

\item {\bf returned value}

Type {\tt PS::S32}. The number of particles of the calling process.

%PS::S32型。１つのMPIプロセスの持つ粒子数。

\item {\bf function}

Return the number of particles of the calling process.

%１つのMPIプロセスの持つ粒子数を返す。

\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsubsubsubsection{PS::ParticleSystem::getNumberOfParticleGlobal}

\begin{screen}
\begin{verbatim}
template <class Tptcl>
PS::S32 PS::ParticleSystem<Tptcl>::getNumberOfParticleGlobal();
\end{verbatim}
\end{screen}

\begin{itemize}

\item {\bf arguments}

void.

\item {\bf returned value}

Type PS::S32. The total number of particles of all processes.

%PS::S32型。全MPIプロセスの持つ粒子数。

\item {\bf function}

Return the total number of particles of all processes.

%全MPIプロセスの持つ粒子数を返す。

\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsubsubsubsection{PS::DomainInfo::getUsedMemorySize}
\begin{screen}
\begin{verbatim}
PS::S64 PS::DomainInfo::getUsedMemorySize();
\end{verbatim}
\end{screen}

\begin{itemize}

\item {\bf arguments}

void.

\item {\bf returned value}

PS::S64. The size of used memory of the calling object in the unit of byte.

\item {\bf function}

%対象のオブジェクトが使用しているメモリー量をByte単位で返す。
Return the size of used memory of the calling object in the unit of byte.

\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsubsubsection{File I/O}
\label{sec:ParticleSystem:IO}

The APIs of file I/O are declared below.
\begin{lstlisting}[caption=ParticleSystem3]
namespace ParticleSimulator {
    template<class Tptcl>
    class ParticleSystem{
    public:
        template <class Theader>
        void readParticleAscii(const char * const filename,
                               const char * const format,
                               Theader & header);
        void readParticleAscii(const char * const filename,       
                               const char * const format);
        template <class Theader>
        void readParticleAscii(const char * const filename,
                               Theader & header);
        void readParticleAscii(const char * const filename);
        template <class Theader>
        void readParticleAscii(const char * const filename,
                               const char * const format,
                               Theader & header,
                               void (Tptcl::*pFunc)(FILE*));
        void readParticleAscii(const char * const filename,       
                               const char * const format,
                               void (Tptcl::*pFunc)(FILE*));
        template <class Theader>
        void readParticleAscii(const char * const filename,
                               Theader & header,
                               void (Tptcl::*pFunc)(FILE*));
        void readParticleAscii(const char * const filename,
                               void (Tptcl::*pFunc)(FILE*) );

        template <class Theader>
        void readParticleBinary(const char * const filename,
                               const char * const format,
                               Theader & header);
        void readParticleBinary(const char * const filename,       
                               const char * const format);
        template <class Theader>
        void readParticleBinary(const char * const filename,
                               Theader & header);
        void readParticleBinary(const char * const filename);
        template <class Theader>
        void readParticleBinary(const char * const filename,
                               const char * const format,
                               Theader & header,
                               void (Tptcl::*pFunc)(FILE*));
        void readParticleBinary(const char * const filename,       
                               const char * const format,
                               void (Tptcl::*pFunc)(FILE*));
        template <class Theader>
        void readParticleBinary(const char * const filename,
                               Theader & header,
                               void (Tptcl::*pFunc)(FILE*));
        void readParticleBinary(const char * const filename,
                               void (Tptcl::*pFunc)(FILE*) );

        template <class Theader>
        void writeParticleAscii(const char * const filename,
                                const char * const format,
                                const Theader & header);        
        void writeParticleAscii(const char * const filename,
                                const char * format);                                       
        template <class Theader>
        void writeParticleAscii(const char * const filename,
                                const Theader & header);
        void writeParticleAscii(const char * const filename);
        template <class Theader>
        void writeParticleAscii(const char * const filename,
                                const char * const format,
                                const Theader & header,
                                void (Tptcl::*pFunc)(FILE*)const);   
        void writeParticleAscii(const char * const filename,
                                const char * format,
                                void (Tptcl::*pFunc)(FILE*)const);
        template <class Theader>
        void writeParticleAscii(const char * const filename,
                                const Theader & header,
                                void (Tptcl::*pFunc)(FILE*)const);
        void writeParticleAscii(const char * const filename,
                                void (Tptcl::*pFunc)(FILE*)const);

        template <class Theader>
        void writeParticleBinary(const char * const filename,
                                const char * const format,
                                const Theader & header);        
        void writeParticleBinary(const char * const filename,
                                const char * format);                                       
        template <class Theader>
        void writeParticleBinary(const char * const filename,
                                const Theader & header);
        void writeParticleBinary(const char * const filename);
        template <class Theader>
        void writeParticleBinary(const char * const filename,
                                const char * const format,
                                const Theader & header,
                                void (Tptcl::*pFunc)(FILE*)const);   
        void writeParticleBinary(const char * const filename,
                                const char * format,
                                void (Tptcl::*pFunc)(FILE*)const);
        template <class Theader>
        void writeParticleBinary(const char * const filename,
                                const Theader & header,
                                void (Tptcl::*pFunc)(FILE*)const);
        void writeParticleBinary(const char * const filename,
                                void (Tptcl::*pFunc)(FILE*)const);
    };
}
\end{lstlisting}


As describe above, there are four APIs for file I/O: \texttt{readParticleAscii}, \texttt{readParticleBinary}, \texttt{writeParticleAscii}, and \texttt{writeParticleBinary}. They are overloaded functions and each has 8 different interfaces, which results from existence or non-existence of the following arguments (the definitions of them will be described later).
\begin{enumerate}[itemsep=-1ex,label=\arabic*)]
\item \verb|template <class Theader> Theader & header|
\item \verb|const char * const format|
\item \verb|void (Tptcl::*pFunc)(FILE *)|
\end{enumerate}
In the following, we describe each API. For brevity, we describe functions overloaded in a single section.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsubsubsubsection{PS::ParticleSystem::readParticleAscii}
\label{sec:readParticleAscii}

\texttt{readParticleAscii} has the following eight interfaces.
\begin{breakitembox}<parindent=0pt>{}
\begin{verbatim}
template <class Tptcl>
template <class Theader>
void PS::ParticleSystem<Tptlc>::readParticleAscii
                 (const char * const filename,
                  const char * const format,
                  Theader & header);
                  
template <class Tptcl>
void PS::ParticleSystem<Tptcl>::readParticleAscii
            (const char * const filename,
             const char * const format);
             
template <class Tptcl>
template <class Theader>
void PS::ParticleSystem<Tptcl>::readParticleAscii
            (const char * const filename,
             Theader & header);
             
template <class Tptcl>
void PS::ParticleSystem<Tptcl>::readParticleAscii
            (const char * const filename);
            
template <class Tptcl>
template <class Theader>
void PS::ParticleSystem<Tptlc>::readParticleAscii
                 (const char * const filename,
                  const char * const format,
                  Theader & header,
                  void (Tptcl::*pFunc)(FILE*));
                  
template <class Tptcl>
void PS::ParticleSystem<Tptcl>::readParticleAscii
            (const char * const filename,
             const char * const format,
             void (Tptcl::*pFunc)(FILE*));
             
template <class Tptcl>
template <class Theader>
void PS::ParticleSystem<Tptcl>::readParticleAscii
            (const char * const filename,
             Theader & header,
             void (Tptcl::*pFunc)(FILE*));
             
template <class Tptcl>
void PS::ParticleSystem<Tptcl>::readParticleAscii
            (const char * const filename,
             void (Tptcl::*pFunc)(FILE*));
\end{verbatim}
\end{breakitembox}

\begin{itemize}

\item {\bf Arguments}

\texttt{filename}: Input. Type \texttt{const char *}. Prefix of name of an input file in the parallel read mode. Name of an input file in the single-process read mode.

\texttt{format}: Input. Type \texttt{const char *}. Format of file name for parallel read mode.

\texttt{header}: Input. Type \texttt{Theader \&}. Header information of a file.

\texttt{pFunc}: Input. Type \texttt{void (Tptcl::*)(FILE*)}. Pointer to a member function of class \texttt{Tptcl}, which receives a \texttt{FILE} pointer and returns \texttt{void}.


\item {\bf Returned value}

None.

\item {\bf Function}

If argument \texttt{format} exists, each process reads data of particles from the input file specified by both \texttt{filename} and \texttt{format} and stores the data into \texttt{FullParticle}-type objects (\textbf{parallel read mode}). If argument \texttt{format} is not present, the root process reads data of particles from the input file named \texttt{filename} and distributes the data to other processes (\textbf{single-process read mode}). In both read modes, if argument \texttt{header} is not present, this API reads the file twice. The first one is to get the number of particles stored in the file. The second is to read particle data. Thus, this API estimates the number of particles assuming that data of one particle is stored in a single line.


In the parallel read mode, \texttt{filename} and \texttt{format} represent the prefix of name of an input file and the format of file name, respectively. Format specifier is the same as that of the standard C library. There must be three format specifiers. The first is string type and both the second and third are integer types. The first string is set to be \texttt{filename}. The second and third integers are the number of the total processes and the rank id of the calling process, respectively. For instance, if \texttt{filename} is \texttt{nbody}, \texttt{format} is \texttt{\%s\_\%03d\_\%03d.init} and the number of total process is $64$, the process with rank id of $12$ reads the file named \texttt{nbody\_064\_012.init}.

The API uses function \texttt{pFunc} to read data of one particle if argument \texttt{pFunc} exists. Otherwise, it uses member function \texttt{readAscii} of \texttt{FullParticle} class. Thus, users must define \texttt{FullParticle::readAscii} if required. The requirement specification and an example of implementation of \texttt{readAscii} are described in Sections \ref{sec:FP_readAscii} and  \ref{sec:example_userdefined_fullparticle_io}, respectively. Function \texttt{pFunc} must fulfill the same requirement specification as that of \texttt{readAscii}.

Member function \texttt{readAscii} of \texttt{Theader} class is used to read header information of the input file. Thus, uses must define \texttt{Theader::readAscii}. Its requirement specification and an example of implementation are described in Section \ref{sec:Hdr_readAscii} and \ref{sec:example_userdefined_header}, respectively.

Files are opened in ascii mode.

\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsubsubsubsection{PS::ParticleSystem::readParticleBinary}
\label{sec:readParticleBinary}

\texttt{readParticleBinary} has the following eight interfaces.
\begin{breakitembox}<parindent=0pt>{}
\begin{verbatim}
template <class Tptcl>
template <class Theader>
void PS::ParticleSystem<Tptlc>::readParticleBinary
                 (const char * const filename,
                  const char * const format,
                  Theader & header);

template <class Tptcl>
void PS::ParticleSystem<Tptcl>::readParticleBinary
            (const char * const filename,
             const char * const format); 
             
template <class Tptcl>
template <class Theader>
void PS::ParticleSystem<Tptcl>::readParticleBinary
            (const char * const filename,
             Theader & header);

template <class Tptcl>
void PS::ParticleSystem<Tptcl>::readParticleBinary
            (const char * const filename);

template <class Tptcl>
template <class Theader>
void PS::ParticleSystem<Tptlc>::readParticleBinary
                 (const char * const filename,
                  const char * const format,
                  Theader & header,
                  void (Tptcl::*pFunc)(FILE*));
                 
template <class Tptcl>
void PS::ParticleSystem<Tptcl>::readParticleBinary
            (const char * const filename,
             const char * const format,
             void (Tptcl::*pFunc)(FILE*));

template <class Tptcl>
template <class Theader>
void PS::ParticleSystem<Tptcl>::readParticleBinary
            (const char * const filename,
             Theader & header,
             void (Tptcl::*pFunc)(FILE*));
             
template <class Tptcl>
void PS::ParticleSystem<Tptcl>::readParticleBinary
            (const char * const filename,
             void (Tptcl::*pFunc)(FILE*));

template <class Tptcl>
template <class Theader>
void PS::ParticleSystem<Tptcl>::writeParticleAscii
            (const char * const filename,
             const Theader & header,
             void (Tptcl::*pFunc)(FILE*)const);

\end{verbatim}
\end{breakitembox}

\begin{itemize}

\item {\bf Arguments}

\texttt{filename}: Input. Type \texttt{const char *}. Prefix of the name of an input file in the parallel read mode. Name of an input file in the single-process read mode.

\texttt{format}: Input. Type \texttt{const char *}. Format of file name in the parallel read mode.

\texttt{header}: Input. Type \texttt{Theader \&}. Header information of a file.

\texttt{pFunc}: Input. Type \texttt{void (Tptcl::*)(FILE*)}. Pointer to a member function of class \texttt{Tptcl}, which receives a \texttt{FILE} pointer and returns void.


\item {\bf Returned value}

None.

\item {\bf Function}

It provides almost the same function as \texttt{readParticleAscii}, but there are the following differences.
\begin{itemize}
\item Files are opened in binary mode.
\item The API estimates the number of particles stored in a file by examining the amount of change of the file position indicator before and after reading one particle actually. Hence, data of one particle does not need to end with a newline character (\texttt{\textbackslash n}).
\end{itemize}

\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsubsubsubsection{PS::ParticleSystem::writeParticleAscii}
\label{sec:writeParticleAscii}

\texttt{writeParticleAscii} has the following eight interfaces.
\begin{breakitembox}<parindent=0pt>{}
\begin{verbatim}
template <class Tptcl>
template <class Theader>
void PS::ParticleSystem<Tptcl>::writeParticleAscii
            (const char * const filename,
             const char * const format,
             const Theader & header);
             
template <class Tptcl>
void PS::ParticleSystem<Tptcl>::writeParticleAscii
            (const char * const filename,
             const char * const format);

template <class Tptcl>
template <class Theader>
void PS::ParticleSystem<Tptcl>::writeParticleAscii
            (const char * const filename,
             const Theader & header);

template <class Tptcl>
void PS::ParticleSystem<Tptcl>::writeParticleAscii
            (const char * const filename);

template <class Tptcl>
template <class Theader>
void PS::ParticleSystem<Tptcl>::writeParticleAscii
            (const char * const filename,
             const char * const format,
             const Theader & header,
             void (Tptcl::*pFunc)(FILE*)const);

template <class Tptcl>
void PS::ParticleSystem<Tptcl>::writeParticleAscii
            (const char * const filename,
             const char * const format,
             void (Tptcl::*pFunc)(FILE*)const);

template <class Tptcl>             
template <class Theader>
void PS::ParticleSystem<Tptcl>::writeParticleAscii
            (const char * const filename,
             const Theader & header,
             void (Tptcl::*pFunc)(FILE*)const);
             
template <class Tptcl>                        
void PS::ParticleSystem<Tptcl>::writeParticleAscii
            (const char * const filename,
             void (Tptcl::*pFunc)(FILE*)const);
\end{verbatim}
\end{breakitembox}

\begin{itemize}

\item{{\bf Arguments}}

  \texttt{filename}: Input. Type \texttt{const char * const}. Prefix of the name of an output file in the parallel write mode. Name of an output file in the single-process write mode.

  \texttt{format}: Input. Type {const char * const}. Format of file name in the parallel write mode.

  \texttt{header}: Input. Type {const Theader \&}. Header information of a file.
  
  \texttt{pFunc}: Input. Type \texttt{void (Tptcl::*)(FILE*)const}. Pointer to a member function of class \texttt{Tptcl}, which receives a \texttt{FILE} pointer and returns void.

\item{{\bf Returned value}}

  None.

\item{{\bf Function}}

If argument \texttt{format} exists, each process writes data of \texttt{FullParticle}-type objects to the output file specified by both \texttt{filename} and \texttt{format} (\textbf{parallel write mode})。If argument \texttt{format} is not present, the root process gathers data of \texttt{FullParticle}-type objects owned by other processes and then writes the collected data to the output file named \texttt{filename} (\textbf{single-process write mode}). In both modes, if argument \texttt{header} exists, header information is also output.


How to describe \texttt{format} is the same as the case of \newline\texttt{PS::ParticleSystem::readParticleAscii}.
  
The API uses function \texttt{pFunc} to write data of one particle if argument \texttt{pFunc} exists. Otherwise, it uses member function \texttt{writeAscii} of \texttt{FullParticle} class. Thus, users must define \texttt{FullParticle::writeAscii} if required. The requirement specification and an example of implementation of \texttt{writeAscii} are described in Sections \ref{sec:FP_writeAscii} and \ref{sec:example_userdefined_fullparticle_io}, respectively. Function \texttt{pFunc} must fulfill the same requirement specification as that of \texttt{writeAscii}.


Member function \texttt{writeAscii} of class \texttt{Theader} is used to write header information of the output file. Thus, users must define \texttt{Theader::writeAscii}. Its requirement specification and an example of implementation are described in Sections \ref{sec:Hdr_writeAscii} and \ref{sec:example_userdefined_header}, respectively.

Files are opened in ascii mode.

\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsubsubsubsection{PS::ParticleSystem::writeParticleBinary}
\label{sec:writeParticleBinary}

\texttt{writeParticleBinary} has the following eight interfaces.
\begin{breakitembox}<parindent=0pt>{}
\begin{verbatim}
template <class Tptcl>
template <class Theader>
void PS::ParticleSystem<Tptcl>::writeParticleBinary
            (const char * const filename,
             const char * const format,
             const Theader & header);
             
template <class Tptcl>
void PS::ParticleSystem<Tptcl>::writeParticleBinary
            (const char * const filename,
             const char * const format);

template <class Tptcl>
template <class Theader>
void PS::ParticleSystem<Tptcl>::writeParticleBinary
            (const char * const filename,
             const Theader & header);

template <class Tptcl>
void PS::ParticleSystem<Tptcl>::writeParticleBinary
            (const char * const filename);

template <class Tptcl>
template <class Theader>
void PS::ParticleSystem<Tptcl>::writeParticleBinary
            (const char * const filename,
             const char * const format,
             const Theader & header,
             void (Tptcl::*pFunc)(FILE*)const);

template <class Tptcl>
void PS::ParticleSystem<Tptcl>::writeParticleBinary
            (const char * const filename,
             const char * const format,
             void (Tptcl::*pFunc)(FILE*)const);

template <class Tptcl>
template <class Theader>
void PS::ParticleSystem<Tptcl>::writeParticleBinary
            (const char * const filename,
             const Theader & header,
             void (Tptcl::*pFunc)(FILE*)const);

template <class Tptcl>             
void PS::ParticleSystem<Tptcl>::writeParticleBinary
            (const char * const filename,
             void (Tptcl::*pFunc)(FILE*)const));
\end{verbatim}
\end{breakitembox}

\begin{itemize}

\item{{\bf Arguments}}

  \texttt{filename}: Input. Type \texttt{const char * const}. Prefix of name of an input file in the parallel write mode. Name of an input file in the single-process write mode.

  \texttt{format}: Input. Type \texttt{const char * const}. Format of a file name in the parallel write mode.

  \texttt{header}: Input. Type \texttt{const Theader \&}. Header information of a file.
  
  \texttt{pFunc}: Input. Type \texttt{void (Tptcl::*)(FILE*)const}. Pointer to a member function of class \texttt{Tptcl}, which receives a \texttt{FILE} pointer and returns void.


\item{{\bf Returned value}}

  None.

\item{{\bf Function}}

It provide almost the same function as \texttt{writeParticleAscii}, but file are opened in binary mode in this API.


\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\subsubsubsubsection{粒子交換}
\subsubsubsubsection{Exchange Particles}


%粒子交換関連のAPIの宣言は以下のようになっている。このあと各APIについて
%記述する。

The APIs of exchange particle are declared below.

\begin{lstlisting}[caption=ParticleSystem4]
namespace ParticleSimulator {
    template<class Tptcl>
    class ParticleSystem{
    public:
        template<class Tdinfo>
        void exchangeParticle(Tdinfo & dinfo,
                              const bool flag_serialize=false);
    };
}
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsubsubsubsection{PS::ParticleSystem::exchangeParticle}
\label{sec:particleSystem:exchangeParticle}

\begin{screen}
\begin{verbatim}
template <class Tptcl>
template <class Tdinfo>
void PS::ParticleSystem<Tptcl>::exchangeParticle
                 (Tdinfo & dinfo, const bool flag_serialize=false);
\end{verbatim}
\end{screen}

\begin{itemize}

\item {\bf arguments}

{\tt dinfo}: input. Type {\tt DomainInfo \&}.

\texttt{flag\_serialize}: input. Type \texttt{const bool}. This argument determines whether the function serializes particle data when particle exchange. Serialize particle data if \texttt{true} is given. \texttt{false} in the default.

\item {\bf returned value}

void.

\item {\bf function}

Redistribute particles among MPI processes so that the particles are in appropriate domains.

When sending particles with serialization, users must define member functions \texttt{pack} and \texttt{unPack} in FullParticle class (see xx)、set \texttt{flag\_serialize} to \texttt{true} (\textcolor{red}{This feature is not yet implemented}).



\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsubsubsection{Adding and removing particles}
\label{sec:addAndRemoveParticle}

The APIs of adding and removing particles are declared as follows.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsubsubsubsection{PS::ParticleSystem::addOneParticle()}
\begin{screen}
\begin{verbatim}
void PS::ParticleSystem::addOneParticle(const FullPartilce & fp);
\end{verbatim}
\end{screen}

\begin{itemize}

\item {\bf arguments}

{\tt fp}: input. Type const FullParticle \&. A particle to be added.

\item {\bf returned value}

void.

\item {\bf function}

Add a new particle {\tt fp} at the end of the array of the particles.

\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsubsubsubsection{PS::ParticleSystem::removeParticle()}
\begin{screen}
\begin{verbatim}
void PS::ParticleSystem::removeParticle(const PS::S32 * idx, 
                                        const PS::S32 n);
\end{verbatim}
\end{screen}

\begin{itemize}

\item {\bf arguments}

{\tt idx}: input. Type const PS::S32 * . An array of the index of the
particles to be removed.

{\tt n}: input. Type const PS::S32. The number of particles to be removed.

\item {\bf returned value}

void.

\item {\bf function}

Remove the particles with the index in the array {\tt idx}. After
calling this API, the order of the array of the particles would be
changed.

\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\subsubsubsubsection{情報取得}
\subsubsubsubsection{Time Measurement}

The APIs of Time Measurement are given below. When a member function
is called, its execution time is set to the private member {\tt
time\_profile\_}. Until the method, {\tt clearTimeProfile()},
execution times are accumulated.

\begin{lstlisting}[caption=ParticleSystem3]
namespace ParticleSimulator {
    template<class Tptcl>
    class ParticleSystem{
    private:
        TimeProfile time_profile_;
    public:
        TimeProfile getTimeProfile();
        void clearTimeProfile();

    };
}
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsubsubsubsection{PS::ParticleSystem::getTimeProfile}
\begin{screen}
\begin{verbatim}
PS::TimeProfile PS::ParticleSystem::getTimeProfile();
\end{verbatim}
\end{screen}

\begin{itemize}

\item {\bf arguments}

void.

\item {\bf returned value}

Type {\tt PS::TimeProfile}.

\item {\bf function}

Return the copy of the member variable {\tt time\_profile\_}.

%メンバ関数exchangeParticleにかかった時間（ミリ秒単位）をTimeProfile型
%のメンバ変数exchange\_particles\_に格納し、返す。

\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsubsubsubsection{PS::ParticleSystem::clearTimeProfile}
\begin{screen}
\begin{verbatim}
void PS::ParticleSystem::clearTimeProfile();
\end{verbatim}
\end{screen}

\begin{itemize}

\item {\bf arguments}

void.

\item {\bf returned value}

void.

\item {\bf function}

Set all member variables of {\tt time\_profile\_} to 0.
%領域情報クラスのTimeProfile型のプライベートメンバ変数のメンバ変数
%exchange\_particles\_の値を０クリアする。


\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\subsubsubsubsection{その他}
\subsubsubsubsection{Others}

%その他のAPIの宣言は以下のようになっている。このあと各APIについて記述す
%る。

Other APIs are declared below.

\begin{lstlisting}[caption=ParticleSystem4]
namespace ParticleSimulator {
    template<class Tptcl>
    class ParticleSystem{
    public:
        template<class Tdinfo>
        void adjustPositionIntoRootDomain
                    (const Tdinfo & dinfo);
        void setNumberOfParticleLocal(const S32 n);
        tamplate<class Tcomp>
        void sortParticle(Tcomp comp);
    };
}
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsubsubsubsection{PS::ParticleSystem::adjustPositionIntoRootDomain}

\begin{screen}
\begin{verbatim}
template <class Tptcl>
template <class Tdinfo>
void ParticleSystem<Tptcl>::adjustPositionIntoRootDomain
            (const Tdinfo & dinfo);
\end{verbatim}
\end{screen}

\begin{itemize}

\item {\bf arguments}

{\tt dinfo}: input. Type {\tt const Tdinfo \&}. Object of the domain information class.
  
%  dinfo: 入力。Tdinfo型。領域クラスのオブジェクト。

\item {\bf returned value}

void.

\item {\bf function}

Under the periodic boundary condition, the particles outside the
calculation domain move to appropriate positions.

%周期境界条件の場合に、計算領域からはみ出した粒子を計算領域に適切に戻す。

\end{itemize}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsubsubsubsection{PS::ParticleSystem::setNumberOfParticleLocal}

\begin{screen}
\begin{verbatim}
template <class Tptcl>
void PS::ParticleSystem<Tptcl>::setNumberOfParticleLocal
                 (const PS::S32 n);
\end{verbatim}
\end{screen}

\begin{itemize}

\item {\bf arguments}

{\tt n}: input. Type {\tt const PS::S32}. The number of particles of the calling process.

\item {\bf returned value}

void.

\item {\bf function}

Set the number of particles of the calling  process.

\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsubsubsubsection{PS::ParticleSystem::sortParticle}
\label{sec:ParticleSystem:sortParticle}

\begin{screen}
\begin{verbatim}
tamplate<class Tcomp>
void sortParticle(Tcomp comp);
\end{verbatim}
\end{screen}

\begin{itemize}

\item {\bf arguments}

{\tt comp}: input. Type Tcomp. Compare function which returns bool
type value. This function needs two arguments.

The following is an example of {\tt comp} to sort FullParticles in
ascending order of particle ID.

%comp: 入力。Tcomp型。比較関数。比較関数は返り値をbool型とし、引数は
%const FullParticle \& を２つ。例として以下にFullParticleがメンバ変数id
%を持っておりidの昇順に並べ替える場合を示す。

\begin{verbatim}
bool comp(const FP & left, const FP & right){
    return left.id < right.id;
}
\end{verbatim}

\item {\bf returned value}

void.

%なし

\item {\bf function}

This API sorts an array of FullParticles in the order determined by a
comparison function {\tt comp}. The returned value of {\tt comp} must
be bool type and it must take two arguments of FullParticles.

%粒子群クラスが保持するFullParticleの配列を引数compで指示したように並べ替える。

\end{itemize}
