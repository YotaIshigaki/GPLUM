本節では、Particle Meshクラスについて記述する。このクラスはParticle
Mesh法を用いて粒子の相互作用を計算するモジュールである。メッシュからの
力はS-2型の関数によってカットオフされており、カットオフ半径はメッシュ
間隔の3倍で固定されている。カットオフ関数径を変更する事は出来ない。ま
た、Particle Meshクラスに送る粒子の座標は0以上1未満の値に規格化して置
かなければならない。以下に、オブジェクトの生成方法、API、使用済マクロ、
使いかたについて記述する。

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsubsection{オブジェクトの生成}

Particle Meshクラスは以下のように宣言されている。
\begin{lstlisting}[caption=ParticleMesh0]
namespace ParticleSimulator {
    namespace ParticleMesh {
        class ParticleMesh;
    }
}
\end{lstlisting}

Particle Meshクラスのオブジェクトの生成は以下のように行う。ここではpm
というオブジェクトを生成している。
\begin{screen}
\begin{verbatim}
PS::PM::ParticleMesh pm;
\end{verbatim}
\end{screen}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsubsection{API}

Particle Meshクラスには初期設定関連のAPI、低レベルAPI、高レベルAPIがあ
る。以下、各節に分けて記述する。

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsubsubsection{初期設定}

初期設定関連のAPIの宣言は以下のようになっている。このあと各APIについて
記述する。
\begin{lstlisting}[caption=ParticleMesh1]
namespace ParticleSimulator {
    namespace ParticleMesh {
        class ParticleMesh{
            ParticleMesh();
        };
    }
}
\end{lstlisting}

\subsubsubsubsubsection{コンストラクタ}

\begin{screen}
\begin{verbatim}
void PS::PM::ParticleMesh::ParticleMesh();
\end{verbatim}
\end{screen}

\begin{itemize}

\item {\bf 引数}

なし

\item {\bf 返値}

なし

\item {\bf 機能}

Particle Meshクラスのオブジェクトを生成する。

\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsubsubsection{低レベルAPI}

低レベルAPIの宣言は以下のようになっている。このあと各APIについて記述す
る。
\begin{lstlisting}[caption=ParticleMesh1]
namespace ParticleSimulator {
    namespace ParticleMesh {
        class ParticleMesh{
            template<class Tdinfo>
            void setDomainInfoParticleMesh
                        (const Tdinfo & dinfo);
            template<class Tpsys>
            void setParticleParticleMesh
                        (const Tpsys & psys,
                         const bool clear=true);
            void calcMeshForceOnly();
            F32vec getForce(F32vec pos);
            F32 getPotential(F32vec pos);
        };
    }
}
\end{lstlisting}

\subsubsubsubsubsection{PS::PM::ParticleMesh::setDomainInfoParticleMesh}

\begin{screen}
\begin{verbatim}
template<class Tdinfo>
void PS::PM::ParticleMesh::setDomainInfoParticleMesh
            (const Tdinfo & dinfo);
\end{verbatim}
\end{screen}

\begin{itemize}

\item {\bf 引数}

dinfo: 入力。Tdinfo \&型。領域クラスのオブジェクト。

\item {\bf 返値}

なし

\item {\bf 機能}

領域情報を読み込む。

\end{itemize}

\subsubsubsubsubsection{PS::PM::ParticleMesh::setParticleParticleMesh}

\begin{screen}
\begin{verbatim}
template<class Tpsys>
void PS::PM::ParticleMesh::setParticleParticleMesh
            (const Tpsys & psys,
             const bool clear=true);
\end{verbatim}
\end{screen}

\begin{itemize}

\item {\bf 引数}

  psys: 入力。Tpsys \& 型。粒子群クラスのオブジェクト。

  clear: 入力。const bool型。これまで読込んだ粒子情報をクリアするかど
  うか決定するフラグ。trueならばクリアする。デフォルトはtrue。

\item {\bf 返値}

  なし

\item {\bf 機能}

  粒子情報を粒子群クラスのオブジェクトから読み込む。

\end{itemize}

\subsubsubsubsubsection{PS::PM::ParticleMesh::calcMeshForceOnly}

\begin{screen}
\begin{verbatim}
void PS::PM::ParticleMesh::calcMeshForceOnly();
\end{verbatim}
\end{screen}

\begin{itemize}

\item {\bf 引数}

  なし

\item {\bf 返値}

  なし

\item {\bf 機能}

  メッシュ上の力を計算する。

\end{itemize}

\subsubsubsubsubsection{PS::PM::ParticleMesh::getForce}

\begin{screen}
\begin{verbatim}
PS::F32vec PS::PM::ParticleMesh::getForce(PS::F32vec pos);
\end{verbatim}
\end{screen}

\begin{itemize}

\item {\bf 引数}

  pos: 入力。PS::F32vec型。メッシュからの力を計算したい位置。

\item {\bf 返値}

  PS::F32vec型。位置posにおけるメッシュからの力。

\item {\bf 機能}

  位置posでのメッシュからの力を返す。この関数はthread-safeである。

\end{itemize}

\subsubsubsubsubsection{PS::PM::ParticleMesh::getPotential}

\begin{screen}
\begin{verbatim}
PS::F32 PS::PM::ParticleMesh::getPotential(PS::F32vec pos);
\end{verbatim}
\end{screen}

\begin{itemize}

\item {\bf 引数}

  pos: 入力。PS::F32vec型。メッシュからのポテンシャルを計算したい位置。

\item {\bf 返値}

  PS::F32型。位置posにおけるメッシュからポテンシャル。

\item {\bf 機能}

  位置posでのメッシュからのポテンシャルを返す。この関数はthread-safeである。

\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsubsubsection{高レベルAPI}

高レベルAPIの宣言は以下のようになっている。このあと各APIについて記述す
る。
\begin{lstlisting}[caption=ParticleMesh1]
namespace ParticleSimulator {
    namespace ParticleMesh {
        class ParticleMesh{
            template<class Tpsys,
                     class Tdinfo>
            void calcForceAllAndWriteBack
                        (Tpsys & psys,
                         const Tdinfo & dinfo);
        };
    }
}
\end{lstlisting}

\subsubsubsubsubsection{PS::PM::ParticleMesh::calcForceAllAndWriteBack}

\begin{screen}
\begin{verbatim}
template<class Tpsys,
         class Tdinfo>
void PS::PM::ParticleMesh::calcForceAllAndWriteBack
            (Tpsys & psys,
             const Tdinfo & dinfo);
\end{verbatim}
\end{screen}

\begin{itemize}

\item {\bf 引数}

  psys: 入力であり出力。Tpsys \& 型。粒子群クラスのオブジェクト。

  dinfo: 入力。const Tdinfo \&型。領域クラスのオブジェクト。

\item {\bf 返値}

  なし

\item {\bf 機能}

  粒子群クラスのオブジェクトpsysに含まれる粒子間のメッシュ力を計算し、
  その結果をpsysに返す。

\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsubsection{使用済マクロ}
%%BINARY_BOUNDARY, BOUNDARY_COMM_NONBLOCKING, BOUNDARY_SMOOTHING,
%%BUFFER_FOR_TREE, CALCPOT, CLEAN_BOUNDARY_PARTICLE,
%%CONSTANT_TIMESTEP, EXCHANGE_COMM_NONBLOCKING, FFT3D, FFTW3_PARALLEL,
%%FFTW_DOUBLE, FIX_FFTNODE, GADGET_IO, GRAPE_OFF, KCOMPUTER, LONG_ID,
%%MAKE_LIST_PROF, MERGE_SNAPSHOT, MULTI_TIMESTEP, MY_MPI_BARRIER,
%%N128_2H, N256_2H, N256_H, N32_2H, N512_2H, NEW_DECOMPOSITION, NOACC,
%%NPART_DIFFERENT_DUMP, OMP_SCHDULE_DISABLE, PRINT_TANIKAWA,
%%REVERSE_ENDIAN_INPUT, REVERSE_ENDIAN_OUTPUT, RMM_PM,
%%SHIFT_INITIAL_BOUNDARY, STATIC_ARRAY, TREE2,
%%TREECONSTRUCTION_PARALLEL, TREE_PARTICLE_CACHE, UNIFORM, UNSTABLE,
%%USING_MPI_PARTICLE, VERBOSE_MODE, VERBOSE_MODE2

このモジュールでは多くのマクロを使っている。これらを別のマクロとして使
用した場合にプログラムが正しく動作する保証はない。ここでは使用されてい
るマクロをアルファベティカルに列挙する。
\begin{itemize}
\item BINARY\_BOUNDARY
\item BOUNDARY\_COMM\_NONBLOCKING
\item BOUNDARY\_SMOOTHING
\item BUFFER\_FOR\_TREE
\item CALCPOT
\item CLEAN\_BOUNDARY\_PARTICLE
\item CONSTANT\_TIMESTEP
\item EXCHANGE\_COMM\_NONBLOCKING
\item FFT3D
\item FFTW3\_PARALLEL
\item FFTW\_DOUBLE
\item FIX\_FFTNODE
\item GADGET\_IO
\item GRAPE\_OFF
\item KCOMPUTER
\item LONG\_ID
\item MAKE\_LIST\_PROF
\item MERGE\_SNAPSHOT
\item MULTI\_TIMESTEP
\item MY\_MPI\_BARRIER
\item N128\_2H
\item N256\_2H
\item N256\_H
\item N32\_2H
\item N512\_2H
\item NEW\_DECOMPOSITION
\item NOACC
\item NPART\_DIFFERENT\_DUMP
\item OMP\_SCHDULE\_DISABLE
\item PRINT\_TANIKAWA
\item REVERSE\_ENDIAN\_INPUT
\item REVERSE\_ENDIAN\_OUTPUT
\item RMM\_PM
\item SHIFT\_INITIAL\_BOUNDARY
\item STATIC\_ARRAY
\item TREE2
\item TREECONSTRUCTION\_PARALLEL
\item TREE\_PARTICLE\_CACHE
\item UNIFORM
\item UNSTABLE
\item USING\_MPI\_PARTICLE
\item VERBOSE\_MODE
\item VERBOSE\_MODE2。
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsubsection{Particle Meshクラスの使いかた}

Particle Meshクラスを使うには以下の４つのことを行う必要がある。
\begin{enumerate}
\item Particle Meshクラスのコンパイル
\item Particle Meshクラスを使ったFDPSコードの記述
\item FDPSコードのコンパイル
\end{enumerate}
以下、詳細に記述する。

\subsubsubsubsection{Particle Meshクラスのコンパイル}

以下のように行う。ディレクトリsrcの下のディレクトリparticle\_meshの
Makefileを適切に編集してmakeする。編集すべきことは以下の２点である。
\begin{itemize}
\item INCLUDE\_FFTWにFFTWのヘッダファイルがあるディレクトリを記述
  する
\item param\_fdps.hの中のSIZE\_OF\_MESH (１次元方向のメッシュの数)を設定。
推奨値は $N^{1/3}/2$($N$は粒子数)。
\end{itemize}
うまく行けば、同じディレクトリにライブラリlibpm.aとヘッダファイル
particle\_mesh.hppができる。

\subsubsubsubsection{FDPSコードを記述}

以下のように行う。
\begin{itemize}
\item 上でできたヘッダファイルをincludeする
\item PMを計算したい粒子クラスに以下のメンバ関数を加える(この粒子クラスのクラス名をFPとする)
  \begin{itemize}
  \item void FP::copyFromForceParticleMesh(const PS::F32vec \& force)。こ
     の中でforceを好きなメンバ変数にセットする。
  \item PS::F64 FP::getChargeParticleMesh()。この中で質量を返す。
  \end{itemize}
\item このクラスのオブジェクトを生成するときに、PS::PM::ParticleMeshと
する
\end{itemize}

\subsubsubsubsection{FDPSコードのコンパイル}

上で記述したFDPSコードをコンパイルするには以下のことを行う必要がある。
\begin{itemize}
\item ヘッダファイルparticle\_mesh.hppのあるディレクトリへのパスを指定する
\item ライブラリlibpm.aとリンクする
\item FFTWのヘッダファイルがあるディレクトリへのパスを指定する
\item FFTWのライブラリとリンクする
\end{itemize}

\subsubsubsubsection{注意事項}

Particle Meshクラスはプロセス数が2以上でないと、動かないことに注意。
