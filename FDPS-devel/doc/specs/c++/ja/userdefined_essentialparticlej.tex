\subsubsection{概要}EssentialParticleJクラスは相互作用の計算に必要なj粒子の情報を持つクラスであり、相互作用の定義(節\ref{sec:overview_action}の手順0)に必要となる。EssentialParticleJクラスはFullParticleクラス(節\ref{sec:fullparticle})のサブセットである。FDPSは、このクラスのデータにアクセスする必要がある。このために、EssentialParticleJクラスはいくつかのメンバ関数を持つ必要がある。以下、この節の前提、常に必要なメンバ関数と、場合によっては必要なメンバ関数について記述する。\subsubsection{前提}この節の中では、EssentialParticleJクラスとしてEPJというクラスを一例として使う。また、FullParticleクラスの一例としてFPというクラスを使う。EPJ, FPというクラス名は変更可能である。EPJとFPの宣言は以下の通りである。\begin{screen}\begin{verbatim}class FP;class EPJ;\end{verbatim}\end{screen}\subsubsection{必要なメンバ関数}\subsubsubsection{概要}常に必要なメンバ関数はEPJ::getPosとEPJ::copyfromFPである。EPJ::getPosはEPJクラスの位置情報をFDPSに読み込ませるための関数で、EPJ::copyFromFPはFPクラスの情報をEPJクラスに書きこむ関数である。これらのメンバ関数の記述例と解説を以下に示す。\subsubsubsection{EPJ::getPos}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\if 0\begin{screen}\begin{verbatim}class EPJ {public:    PS::F64vec pos;    PS::F64vec getPos() const {        return this->pos;    }};\end{verbatim}\end{screen}\begin{itemize}\item {\bf 前提}    EPJのメンバ変数posはある１つの粒子の位置情報。このposのデー  タ型はPS::F64vec型。  \item {\bf 引数}  なし  \item {\bf 返値}  PS::F64vec型。EPJクラスの位置情報を保持したメンバ変数。  \item {\bf 機能}  EPJクラスの位置情報を保持したメンバ変数を返す。  \item {\bf 備考}  EPJクラスのメンバ変数posの変数名は変更可能。\end{itemize}\fi%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\begin{screen}\begin{verbatim}class EPJ {public:    PS::F64vec getPos() const;};\end{verbatim}\end{screen}\begin{itemize}\item {\bf 引数}  なし  \item {\bf 返値}  PS::F64vec型。EPJクラスの位置情報を保持したメンバ変数。  \item {\bf 機能}  EPJクラスの位置情報を保持したメンバ変数を返す。  \end{itemize}\subsubsubsection{EPJ::copyFromFP}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\if 0\begin{screen}\begin{verbatim}class FP {public:    PS::S64    identity;    PS::F64    mass;    PS::F64vec position;    PS::F64vec velocity;    PS::F64vec acceleration;    PS::F64    potential;};class EPJ {public:    PS::S64    id;    PS::F64    m;    PS::F64vec pos;    void copyFromFP(const FP & fp) {        this->id  = fp.identity;        this->m   = fp.mass;        this->pos = fp.position;    }};\end{verbatim}\end{screen}\begin{itemize}\item {\bf 前提}  FPクラスのメンバ変数identity, mass, positionと  EPJクラスのメンバ変数id, m, posはそれぞれ対応する情報  を持つ。\item {\bf 引数}  fp: 入力。const FP \&型。FPクラスの情報を持つ。  \item {\bf 返値}  なし。  \item {\bf 機能}  FPクラスの持つ１粒子の情報の一部をEPJクラスに書き込む。  \item {\bf 備考}  FPクラスのメンバ変数の変数名、EPJクラスのメンバ変数の変数名は変更可  能。メンバ関数EPJ::copyFromFPの引数名は変更可能。対応する情報を持つ  メンバ変数同士のデータ型が一致している必要はないが、実数型とベクトル  型(または整数型とベクトル型)という違いがある場合に正しく動作する保証  はない。\end{itemize}\fi%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\begin{screen}\begin{verbatim}class FP;class EPJ {public:    void copyFromFP(const FP & fp);};\end{verbatim}\end{screen}\begin{itemize}\item {\bf 引数}  fp: 入力。const FP \&型。FPクラスの情報を持つ。  \item {\bf 返値}  なし。  \item {\bf 機能}  FPクラスの持つ１粒子の情報の一部をEPJクラスに書き込む。  \end{itemize}\subsubsection{場合によっては必要なメンバ関数}\subsubsubsection{概要}本節では、場合によっては必要なメンバ関数について記述する。相互作用ツリークラスのPS::SEARCH\_MODE型にPS::SEARCH\_MODE\_LONG以外を用いる場合に必要なメンバ関数、列挙型のBOUNDARY\_CONDITION型にPS::BOUNDARY\_CONDITION\_OPEN以外を選んだ場合に必要となるメンバ関数について記述する。なお、既存のMomentクラスやSuperParticleJクラスを用いる際に必要となるメンバ変数はこれら既存のクラスの節を参照のこと。\subsubsubsection{相互作用ツリークラスのPS::SEARCH\_MODE型に\\PS::SEARCH\_MODE\_LONG以外を用いる場合}\subsubsubsubsection{EPJ::getRSearch}\begin{screen}\begin{verbatim}class EPJ {public:    PS::F64 getRSearch() const;};\end{verbatim}\end{screen}\begin{itemize}\item {\bf 引数}  なし  \item {\bf 返値}  PS::F32型またはPS::F64型。 EPJクラスの近傍粒子を探す  半径の大きさを保持したメンバ変数。  \item {\bf 機能}  EPJクラスの近傍粒子を探す半径の大きさを保持したメンバ  変数を返す。
  
  なお、PS::SEARCH\_MODE型にPS::SEARCH\_MODE\_LONG\_CUTOFFを用いる場合、すべてのEPJが同じ値を返すように定義しなければならない。
\end{itemize}\subsubsubsection{BOUNDARY\_CONDITION型にPS::BOUNDARY\_CONDITION\_OPEN以外を用いる場合}\subsubsubsubsection{EPJ::setPos}\begin{screen}\begin{verbatim}class EPJ {public:    void setPos(const PS::F64vec pos_new);};\end{verbatim}\end{screen}\begin{itemize}\item {\bf 引数}  pos\_new: 入力。const PS::F32vecまたはconst PS::F64vec型。FDPS側で修  正した粒子の位置情報。\item {\bf 返値}  なし。  \item {\bf 機能}  FDPSが修正した粒子の位置情報をEPJクラスの位置情報に書き込む。\end{itemize}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\subsubsubsection{粒子のid番号から対応するEPJを取得したい場合}\subsubsubsubsection{EPJ::getId}\label{sec:EPJ:getId}\begin{screen}\begin{verbatim}class EPJ {public:    PS::S64 getId();};\end{verbatim}\end{screen}\begin{itemize}\item {\bf 引数}なし。\item {\bf 返値}PS::S64型。  \item {\bf 機能}PS::TreeForForce::getEpjFromId()を使用する場合に必要。詳しくは\ref{sec:getEpjFromId}を参照。\end{itemize}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\subsubsubsection{LET交換時に粒子データをシリアライズして送る場合}\label{sec:EPJ:serialize}LET交換時に粒子データをシリアライズして送る場合には、メンバ関数にEPJ::packとEPJ::unpackを用意する必要がある。以下にそれぞれの規定を記述する。%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\subsubsubsubsection{EPJ::pack}\begin{screen}\begin{verbatim}class EPJ {public:    static PS::S32 pack(const PS::S32 n_ptcl, const EPJ *ptcl[], char *buf,                         size_t & packed_size, const size_t max_buf_size);};\end{verbatim}\end{screen}\begin{itemize}\item {\bf 引数}  n\_ptcl: LET交換時に送る粒子の数。\\  ptcl: 送る粒子へのポインタの配列。\\  buf: 送信バッファーの先頭アドレス。\\  packed\_size: ユーザーがバッファーへ書き込むサイズ。単位はバイト。\\  max\_buf\_size: 送信バッファーの書き込み可能な領域のサイズ。単位はバイト。\item {\bf 返値}  PS::S32型。packed\_sizeがmax\_buf\_sizeを超えた場合は-1を返す。それ  以外の場合は0を返す。  \item {\bf 機能}  LET交換時に送信する粒子をシリアライズし、送信バッファーに書き込む。\end{itemize}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\subsubsubsubsection{EPJ::unPack}\begin{screen}\begin{verbatim}class EPJ {public:    static void unPack(const PS::S32 n_ptcl, EPJ ptcl[], const char *buf);};\end{verbatim}\end{screen}\begin{itemize}\item {\bf 引数}  n\_ptcl: LET交換時に受け取る粒子の数。\\  ptcl: 受け取る粒子の配列。\\  buf: 受信バッファーの先頭アドレス。\\\item {\bf 返値}  なし。\item {\bf 機能} LET交換時に受信する粒子をデシリアライズし、粒子配列に書き込む。詳しく はセクション\ref{sec:treeForForceHighLevelAPI}を参照。デシリアライズ に失敗した場合はPS::Abort()が呼ばれプログラムは終了する。\end{itemize}