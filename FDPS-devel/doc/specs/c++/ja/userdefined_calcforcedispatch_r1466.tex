\subsubsection{概要}関数calcForceDispatchは関数calcForceRetrieveと合わせて粒子同士の相互作用を記述するものであり、calcForceSpEp やcalcForceEpEp の代わりに相互作用の定義(節\ref{sec:overview_action}の手順0)に使うことができる。calcForceSpEp やcalcForceEpEp との違いは、calcForceDispatch は複数の相互作用リストと i粒子リストを受け取ることである。これにより、GPGPU 等のアクセラレータを起動する回数を削減し、実行効率を向上させる。相互作用リストを作る方法として、粒子自体の相互作用リストを作る方法と初期に必要となる全粒子の情報をデバイスメモリー上に送り、粒子インデックスのみの相互作用リストを作る方法の二通りが用意されている。以下、これの書き方の規定を記述する。関数calcForceDispatchの名前はGravityDispatchとする。これは変更自由である。また、EssentialParitlceIクラスのクラス名をEPI,EssentialParitlceJクラスのクラス名をEPJ, SuperParitlceJクラスのクラス名をSPJとする。\subsubsection{短距離力の場合}\subsubsubsection{粒子の相互作用リストを作る場合}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\begin{lstlisting}[caption=calcForceDispatch]class EPI;class EPJ;PS::S32 HydroforceDispatch(const PS::S32  tag,                           const PS::S32  nwalk,                           const EPI**      epi,                           const PS::S32*  ni,                           const EPJ**      epj,                           const PS::S32*  nj_ep;};\end{lstlisting}\begin{itemize}\item {\bf 引数}  tag: 入力。const PS::S32 型。tagの番号。発行されるtagの番号は\\  0から関数PS::TreeForForce::calcForceAllandWriteBackMultiWalk()の\\  第三引数として設定された値から1引いた数までである。\\  tagの番号はcalcForceRetrieve()で設定するtagの番号と対応させる必要がある。  nwalk: 入力。const PS::S32 型。walkの数。walkの数の最大値は\\  PS::TreeForForce::calcForceAllandWriteBackMultiWalk()の第六引数の値である。  epi: 入力。const EPI** 型。i粒子情報を持つポインタのポインタ。  ni: 入力。const PS::S32*型。i粒子数のポインタ。  epj: 入力。const EPJ** 型。j粒子情報を持つポインタのポインタ。    nj\_ep: 入力。const PS::S32* 型。j粒子数のポインタ。\item {\bf 返値}  PS::S32型。ユーザーは正常に実行された場合は0を、エラーが起こった場合  は0以外の値を返すようにする。  \item {\bf 機能}毎回epi,epjの相互作用リストをアクセラレータに送り、相互作用カーネルを発行する。  \end{itemize}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\subsubsubsection{粒子のインデックスのみの相互作用リストを作る場合}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\begin{lstlisting}[caption=calcForceDispatch]PS::S32 GravityDispatch(const PS::S32   tag,                        const PS::S32   nwalk,                        const TEpi**    iptcl,                        const PS::S32*  ni,                        const PS::S32** id_jptcl_ep,                        const PS::S32*  nj_ep,                        const TEpj*     jptcl_ep,                        const PS::S32   n_send_ep,                        const bool send_ptcl);\end{lstlisting}\begin{itemize}\item {\bf 引数}  tag: 入力。const PS::S32 型。tagの番号。発行されるtagの番号は\\  0から関数PS::TreeForForce::calcForceAllandWriteBackMultiWalk()の\\  第三引数として設定された値から1引いた数までである。\\  tagの番号はcalcForceRetrieve()で設定するtagの番号と対応させる必要がある。  nwalk: 入力。const PS::S32 型。walkの数。walkの数の最大値は  PS::TreeForForce::calcForceAllandWriteBackMultiWalk()の第六引数の値  である。  epi: 入力。const EPI** 型。i粒子情報を持つ配列の配列。  ni: 入力。const PS::S32*型。i粒子数の配列。  id\_epj: 入力。const EPJ** 型。EPJのインデックスの配列の配列。    nj\_ep: 入力。const PS::S32* 型。j粒子数の配列。  epj: 入力。const EPJ* 型。j粒子情報を持つ配列。  n\_send\_ep: 入力。const PS::S32型。デバイスに送るepjの数。  send\_ptcl: 入力。const bool型。epjとspjの配列をデバイスに送るかを決  める。\item {\bf 返値}  PS::S32型。ユーザーは正常に実行された場合は0を、エラーが起こった場合  は0以外の値を返すようにする。  \item {\bf 機能}send\_ptclがtrueの場合、epjをデバイスメモリー上に送る。毎回epiの配列とepjのインデックスの相互作用リストをアクセラレータに送り、相互作用カーネルを発行する。  \end{itemize}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\subsubsection{長距離力の場合}\subsubsubsection{粒子の相互作用リストを作る場合}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\begin{lstlisting}[caption=calcForceDispatch]class EPI;class EPJ;class SPJ;PS::S32 GravityDispatch(const PS::S32   tag,                        const PS::S32   nwalk,                        const EPI**     epi,                        const PS::S32*  ni,                        const EPJ**     epj,                        const PS::S32*  nj_ep,                        const SPJ**     spj,                        const PS::S32*  nj_sp);};\end{lstlisting}\begin{itemize}\item {\bf 引数}  tag: 入力。const PS::S32 型。tagの番号。発行されるtagの番号は0から関  数PS::TreeForForce::calcForceAllandWriteBackMultiWalk()の第三引数と  して設定された値から1引いた数までである。tagの番号は  calcForceRetrieve()で設定するtagの番号と対応させる必要がある。  nwalk: 入力。const PS::S32 型。walkの数。walkの数の最大値は  PS::TreeForForce::calcForceAllandWriteBackMultiWalk()の第六引数の値  である。  epi: 入力。const EPI** 型。i粒子情報を持つ配列の配列。  ni: 入力。const PS::S32*型。i粒子数の配列。  epj: 入力。const EPJ** 型。j粒子情報を持つ配列の配列。    nj\_ep: 入力。const PS::S32* 型。j粒子数の配列。  spj: 入力。const SPJ** 型。j粒子情報を持つ配列の配列。    nj\_sp: 入力。const PS::S32* 型。j粒子数の配列。\item {\bf 返値}  PS::S32型。ユーザーは正常に実行された場合は0を、エラーが起こった場合  は0以外の値を返すようにする。  \item {\bf 機能}epi,epj,spjの情報をアクセラレータに送り、相互作用カーネルを発行する。  \end{itemize}\subsubsubsection{粒子のインデックスのみの相互作用リストを作る場合}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\begin{lstlisting}[caption=calcForceDispatch]PS::S32 GravityDispatch(const PS::S32   tag,                        const PS::S32   nwalk,                        const TEpi**    iptcl,                        const PS::S32*  ni,                        const PS::S32** id_jptcl_ep,                        const PS::S32*  nj_ep,                        const PS::S32** id_jptcl_sp,                        const PS::S32*  nj_sp,                        const TEpj*     jptcl_ep,                        const PS::S32   n_send_ep,                        const TSpj*     jptcl_sp,                        const PS::S32   n_send_sp,                        const bool send_ptcl);\end{lstlisting}\begin{itemize}\item {\bf 引数}  tag: 入力。const PS::S32 型。tagの番号。発行されるtagの番号は0から関  数PS::TreeForForce::calcForceAllandWriteBackMultiWalk()の第三引数と  して設定された値から1引いた数までである。tagの番号は  calcForceRetrieve()で設定するtagの番号と対応させる必要がある。  nwalk: 入力。const PS::S32 型。walkの数。walkの数の最大値は  PS::TreeForForce::calcForceAllandWriteBackMultiWalk()の第六引数の値  である。  epi: 入力。const EPI** 型。i粒子情報を持つ配列の配列。  ni: 入力。const PS::S32*型。i粒子数の配列。  id\_epj: 入力。const EPJ** 型。EPJのインデックスの配列の配列。    nj\_ep: 入力。const PS::S32* 型。j粒子数の配列。  id\_spj: 入力。const PS::S32** 型。SPJのインデックスの配列の配列。    nj\_sp: 入力。const PS::S32* 型。j粒子数の配列。  epj: 入力。const EPJ* 型。j粒子情報を持つ配列。  n\_send\_ep: 入力。const PS::S32型。デバイスに送るepjの数。  spj: 入力。const SPJ* 型。j粒子情報を持つ配列の配列。  n\_send\_sp: 入力。const PS::S32型。デバイスに送るepjの数。  send\_ptcl: 入力。const bool型。epjとspjの配列をデバイスに送るかを決  める。\item {\bf 返値}  PS::S32型。ユーザーは正常に実行された場合は0を、エラーが起こった場合  は0以外の値を返すようにする。  \item {\bf 機能}send\_ptclがtrueの場合、epj,spjをデバイスメモリー上に送る。毎回epiの配列とepj、spjのインデックスの相互作用リストをアクセラレータに送り、相互作用カーネルを発行する。\item {\bf 例}\begin{lstlisting}[caption=calcForceDispatchExample]PS::S32 DispatchKernelWithSPIndex(const PS::S32   tag,                                  const PS::S32   nwalk,                                  const TEpi**    iptcl,                                  const PS::S32*  ni,                                  const PS::S32** id_jptcl_ep,                                  const PS::S32*  nj_ep,                                  const PS::S32** id_jptcl_sp,                                  const PS::S32*  nj_sp,                                  const TEpj*     jptcl_ep,                                  const PS::S32   n_send_ep,                                  const TSpj*     jptcl_sp,                                  const PS::S32   n_send_sp,                                  const bool send_ptcl){    int nj_tot = 0;    cl_int ret;    if(n_walk <= -1){        for(int j=0; j<n_epj[0]; j++){            epj_h[j].px   = jptcl_ep[j].pos.x;            epj_h[j].py   = jptcl_ep[j].pos.y;            epj_h[j].pz   = jptcl_ep[j].pos.z;            epj_h[j].mass = jptcl_ep[j].mass;        }        for(int j=0; j<n_spj[0]; j++){            spj_h[j].px   = jptcl_sp[j].pos.x;            spj_h[j].py   = jptcl_sp[j].pos.y;            spj_h[j].pz   = jptcl_sp[j].pos.z;            spj_h[j].mass = jptcl_sp[j].getCharge();        }        ret = clEnqueueWriteBuffer(command_queue, epj_d,   CL_TRUE, 0, (n_send_ep)*sizeof(EpjDev),  epj_h, 0, NULL, NULL);        ret = clEnqueueWriteBuffer(command_queue, spj_d,   CL_TRUE, 0, (n_send_sp)*sizeof(SpjDev),  spj_h, 0, NULL, NULL);        return 0;    }    const float eps2 = FPGrav::eps * FPGrav::eps;    PS::S32 ni_tot = 0;    j_disp_h[0] = 0;    for(int k=0; k<n_walk; k++){        ni_tot += GetQuantizedValue(n_epi[k], NI_PIPE);        assert(GetQuantizedValue(n_epi[k], NI_PIPE) \% NI_PIPE == 0);        j_disp_h[k+1] = j_disp_h[k] + (n_epj[k] + n_spj[k]);    }    j_disp_h[n_walk+1] = j_disp_h[n_walk];    assert(ni_tot < NI_LIMIT);    assert(j_disp_h[n_walk] < NJ_LIMIT);    ret = clEnqueueWriteBuffer(command_queue, j_disp_d, CL_TRUE, 0, (n_walk+2)*sizeof(int), j_disp_h, 0, NULL, NULL);    ni_tot = 0;    nepj_tot = 0;    for(int iw=0; iw<n_walk; iw++){        for(int i=0; i<n_epi[iw]; i++){            epi_h[ni_tot].px = epi[iw][i].pos.x;            epi_h[ni_tot].py = epi[iw][i].pos.y;            epi_h[ni_tot].pz = epi[iw][i].pos.z;            epi_h[ni_tot].id_walk = iw;            ni_tot++;        }        for(int i=n_epi[iw]; i<GetQuantizedValue(n_epi[iw], NI_PIPE); i++){            epi_h[ni_tot].px = 0.0;            epi_h[ni_tot].py = 0.0;            epi_h[ni_tot].pz = 0.0;            epi_h[ni_tot].id_walk = iw;            ni_tot++;        }        for(int j=0; j<n_epj[iw]; j++){            id_epj_h[nepj_tot++] = id_epj[iw][j];        }        for(int j=0; j<n_spj[iw]; j++){            id_spj_h[nspj_tot++] = id_spj[iw][j];        }    }    ret = clEnqueueWriteBuffer(command_queue, epi_d,    CL_TRUE, 0, (ni_tot)*sizeof(EpiDev),    epi_h,    0, NULL, NULL);    ret = clEnqueueWriteBuffer(command_queue, id_epj_d, CL_TRUE, 0, (nepj_tot)*sizeof(PS::S32), id_epj_h, 0, NULL, NULL);    ret = clEnqueueWriteBuffer(command_queue, id_spj_d, CL_TRUE, 0, (nspj_tot)*sizeof(PS::S32), id_spj_h, 0, NULL, NULL);        ret = clSetKernelArg(kernel_index, 0, sizeof(cl_mem), (void*)&j_disp_d);    ret = clSetKernelArg(kernel_index, 1, sizeof(cl_mem), (void*)&epi_d);    ret = clSetKernelArg(kernel_index, 2, sizeof(cl_mem), (void*)&epj_d);    ret = clSetKernelArg(kernel_index, 3, sizeof(cl_mem), (void*)&id_epj_d);    ret = clSetKernelArg(kernel_index, 4, sizeof(cl_mem), (void*)&force_d);    ret = clSetKernelArg(kernel_index, 5, sizeof(float),  (void*)&eps2);    ret = clSetKernelArg(kernel_index, 6, sizeof(int),    (void*)&ni_tot);    size_t work_size = N_THREAD_MAX;    ret = clEnqueueNDRangeKernel(command_queue, kernel_index, 1, NULL, &work_size, NULL, 0, NULL, &event_force);    return 0;}\end{lstlisting}\end{itemize}