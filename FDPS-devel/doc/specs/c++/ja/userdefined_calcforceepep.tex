\subsubsection{概要}関数オブジェクトcalcForceEpEpは粒子同士の相互作用を記述するものであり、相互作用の定義(節\ref{sec:overview_action}の手順0)に必要となる。以下、これの書き方の規定を記述する。\subsubsection{前提}ここで示すのは重力N体シミュレーションの粒子間相互作用の記述の仕方である。関数オブジェクトcalcForceEpEpの名前はgravityEpEpとする。これは変更自由である。また、EssentialParitlceIクラスのクラス名をEPI,EssentialParitlceJクラスのクラス名をEPJ, Forceクラスのクラス名をResultとする。\subsubsection{gravityEpEp::operator ()}\if 0\begin{lstlisting}[caption=calcForceEpEp]class Result {public:    PS::F32vec acc;};class EPI {public:    PS::S32    id;    PS::F32vec pos;};class EPJ {public:    PS::S32    id;    PS::F32    mass;    PS::F32vec pos;};struct gravityEpEp {    static PS::F32 eps2;    void operator () (const EPI *epi,                      const PS::S32 ni,                      const EPJ *epj,                      const PS::S32 nj,                      Result *result) {        for(PS::S32 i = 0; i < ni; i++) {            PS::S32    ii = epi[i].id;            PS::F32vec xi = epi[i].pos;            PS::F32vec ai = 0.0;            for(PS::S32 j = 0; j < nj; j++) {                PS::S32    jj = epj[j].id;                PS::F32    mj = epj[j].mass;                PS::F32vec xj = epj[j].pos;                PS::F32vec dx   = xi - xj;                PS::F32    r2   = dx * dx + eps2;                PS::F32    rinv = (ii != jj) ? 1. / sqrt(r2)                                             : 0.0;                ai += mj * rinv * rinv * rinv * dx;            }            result.acc = ai;        }    }};PS::F32 gravityEpEp::eps2 = 9.765625e-4;\end{lstlisting}\begin{itemize}\item {\bf 前提}  クラスResult, EPI, EPJに必要なメンバ関数は省略した。クラスResultのメ  ンバ変数accはi粒子がj粒子から受ける重力加速度である。クラスEPIとEPJ  のメンバ変数idとposはそれぞれの粒子IDと粒子位置である。クラスEPJのメ  ンバ変数massはj粒子の質量である。関数オブジェクトgravityEpEpのメンバ  変数eps2は重力ソフトニングの2乗である。ここの外側でスレッド並列になっ  ているため、ここでOpenMPを記述する必要はない。\item {\bf 引数}  epi: 入力。const EPI *型またはEPI *型。i粒子情報を持つ配列。  ni: 入力。const PS::S32型またはPS::S32型。i粒子数。  epj: 入力。const EPJ *型またはEPJ *型。j粒子情報を持つ配列。    nj: 入力。const PS::S32型またはPS::S32型。j粒子数。  result: 出力。Result *型。i粒子の相互作用結果を返す配列。\item {\bf 返値}  なし。  \item {\bf 機能}  j粒子からi粒子への作用を計算する。  \item {\bf 備考}  引数名すべて変更可能。関数オブジェクトの内容などはすべて変更可能。  \end{itemize}\fi\begin{lstlisting}[caption=calcForceEpEp]class Result;class EPI;class EPJ;struct gravityEpEp {    void operator () (const EPI *epi,                      const PS::S32 ni,                      const EPJ *epj,                      const PS::S32 nj,                      Result *result);};\end{lstlisting}\begin{itemize}\item {\bf 引数}  epi: 入力。const EPI *型またはEPI *型。i粒子情報を持つ配列。  ni: 入力。const PS::S32型またはPS::S32型。i粒子数。  epj: 入力。const EPJ *型またはEPJ *型。j粒子情報を持つ配列。    nj: 入力。const PS::S32型またはPS::S32型。j粒子数。  result: 出力。Result *型。i粒子の相互作用結果を返す配列。\item {\bf 返値}  なし。  \item {\bf 機能}  j粒子からi粒子への作用を計算する。  \end{itemize}