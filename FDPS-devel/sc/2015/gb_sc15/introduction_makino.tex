Particle-based simulations have been widely used in the field of
computational science, and they are becoming more and more
popular. In particle-based simulations, a system under study is
regarded as a collection of mutually-interacting particles, or
a particle system,  and its
evolution is described by the evolution (in many cases, motion) of
individual particles. Examples of particle-based simulations include
gravitational $N$-body simulation, molecular dynamics simulation,
granular dynamics simulation, and element-free simulation of fluid
dynamics or structural analysis. In the case of molecular dynamics and
gravitational $N$-body simulations, the physical system under study is
a collection of particles, and the particle-based method is a natural
way to simulate the system. Element-free methods have advantages over
structured (or unstructured) grid-based method, depending on the
nature of the system and computer system to be used. 

In order to improve the resolution and accuracy of particle-based
simulations, it is necessary to utilize present-day HPC systems.
However, to develop a calculation code for particle systems
which can achieve high efficiency on present-day HPC systems is
difficult and time-consuming. There are several reasons for this
difficulty. In order to achieve high efficiency, we need to decompose
the computational domain, assign subdomains to computing nodes, and
redistribute particles according to their positions. This
decomposition should be dynamically changed to guarantee the good load
balance. This division of the computational domain means that
computing nodes need to exchange the information of particles to
evaluate the interactions on their particles. To achieve high
efficiency, the amount of the exchanged data must be minimized, and
interaction calculation should also be efficient, making good use of
cache memory and SIMD execution units. It is also important to make
use of GPGPUs or other types of accelerators, if available.

Domain decomposition and load balance have been discussed in a number
of works \cite{1994JCoPh.111..136S, 1996NewA....1..133D,
confscWarrenSBGSW97, 2004PASJ...56..521M, ishiyama:greem,
ishiyama:gordonbell}.  The efficient use of SIMD units is discussed
in \cite{2006NewA...12..169N,2012NewA...17...82T,2013NewA...19...74T},
and GPGPUs in \cite{hamada2009novel, 2009NewA...14..630G,
Hamada:2009:THN:1654059.1654123, Hamada:2010:TAN:1884643.1884644,
2012JCoPh.231.2825B, Bedorf:2014:PGT:2683593.2683600}.

Thus, to develop a code which has all of these necessary features for
present-day HPC systems has become a big project which requires
multi-year effort of a multi-person team. It has become difficult for
researchers outside such a team to try any new experiment which
requires nontrivial modification of the code. If one wants to develop
a new numerical scheme for particle-based simulation or to apply it to
new problem, it is necessary to write his/her own code. However, it is
practically impossible for a single person, or even for a group of
people, to develop a new code which can run efficiently on present-day
HPC systems in reasonable time.  This difficulty, in our opinion, has
slowed down the evolution of the entire field of computational science
in the last two decades or around. Here we discussed the situation of
particle-based codes. The situation of grid-based codes is similar. 


In order to overcome the difficulty described above, we developed FDPS
(Framework for Developing Particle
Simulator)\footnote{https://github.com/FDPS/FDPS}. Our goal is to
provide a software framework which enables researchers and programmers
to develop high-performance particle simulation codes quickly. The
basic idea of FDPS is to separate the above-described ``difficult''
part of the code, such as the domain decomposition and exchange of
particles, from the description of the physical problem itself. The
difficult part is implemented in FDPS as a library. A user of FDPS
need to define the data structure of particles and the interaction
function of particles. Then FDPS received these code, and generates an
efficient code to perform domain decomposition and parallelized
calculation of interaction. The user program first uses the functions
of FDPS to do the interaction calculation, and then updates the
physical data of particles, and repeats this loop until the end of
simulation.  Thus, the user of FDPS does not have to write complex
code for parallelization.


FDPS supports particle simulations with arbitrary pairwize
particle-particle interactions. If the physical system include
many-body interactions, a user can calculate such interaction within
his/her code, letting FDPS do the parallelization and calculation of
pairwise interactions.  In FDPS, the separation of parallelization and
physical problem is done through the use of abstract data types
implemented using C++ templates. Users of FDPS provide actual particle
data class and interaction function to the template class defined in
FDPS. Thus, users can develop a gravitational $N$-body code, and SPH
code, other particles-based fluid code, large-scale molecular dynamics
code, a DEM code, and many other particle-based code using FDPS, and
all of them will automatically parallelized with near-optimal load
balancing. A similar approach to provide general-purpose framework is
in \cite{1995CoPhC..87..266W}, but it was limited to long-range
interaction with $1/r$ potential.


One might think that, even though it is not impossible to develop
general-purpose framework for parallel particle-based simulations,
such a framework would be inherently slow. Since the goal of FDPS is
to make efficient use of present-day HPC systems, we designed FDPS so
that it can achieve the performance not worse than that of existing
large-scale parallel codes for particle simulations. We will discuss
the achieved performance later.

The structure of this paper is as follows. In section~\ref{sec:user},
we overview how FDPS users implement a simulation code on FDPS.  In
section~\ref{sec:implementation}, we describe parallel algorithm
implemented in FDPS. In section~\ref{sec:performance}, we illustrate
how FDPS actually simplifies the development of user programs, using
two sample FDPS applications, and describe their performance. Finally,
we summarize this study in section~\ref{sec:conclusion}.
