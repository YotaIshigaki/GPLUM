In this section, we present the complete working example of a
simulation code written using FDPS, to illustrate how a user actually
uses FDPS. As the target problem, we use the gravitational $N$-body
problem with an open boundary.  Within the terminology of FDPS, the
interaction between particles in the gravitational $N$-body problem is
of the ``long-range'' type. Therefore, we need to specify the function
to calculate interactions for both the ordinary particles and
superparticles. For the sake of brevity, we use the center-of-mass
approximation for superparticles, which means that we can actually use
the same function for both types of particles.

The physical quantity vector $\myvec{u}_i$ and interaction functions
$\myvec{f}$, $\myvec{f'}$, and $\myvec{g}$ for the gravitational
$N$-body problem is now given by:
\begin{align}
  \myvec{u}_i &= (\myvec{r}_i,
  \myvec{v}_i,m_i) \label{eq:PhysicalVectorNbody} \\
%%  
  \myvec{f} (\myvec{u}_i, \myvec{u}_j) &= \frac{Gm_j \left(
    \myvec{r}_j - \myvec{r}_i \right)}{ \left( |\myvec{r}_j -
    \myvec{r}_i|^2 + \epsilon_i^2
    \right)^{3/2}} \label{eq:ParticleParticleNbody} \\
%%
  \myvec{f'} (\myvec{u}_i, \myvec{u'}_j) &= \frac{Gm_j' \left(
    \myvec{r'}_j - \myvec{r}_i \right)}{ \left( |\myvec{r'}_j -
    \myvec{r}_i|^2 + \epsilon_i^2
    \right)^{3/2}} \label{eq:ParticleSuperparticleNbody} \\
%%
  \myvec{g}(\myvec{F}_i,\myvec{u}_i) &= (\myvec{v}_i,\myvec{F}_i,0),
\label{eq:ConversionNbody} \\
%%
  \myvec{F}_i
  &= \sum_j^{N_{\mathrm{J},i}} \myvec{f}(\myvec{u}_i,\myvec{u}_j)
  + \sum_{j'}^{N_{\mathrm{S},i}} \myvec{f'}(\myvec{u}_i,\myvec{u'}_{j'})
\end{align}
where $m_i$, $\myvec{r}_i$, $\myvec{v}_i$, and $\epsilon_i$ are, the
mass, position, velocity, and gravitational softening of particle $i$,
$m_j'$ and $\myvec{r'}_j$ are, the mass and position of a
superparticle $j$, and $G$ is the gravitational constant.  Note that
the shapes of the functions $\myvec{f}$ and $\myvec{f'}$ are the same.

\input{sample_src.tex}

Listing~\ref{code:samplecode} shows the complete code which can be
actually compiled and run, not only on a single-core machine but also
massively-parallel, distributed-memory machines such as the full-node
configuration of the K computer. The total number of lines is only
117.

Now let us explain how this sample code works. This code consists of
four parts: The declaration to use FDPS (lines 1 and 2), the
definition of the particle (the vector $\myvec{u}_i$) (lines 4 to 35),
the definition of the gravitational force (the functions $\myvec{f}$
and $\myvec{f'}$) (lines 37 to 61), and the actual user program,
comprising a user-defined main routine and user-defined functions from
which library functions of FDPS are called (lines 63 to line 117). In
the following, we explain them step by step.

In order to declare to use FDPS, the only thing the user program need
to do is to include the header file ``particle\_simulator.hpp''. This
file and other source library files of FDPS should be in the include
path of the compiler. Everything in the standard FDPS library is
provided as the header source library, since they are implemented as
template libraries which need to receive particle class and
interaction functions. Everything in FDPS is provided in the namespace
``PS''. Therefore in this sample program, we declare it as the default
namespace to simplify the code. (For simplicity's sake, we do not omit
the namespace ``PS'' of FDPS functions and class templates in the main
routine.)

Before going to the 2nd parts, let us list the data types and classes
defined in FDPS. \texttt{F32/F64} are data types of 32-bit and 64-bit
floating points. \texttt{S32} is a data type of 32-bit signed integer.
\texttt{F64vec} is a class of a vector consisting of three 64-bit
floating points. This class provides several operators, such as the
addition, subtraction and the inner product indicated by ``$*$''.
Users need not use these data types in their own program, but some of
the functions which users should define should return the values in
these data types.

In the 2nd part, we define the particle, i.e. the vector
$\myvec{u}_i$, as a class \texttt{Nbody}. This class has member
variables: \texttt{mass} ($m_i$), \texttt{eps}
($\epsilon_i$), \texttt{pos} ($\myvec{r}_i$), \texttt{vel}
($\myvec{v}_i$), and \texttt{acc} ($d\myvec{v}_i/dt$). Although the
member variable \texttt{acc} does not appear in
equation~(\ref{eq:PhysicalVectorNbody}) -- (\ref{eq:ConversionNbody}),
we need this variable to store the result of the gravitational force
calculation. A particle class for FDPS must provide public member
functions \texttt{getPos}, \texttt{getCharge}, \texttt{copyFromFP},
\texttt{copyFromForce}, \texttt{clear},
and \texttt{readAscii}, in these names, so that the internal functions
of FDPS can access the data within the particle class.  For the name
of the particle class itself and the names of the member variables, a
user can use whatever names allowed by the C++ syntax.  The member
functions \texttt{predict} and \texttt{correct} are used in the
user-defined part of the code to integrate the orbits of particles.
Note that since the interaction used here is of $1/r$ type, the
definition and construction method of the superparticle are given as
the default in FDPS and not shown here.

In the 3rd part, the interaction functions $\myvec{f}$ and
$\myvec{f'}$ are defined. Since the shapes of the functions
$\myvec{f}$ and $\myvec{f'}$ are the same, we give one as a template
function.  The interaction function used in FDPS should have the
following five arguments. The first argument \texttt{ip} is the
pointer to the array of variables of particle
class \texttt{Nbody}. This argument specifies $i$-particles which
receive the interaction. The second argument \texttt{ni} is the number
of $i$-particles. The third argument \texttt{jp} is the pointer to the
array of variable of a template data type \texttt{TPJ}. This argument
specifies $j$-particles or superparticles which exert the
interaction. The fourth argument \texttt{nj} is the number of
$j$-particles or super-particles. The fifth argument \texttt{force} is
the pointer to the array of a variable of a user-defined class to
which the calculated interaction on an $i$-particle can be stored. In
this example, we used the particle class itself, but this can be
another class or a simple array.

%
The interaction function should be defined as a function object, so
that it can be passed to other functions as argument. Thus, it is
declared as a \texttt{struct}, with the only member
function \texttt{operator ()}.  In this example, the interaction is
calculated through a simple double loop. In order to make full
advantage of the SIMD unit in modern processors,
architecture-dependent tuning may be necessary, but only to this
single function.

In the 4th part, we give the main routine and functions called from
the main routine. In the main routine, we first initialize FDPS by
calling \texttt{PS::Initialize} (line 95). Next, we create and
initialize objects of FDPS classes (lines 96 to 102). In line 103, we
read particle data from a file by calling FDPS
function \texttt{PS::readParticleAscii}. Then, we calculate gravity of
all the particles at the initial time by calling a
function \texttt{calcGravAllAndWriteBack} (lines 104 to 106). In this
function, we decompose the computational domain by
calling \texttt{decomposeDomainAll} (line 83), relocate particle data
by calling \texttt{exchangeParticle} (line 84), and calculate gravity
by calling \texttt{calcForceAllAndWriteBack} (lines 85 to 88). From
line 107 to line 114, we integrate the orbits of all the particles
with Leap-Frog method. Finally, we finalize FDPS by
calling \texttt{PS::Finalize} (line 115).

%In the 4th part, we give the main routine and functions called from
%the main routine. In the following, we describe the main routine in
%detail, and briefly discuss other functions. The main routine
%consists of the following seven steps:
%\begin{enumerate}
%\item Set simulation time and timestep (lines 92 to 94). \label{proc:literal}
%\item Initialize FDPS (line 95). \label{proc:init}
%\item Create and initialize objects of FDPS classes (lines 96 to 102). \label{proc:construct}
%\item Read in particle data from a file (line 103). \label{proc:input}
%\item Calculate the gravitational forces of all the particles at the
%  initial time (lines 104 to 106). \label{proc:calcinteraction}
%\item Integrate the orbits of all the particles with Leap-Frog method
%  (lines 107 to 114). \label{proc:integration}
%\item Finish the use of  FDPS (line 115). \label{proc:fin}
%\end{enumerate}

%In the following, we describe
%steps~\ref{proc:init}, \ref{proc:construct}, \ref{proc:input}, \ref{proc:calcinteraction},
%and \ref{proc:fin}, and skip steps~\ref{proc:literal}
%and \ref{proc:integration}.  In step~\ref{proc:literal}, we do not
%call FDPS libraries.  Although we call FDPS libraries in
%step~\ref{proc:integration}, the usage is the same as in
%step~\ref{proc:calcinteraction}.

%In step~\ref{proc:init}, the FDPS function \texttt{Initialize} is
%called. In this function, MPI and OpenMP libraries are
%initialized. If neither of them are used, this function does nothing.
%All functions of FDPS must be called between this function and the
%function \texttt{Finalize}.

%In step~\ref{proc:construct}, we create and initialize three objects
%of the FDPS classes:
%\begin{itemize}
%\item \texttt{dinfo}: An object of class \texttt{DomainInfo}. It is
%  used for domain decomposition.
%\item \texttt{ptcl}: An object of class template \texttt{ParticleSystem}.
%It takes the user-defined particle class (in this
%example, \texttt{Nbody}) as the template argument. From the user
%program, this object looks as an array of $i$-particles.
%\item \texttt{grav}: An object of a data type \texttt{Monopole} defined in
%a class template \texttt{TreeForForceLong}. This object is used for
%the calculation of long-range interaction using the tree algorithm.
%It receives three user-defined classes template arguments: the class
%to store the calculated interaction, the class for $i$-particles and
%the class for $j$-particles. In this example, all three are the same
%as the original class of particles.  It is possible to define classes
%with minimal data for these purposes and use them here, in order to
%optimize the cache usage. The data type \texttt{Monopole} indicates
%that the center-of-mass approximation is used for superparticles.
%\end{itemize}

%In step~\ref{proc:input}, the data of particles are read from a file
%into the object \texttt{ptcl}, using the FDPS
%function \texttt{readParticleAscii}. In the function, a member
%function of class \texttt{Nbody}, \texttt{readAscii}, is called.

%In step~\ref{proc:calcinteraction}, the forces on all particles are
%calculated through the function \texttt{calcGravAllAndWriteBack},
%which is defined in lines 79 to 89. In this function,
%steps~\ref{proc:decompose}, \ref{proc:exchange},
%and \ref{proc:interaction} in section~\ref{sec:view} are
%performed. In other words, all of the actual work of FDPS libraries
%to calculate interaction between particles takes place here. For
%step~\ref{proc:decompose}, \texttt{decomposeDomainAll}, a member
%function of class \texttt{DomainInfo} is called. This function takes
%the object \texttt{ptcl} as an argument to use the positions of
%particles to determine the domain decomposition.
%Step~\ref{proc:exchange} was performed in \texttt{exchangeParticle},
%a member function of class \texttt{ParticleSystem}. This function
%takes the object \texttt{dinfo} as an argument and redistributes
%particles among MPI processes.  Step~\ref{proc:interaction} was
%performed in \texttt{calcForceAllAndWriteBack}, a member function of
%class \texttt{TreeForForceLong}. This function takes the user-defined
%function object \texttt{CalcGrav} as the first and second arguments,
%and calculates particle-particle and particle-superparticle
%interactions using them.

%In step~\ref{proc:fin}, the FDPS function \texttt{Finalize} is
%called. It calls the \texttt{MPI\_finalize} function.

%In this section, we have described in detail how a user program
%written using FDPS looks like. As we stated earlier, this program can
%be compiled with or without parallelization using MPI and/or OpenMP,
%without any change in the user program. The executable parallelized
%with MPI is generated by using an appropriate compiler with MPI
%support and a compile-time flag.  Thus, a user need not worry about
%complicated bookkeeping necessary for parallelization using MPI. In
%the next section, we describe how FDPS provides a generic framework
%which takes care of parallelization and bookkeeping for
%particle-based simulations.
