

通信関係の全APIの名称の一覧を以下に示す:
\begin{screen}
\begin{spverbatim}
(fdps_)(ci_)get_rank
(fdps_)(ci_)get_rank_multi_dim
(fdps_)(ci_)get_num_procs
(fdps_)(ci_)get_num_procs_multi_dim
(fdps_)(ci_)get_logical_and
(fdps_)(ci_)get_logical_or
(ci_)get_min_value (Fortran のみ)
fdps_(ci_)get_min_value_s32 (C言語のみ)
fdps_(ci_)get_min_value_s64 (C言語のみ)
fdps_(ci_)get_min_value_u32 (C言語のみ)
fdps_(ci_)get_min_value_u64 (C言語のみ)
fdps_(ci_)get_min_value_f32 (C言語のみ)
fdps_(ci_)get_min_value_f64 (C言語のみ)
fdps_(ci_)get_min_value_w_id_f32 (C言語のみ)
fdps_(ci_)get_min_value_w_id_f64 (C言語のみ)
(ci_)get_max_value (Fortran のみ)
fdps_(ci_)get_max_value_s32 (C言語のみ)
fdps_(ci_)get_max_value_s64 (C言語のみ)
fdps_(ci_)get_max_value_u32 (C言語のみ)
fdps_(ci_)get_max_value_u64 (C言語のみ)
fdps_(ci_)get_max_value_f32 (C言語のみ)
fdps_(ci_)get_max_value_f64 (C言語のみ)
fdps_(ci_)get_max_value_w_id_f32 (C言語のみ)
fdps_(ci_)get_max_value_w_id_f64 (C言語のみ)
\end{spverbatim}
\end{screen}

\begin{screen}
\begin{spverbatim}
(ci_)get_sum (Fortran のみ)
fdps_(ci_)get_sum_s32 (C言語のみ)
fdps_(ci_)get_sum_s64 (C言語のみ)
fdps_(ci_)get_sum_u32 (C言語のみ)
fdps_(ci_)get_sum_u64 (C言語のみ)
fdps_(ci_)get_sum_f32 (C言語のみ)
fdps_(ci_)get_sum_f64 (C言語のみ)
(ci_)broadcast (Fortran のみ)
fdps_(ci_)broadcast_s32 (C言語のみ)
fdps_(ci_)broadcast_s64 (C言語のみ)
fdps_(ci_)broadcast_u32 (C言語のみ)
fdps_(ci_)broadcast_u64 (C言語のみ)
fdps_(ci_)broadcast_f32 (C言語のみ)
fdps_(ci_)broadcast_f64 (C言語のみ)
(fdps_)(ci_)get_wtime
(fdps_)(ci_)barrier
\end{spverbatim}
\end{screen}

以下、順に各APIの仕様を記述していく。ただし、API名が次の正規表現パターンにマッチするものは単一の節でまとめて説明を行う：\texttt{*get\_min\_value*}、\texttt{*get\_max\_value*}、\texttt{*get\_sum*}、\texttt{*broadcast*}。

関数名に {\tt ci\_} があるものは、MPI コミュニケータに対応するインデッ
クスを引数にとることができる。この記述は煩雑になるため
{\tt (fdps\_)ci\_get\_rank} についてのみ示す。



\clearpage

%=============================================================
\subsection{get\_rank}
\subsubsection*{Fortran 構文}
\begin{screen}
\begin{spverbatim}
integer(kind=c_int) fdps_ctrl%get_rank()
\end{spverbatim}
\end{screen}

\subsection*{C言語 構文}
\begin{screen}
\begin{spverbatim}
int fdps_get_rank();
\end{spverbatim}
\end{screen}

\subsection*{仮引数仕様}
なし。

\subsection*{返り値}
integer(kind=c\_int) 型。全プロセス中でのランクを返す。

\subsection*{機能}
全プロセス中でのランクを返す。
\clearpage

%=============================================================
\subsection{ci\_get\_rank}
\subsection*{Fortran 構文}
\begin{screen}
\begin{spverbatim}
integer(kind=c_int) fdps_ctrl%ci_get_rank(ci)
\end{spverbatim}
\end{screen}

\subsection*{C言語 構文}
\begin{screen}
\begin{spverbatim}
int fdps_ci_get_rank(int ci);
\end{spverbatim}
\end{screen}

\subsection*{仮引数仕様}
\begin{table}[h]
\begin{tabularx}{\linewidth}{cXcX}
\toprule
\rowcolor{Snow2}
仮引数名 & データ型 & 入出力属性 & 定義 \\
\midrule
\verb|ci| & integer(kind=c\_int) & 入力 & コミュニケータ番号。\\
\bottomrule
\end{tabularx}
\end{table}


\subsection*{返り値}
integer(kind=c\_int) 型。コミュニケータ中でのランクを返す。

\subsection*{機能}
コミュニケータ中でのランクを返す。
\clearpage

%=============================================================
\subsection{get\_rank\_multi\_dim}
\subsection*{Fortran 構文}
\begin{screen}
\begin{spverbatim}  
integer(kind=c_int) fdps_ctrl%get_rank_multi_dim(id)
\end{spverbatim}
\end{screen}

\subsection*{C言語 構文}
\begin{screen}
\begin{spverbatim}  
int fdps_get_rank_multi_dim(const int id);
\end{spverbatim}
\end{screen}

\subsection*{仮引数仕様}
\begin{table}[h]
\begin{tabularx}{\linewidth}{cXcX}
\toprule
\rowcolor{Snow2}
仮引数名 & データ型 & 入出力属性 & 定義 \\
\midrule
\verb|id| & integer(kind=c\_int) & 入力 & 軸の番号。x軸:0, y軸:1, z軸:2。\\
\bottomrule
\end{tabularx}
\end{table}

\subsection*{返り値}
integer(kind=c\_int) 型。id番目の軸でのランクを返す。2次元の場合、id=2
は1を返す。

\subsection*{機能}
id番目の軸でのランクを返す。2次元の場合、id=2は1を返す。
\clearpage

%=============================================================
\subsection{get\_num\_procs}
\subsection*{Fortran 構文}
\begin{screen}
\begin{spverbatim}
integer(kind=c_int) fdps_ctrl%get_num_procs()
\end{spverbatim}
\end{screen}

\subsection*{C言語 構文}
\begin{screen}
\begin{spverbatim}
int fdps_get_num_procs();
\end{spverbatim}
\end{screen}

\subsection*{仮引数仕様}
なし。

\subsection*{返り値}
integer(kind=c\_int) 型。全プロセス数を返す。

\subsection*{機能}
全プロセス数を返す。
\clearpage

%=============================================================
\subsection{get\_num\_procs\_multi\_dim}
\subsection*{Fortran 構文}
\begin{screen}
\begin{spverbatim}
integer(kind=c_int) fdps_ctrl%get_num_procs_multi_dim(id)
\end{spverbatim}
\end{screen}

\subsection*{C言語 構文}
\begin{screen}
\begin{spverbatim}
int fdps_get_num_procs_multi_dim(const int id);
\end{spverbatim}
\end{screen}

\subsection*{仮引数仕様}
\begin{table}[h]
\begin{tabularx}{\linewidth}{cXcX}
\toprule
\rowcolor{Snow2}
仮引数名 & データ型 & 入出力属性 & 定義 \\
\midrule
\verb|id| & integer(kind=c\_int) & 入力 & 軸の番号。x軸:0, y軸:1, z軸:2。\\
\bottomrule
\end{tabularx}
\end{table}

\subsection*{返り値}
integer(kind=c\_int) 型。id番目の軸のプロセス数を返す。2次元の場合、id=2は1を返す。

\subsection*{機能}
id番目の軸のプロセス数を返す。2次元の場合、id=2は1を返す。
\clearpage

%=============================================================
\subsection{get\_logical\_and}
\subsection*{Fortran 構文}
\begin{screen}
\begin{spverbatim}
subroutine fdps_ctrl%get_logical_and(f_in, &
                                     f_out)
\end{spverbatim}
\end{screen}

\subsection*{C言語構文}
\begin{screen}
\begin{spverbatim}
_Bool fdps_get_logical_and(const _Bool in);
\end{spverbatim}
\end{screen}

\subsection*{仮引数仕様}
\begin{table}[h]
\begin{tabularx}{\linewidth}{cccX}
\toprule
\rowcolor{Snow2}
仮引数名 & データ型 & 入出力属性 & 定義 \\
\midrule
\verb|f_in| & logical(kind=c\_bool) & 入力 & 入力の論理値\\
\verb|f_out| & logical(kind=c\_bool) & 入出力 & 出力の論理値\\
\verb|in| & const \_Bool & 入力 & 入力の論理値\\
\bottomrule
\end{tabularx}
\end{table}

\subsection*{返り値}
Fortranの場合はなし。C言語の場合は \_Bool型。

\subsection*{機能}
Fortranの場合、全プロセスでの \texttt{f\_in} の論理積をとり \texttt{f\_out} にいれる。C言語の場合、全プロセスでの \texttt{in} の論理積をとり、その結果を返す。
\clearpage

%=============================================================
\subsection{get\_logical\_or}
\subsection*{Fortran 構文}
\begin{screen}
\begin{spverbatim}
subroutine fdps_ctrl%get_logical_or(f_in, &
                                     f_out)
\end{spverbatim}
\end{screen}

\subsection*{C言語 構文}
\begin{screen}
\begin{spverbatim}
_Bool fdps_get_logical_or(const _Bool in);
\end{spverbatim}
\end{screen}

\subsection*{仮引数仕様}
\begin{table}[h]
\begin{tabularx}{\linewidth}{cccX}
\toprule
\rowcolor{Snow2}
仮引数名 & データ型 & 入出力属性 & 定義 \\
\midrule
\verb|f_in| & logical(kind=c\_bool) & 入力 & 入力の論理値\\
\verb|f_out| & logical(kind=c\_bool) & 入出力 & 出力の論理値\\
\verb|in| & const \_Bool & 入力 & 入力の論理値\\
\bottomrule
\end{tabularx}
\end{table}

\subsection*{返り値}
Fortranの場合はなし。C言語の場合は\_Bool型。

\subsection*{機能}
Fortranの場合、全プロセスでの \texttt{f\_in} の論理和をとり \texttt{f\_out} にいれる。C言語の場合、全プロセスでの \texttt{in} の論理和をとり、その結果を返す。

\clearpage

%=============================================================
\subsection{get\_min\_value}
\subsection*{Fortran 構文 (1)}
\begin{screen}
\begin{spverbatim}
subroutine fdps_ctrl%get_min_value(f_in, &
                                   f_out)
\end{spverbatim}
\end{screen}

\subsection*{C言語 構文 (1)}
\begin{screen}
\begin{spverbatim}
fdps_s32 fdps_get_min_value_s32(const fdps_s32 f_in);
fdps_s64 fdps_get_min_value_s64(const fdps_s64 f_in);
fdps_u32 fdps_get_min_value_u32(const fdps_u32 f_in);
fdps_u64 fdps_get_min_value_u64(const fdps_u64 f_in);
fdps_f32 fdps_get_min_value_f32(const fdps_f32 f_in);
fdps_f64 fdps_get_min_value_f64(const fdps_f64 f_in);
\end{spverbatim}
\end{screen}

\subsection*{仮引数仕様}
\begin{table}[h]
\begin{tabularx}{\linewidth}{clcX}
\toprule
\rowcolor{Snow2}
仮引数名 & データ型 & 入出力属性 & 定義 \\
\midrule
\verb|f_in|  & Fortranの場合、以下のいずれか: & 入力 & 入力値\\
             & integer(kind=c\_int) &&\\
             & integer(kind=c\_long\_long) &&\\
             & real(kind=c\_float) && \\
             & real(kind=c\_double) && \\
             & C言語の場合、以下のいずれか: &&\\
             & fdps\_s32, fdps\_s64 && \\
             & fdps\_u32, fdps\_u64 && \\
             & fdps\_f32, fdps\_f64 && \\
\verb|f_out| & 入力と同じ &入出力  & 出力値\\
\bottomrule
\end{tabularx}
\end{table}

\subsection*{返り値}
Fortranの場合はなし。C言語の場合は入力値と同じデータ型。

\subsection*{機能}
Fortranの場合、全プロセスで {\tt f\_in}の最小値を取り、結果を\texttt{f\_out}に代入する。C言語の場合、全プロセスで\texttt{f\_in}の最小値を取り、その結果を返す。
\clearpage

最小値の他、最小値に対応したインデックスも返すAPI もある。これは以下の
ようになる。

\subsection*{Fortran 構文 (2)}
\begin{screen}
\begin{spverbatim}
subroutine fdps_ctrl%get_min_value(f_in, &
                                   i_in, &  
                                   f_out,&
                                   i_out)
\end{spverbatim}
\end{screen}

\subsection*{C言語 構文 (2)}
\begin{screen}
\begin{spverbatim}
void fdps_get_min_value_w_id_f32(const fdps_f32 f_in,
                                 const int i_in,
                                 fdps_f32 *f_out,
                                 int *i_out);
void fdps_get_min_value_w_id_f64(const fdps_f64 f_in,
                                 const int i_in,
                                 fdps_f64 *f_out,
                                 int *i_out);
\end{spverbatim}
\end{screen}


\subsection*{仮引数仕様}
\begin{table}[h]
\begin{tabularx}{\linewidth}{cccX}
\toprule
\rowcolor{Snow2}
仮引数名 & データ型 & 入出力属性 & 定義 \\
\midrule
\verb|f_in| &real(kind=c\_float)  & 入力 & 入力値\\
 & real(kind=c\_double)&&\\
\verb|i_in| &integer(kind=c\_int)  & 入力 & 入力値に対応するインデックス\\
\verb|f_out| & \verb|f_in|と同じ&入出力  & 出力値\\
\verb|i_out| &integer(kind=c\_int)  & 入出力 & 出力値に対応するインデックス\\
\bottomrule
\end{tabularx}
\end{table}

\subsection*{返り値}
なし。

\subsection*{機能}
全プロセスで {\tt f\_in}の最小値を取り、結果を{\tt f\_out}に格納する。
さらに、その値に対応する{\tt i\_in} の値を{\tt i\_out}に格納する。
\clearpage
  
%=============================================================
\subsection{get\_max\_value}
\subsection*{Fortra 構文 (1)}
\begin{screen}
\begin{spverbatim}
subroutine fdps_ctrl%get_max_value(f_in, &
                                   f_out)
\end{spverbatim}
\end{screen}

\subsection*{C言語 構文 (1)}
\begin{screen}
\begin{spverbatim}
fdps_s32 fdps_get_max_value_s32(const fdps_s32 f_in);
fdps_s64 fdps_get_max_value_s64(const fdps_s64 f_in);
fdps_u32 fdps_get_max_value_u32(const fdps_u32 f_in);
fdps_u64 fdps_get_max_value_u64(const fdps_u64 f_in);
fdps_f32 fdps_get_max_value_f32(const fdps_f32 f_in);
fdps_f64 fdps_get_max_value_f64(const fdps_f64 f_in);
\end{spverbatim}
\end{screen}

\subsection*{仮引数仕様}
\begin{table}[h]
\begin{tabularx}{\linewidth}{clcX}
\toprule
\rowcolor{Snow2}
仮引数名 & データ型 & 入出力属性 & 定義 \\
\midrule
\verb|f_in| & Fortranの場合、以下のいずれか: & 入力 & 入力値\\
            & integer(kind=c\_int) &&\\
            & integer(kind=c\_long\_long)&&\\
            & real(kind=c\_float)&&\\
            & real(kind=c\_double)&&\\
            & C言語の場合、以下のいずれか: &&\\
            & fdps\_s32, fdps\_s64 &&\\
            & fdps\_u32, fdps\_u64 &&\\
            & fdps\_f32, fdps\_f64 &&\\
 \verb|f_out| & 入力と同じ &入出力  & 出力値\\
\bottomrule
\end{tabularx}
\end{table}

\subsection*{返り値}
Fortranの場合はなし。C言語の場合は入力値と同じデータ型。

\subsection*{機能}
全プロセスで {\tt f\_in}の最大値を取り、結果を返す。
\clearpage


最大値の他、最大値に対応したインデックスも返すAPI もある。これは以下の
ようになる。
\subsection*{Fortran 構文 (2)}
\begin{screen}
\begin{spverbatim}
subroutine fdps_ctrl%get_max_value(f_in, &
                                   i_in, &  
                                   f_out,&
                                   i_out)
\end{spverbatim}
\end{screen}

\subsection*{C言語 構文 (2)}
\begin{screen}
\begin{spverbatim}
void fdps_get_max_value_w_id_f32(const fdps_f32 f_in,
                                 const int i_in,
                                 fdps_f32 *f_out,
                                 int *i_out);
void fdps_get_max_value_w_id_f64(const fdps_f64 f_in,
                                 const int i_in,
                                 fdps_f64 *f_out,
                                 int *i_out);
\end{spverbatim}
\end{screen}

\subsection*{仮引数仕様}
\begin{table}[h]
\begin{tabularx}{\linewidth}{cccX}
\toprule
\rowcolor{Snow2}
仮引数名 & データ型 & 入出力属性 & 定義 \\
\midrule
\verb|f_in| &real(kind=c\_float)  & 入力 & 入力値\\
 & real(kind=c\_double)&&\\
\verb|i_in| &integer(kind=c\_int)  & 入力 & 入力値に対応するインデックス\\
\verb|f_out| & \verb|f_in|と同じ&入出力  & 出力値\\
\verb|i_out| &integer(kind=c\_int)  & 入出力 & 出力値に対応するインデックス\\
\bottomrule
\end{tabularx}
\end{table}

\subsection*{返り値}
Fortranの場合はなし。C言語の場合は入力値と同じデータ型。

\subsection*{機能}
全プロセスで {\tt f\_in}の最大値を取り、結果を{\tt f\_out}に格納する。
さらに、その値に対応する{\tt i\_in} の値を{\tt i\_out}に格納する。
\clearpage

%=============================================================
\subsection{get\_sum}
\subsection*{Fortran 構文}
\begin{screen}
\begin{spverbatim}
subroutine fdps_ctrl%get_sum(f_in, &
                             f_out)
\end{spverbatim}
\end{screen}

\subsection*{C言語 構文}
\begin{screen}
\begin{spverbatim}
fdps_s32 fdps_get_sum_s32(const fdps_s32 f_in);
fdps_s64 fdps_get_sum_s64(const fdps_s64 f_in);
fdps_u32 fdps_get_sum_u32(const fdps_u32 f_in);
fdps_u64 fdps_get_sum_u64(const fdps_u64 f_in);
fdps_f32 fdps_get_sum_f32(const fdps_f32 f_in);
fdps_f64 fdps_get_sum_f64(const fdps_f64 f_in);
\end{spverbatim}
\end{screen}

\subsection*{仮引数仕様}
\begin{table}[h]
\begin{tabularx}{\linewidth}{clcX}
\toprule
\rowcolor{Snow2}
仮引数名 & データ型 & 入出力属性 & 定義 \\
\midrule
\verb|f_in| & Fortranの場合、以下のいずれか: & 入力 & 入力値\\
            & integer(kind=c\_int) &&\\
            & integer(kind=c\_long\_long) &&\\
            & real(kind=c\_float) &&\\
            & real(kind=c\_double) &&\\
            & C言語の場合、以下のいずれか: &&\\
            & fdps\_s32, fdps\_s64 && \\
            & fdps\_u32, fdps\_u64 && \\
            & fdps\_f32, fdps\_f64 && \\
\verb|f_out| & 入力と同じ &入出力  & 出力値\\
\bottomrule
\end{tabularx}
\end{table}

\subsection*{返り値}
Fortranの場合はなし。C言語の場合は入力値と同じデータ型。

\subsection*{機能}
全プロセスで {\tt f\_in}の総和を取り、結果を返す。
\clearpage

%=============================================================
\subsection{broadcast}
\subsection*{Fortran 構文}
\begin{screen}
\begin{spverbatim}
subroutine fdps_ctrl%broadcast(val, &
                               n,   &
                               src)
\end{spverbatim}
\end{screen}

\subsection*{C言語 構文}
\begin{screen}
\begin{spverbatim}
void fdps_broadcast_s32(fdps_s32 *val, int n, int src);
void fdps_broadcast_s64(fdps_s64 *val, int n, int src);
void fdps_broadcast_u32(fdps_u32 *val, int n, int src);
void fdps_broadcast_u64(fdps_u64 *val, int n, int src);
void fdps_broadcast_f32(fdps_f32 *val, int n, int src);
void fdps_broadcast_f64(fdps_f64 *val, int n, int src);
\end{spverbatim}
\end{screen}

\subsection*{仮引数仕様}
\begin{table}[h]
\begin{tabularx}{\linewidth}{cp{5cm}cX}
\toprule
\rowcolor{Snow2}
仮引数名 & データ型 & 入出力属性 & 定義 \\
\midrule
\verb|val| & Fortranの場合、以下のいずれかの型の変数または配列: & 入出力 & 入力値。{\setnoko\uc{C言語では引数に変数のアドレスを指定する必要があることに注意}}。\\
           & integer(kind=c\_int) &&\\
           & integer(kind=c\_long\_long) &&\\
           & real(kind=c\_float) &&\\
           & real(kind=c\_double) &&\\
           & C言語の場合、以下のいずれかの型の変数または配列 &&\\
           & fdps\_s32, fdps\_s64 &&\\
           & fdps\_u32, fdps\_u64 &&\\
           & fdps\_f32, fdps\_f64 &&\\
 \verb|n| & integer(kind=c\_int) &入力  & 入力値の数。スカラー変数の場合には1を、配列の場合には配列サイズを指定する。 \\
 \verb|src| & integer(kind=c\_int) &入力  & 放送するプロセスのランク番号 \\
\bottomrule
\end{tabularx}
\end{table}

\subsection*{返り値}
なし。

\subsection*{機能}
ランク番号{\tt src} のプロセスが{\tt n}個の{\tt val}で指定されるn個
の変数を全プロセスに放送する。結果は {\tt val}に格納される。
\clearpage

%=============================================================
\subsection{get\_wtime}
\subsection*{Fortran 構文}
\begin{screen}
\begin{spverbatim}
real(kind=c_double) fdps_ctrl%get_wtime()
\end{spverbatim}
\end{screen}

\subsection*{C言語 構文}
\begin{screen}
\begin{spverbatim}
double fdps_get_wtime();
\end{spverbatim}
\end{screen}

\subsection*{仮引数仕様}
なし。

\subsection*{返り値}
real(kind=c\_double) 型。ウォールクロックタイムを返す。単位は秒。

\subsection*{機能}
ウォールクロックタイムを返す。単位は秒。
\clearpage

%=============================================================
\subsection{barrier}
\subsection*{Fortran 構文}
\begin{screen}
\begin{spverbatim}
subroutine fdps_ctrl%barrier()
\end{spverbatim}
\end{screen}

\subsection*{C言語 構文}
\begin{screen}
\begin{spverbatim}
void fdps_barrier();
\end{spverbatim}
\end{screen}

\subsection*{仮引数仕様}
なし。

\subsection*{返り値}
なし。

\subsection*{機能}
プロセス間の同期を取る。
