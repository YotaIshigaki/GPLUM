In this section, we describe the specifications of APIs to use the extended feature ``Particle Mesh". In FDPS, all data required to perform particle mesh calculation are stored in ParticleMesh object (hereafter, we call it \textbf{PM object} for simplicity). Similar to other FDPS objects, this object is managed by an identification number in FDPS Fortran/C interface.

This is the list of APIs to manipulate PM object:
\begin{screen}
\begin{spverbatim}
(fdps_)create_pm
(fdps_)delete_pm
(fdps_)get_pm_mesh_num
(fdps_)get_pm_cutoff_radius
(fdps_)set_dinfo_of_pm
(fdps_)set_psys_of_pm
(fdps_)get_pm_force
(fdps_)get_pm_potential
(fdps_)calc_pm_force_only
(fdps_)calc_pm_force_all_and_write_back
\end{spverbatim}  
\end{screen}

In the following, we describe the specification of each API in the order above.
\clearpage


%=============================================================
% API名::create_pm()
\subsection{create\_pm}
\subsubsection*{Fortran syntax}
\begin{screen}
\begin{spverbatim}
subroutine fdps_ctrl%create_pm(pm_num)
\end{spverbatim}
\end{screen}

\subsubsection*{C syntax}
\begin{screen}
\begin{spverbatim}
void fdps_create_pm(int *pm_num);
\end{spverbatim}
\end{screen}

\subsubsection*{Dummy argument specification}
\begin{table}[h]
\begin{tabularx}{\linewidth}{cccX}
\toprule
\rowcolor{Snow2}
Name & Data type & I/O Characteristics & Definition \\
\midrule
\texttt{pm\_num} & integer(kind=c\_int) & Input and Output & Variable to receive the identification number of a PM object. {\setnoko\Euc{Note that users need to pass the address of the variable in C}}. \\
\bottomrule
\end{tabularx}
\end{table}

\subsubsection*{Returned value}
None.

\subsubsection*{Function}
Create an PM object and return its identification number.

\clearpage

%=============================================================
% API名::delete_pm()
\subsection{delete\_pm}
\subsubsection*{Fortran syntax}
\begin{screen}
\begin{spverbatim}
subroutine fdps_ctrl%delete_pm(pm_num)
\end{spverbatim}
\end{screen}

\subsubsection*{C syntax}
\begin{screen}
\begin{spverbatim}
void fdps_delete_pm(const int pm_num);
\end{spverbatim}
\end{screen}

\subsubsection*{Dummy argument specification}
\begin{table}[h]
\begin{tabularx}{\linewidth}{cccX}
\toprule
\rowcolor{Snow2}
Name & Data type & I/O Characteristics & Definition \\
\midrule
\texttt{pm\_num} & integer(kind=c\_int) & Input & Variable giving the  identification number of a PM object. \\
\bottomrule
\end{tabularx}
\end{table}

\subsubsection*{Returned value}
None.

\subsubsection*{Function}
Delete a PM object indicated by the identification number.
\clearpage

%=============================================================
% API名::get_pm_mesh_num()
\subsection{get\_pm\_mesh\_num}
\subsubsection*{Fortran syntax}
\begin{screen}
\begin{spverbatim}
integer(kind=c_int) fdps_ctrl%get_pm_mesh_num()
\end{spverbatim}
\end{screen}

\subsubsection*{C syntax}
\begin{screen}
\begin{spverbatim}
int fdps_get_pm_mesh_num();
\end{spverbatim}
\end{screen}

\subsubsection*{Dummy argument specification}
None.

\subsubsection*{Returned value}
The number of the mesh per spatial dimension.
Type integer(kind=c\_int). 

\subsubsection*{Function}
Return the number of the mesh per spatial dimension used in the particle mesh calculation.
\clearpage

%=============================================================
% API名::get_pm_cutoff_radius()
\subsection{get\_pm\_cutoff\_radius}
\subsubsection*{Fortran syntax}
\begin{screen}
\begin{spverbatim}
real(kind=c_double) fdps_ctrl%get_pm_cutoff_radius()
\end{spverbatim}
\end{screen}

\subsubsection*{C syntax}
\begin{screen}
\begin{spverbatim}
double fdps_get_pm_cutoff_radius();
\end{spverbatim}
\end{screen}

\subsubsection*{Dummy argument specification}
None.

\subsubsection*{Returned value}
The size of cutoff radius used in the particle mesh calculation. Note that the cutoff radius is normalized by the size of the mesh interval. Type real(kind=c\_double).

\subsubsection*{Function}
Return the size of cutoff radius used in the particle mesh calculation.
\clearpage

%=============================================================
% API名::set_dinfo_of_pm()
\subsection{set\_dinfo\_of\_pm}
\subsubsection*{Fortran syntax}
\begin{screen}
\begin{spverbatim}
subroutine fdps_ctrl%set_dinfo_of_pm(pm_num,dinfo_num)
\end{spverbatim}
\end{screen}

\subsubsection*{C syntax}
\begin{screen}
\begin{spverbatim}
void fdps_set_dinfo_of_pm(const int pm_num,
                          const int dinfo_num);
\end{spverbatim}
\end{screen}

\subsubsection*{Dummy argument specification}
\begin{table}[h]
\begin{tabularx}{\linewidth}{cccX}
\toprule
\rowcolor{Snow2}
Name & Data type & I/O Characteristics & Definition \\
\midrule
\texttt{pm\_num} & integer(kind=c\_int) & Input & Variable giving the identification number of a PM object.\\
\texttt{dinfo\_num} & integer(kind=c\_int) & Input & Variable giving the identification number of a DomainInfo object that is related to a ParticleSystem object for which the particle mesh calculation is performed.\\
\bottomrule
\end{tabularx}
\end{table}


\subsubsection*{Returned value}
None.

\subsubsection*{Function}
Set the identification number of a DomainInfo object stored in the PM object indicated by the identification number \texttt{pm\_num}. FDPS uses this DomainInfo object to get the information on domain decomposition. Therefore, it should be the one that is related to a ParticleSystem object for which the particle mesh calculation is performed.
\clearpage

%=============================================================
% API名::set_psys_of_pm()
\subsection{set\_psys\_of\_pm}
\subsubsection*{Fortran syntax}
\begin{screen}
\begin{spverbatim}
subroutine fdps_ctrl%set_psys_of_pm(pm_num,psys_num,clear)
\end{spverbatim}
\end{screen}

\subsubsection*{C syntax}
\begin{screen}
\begin{spverbatim}
void fdps_set_psys_of_pm(const int pm_num,
                         const int psys_num,
                         const _Bool clear);
\end{spverbatim}
\end{screen}


\subsubsection*{Dummy argument specification}
\begin{table}[h]
\begin{tabularx}{\linewidth}{cccX}
\toprule
\rowcolor{Snow2}
Name & Data type & I/O Characteristics & Definition \\
\midrule
\texttt{pm\_num} & integer(kind=c\_int) & Input & Variable giving the identification number of a PM object.\\
\texttt{psys\_num} & integer(kind=c\_int) & Input & Variable giving the identification number of a ParticleSystem object for which the particle mesh calculation is performed.\\
\texttt{clear} & logical(kind=c\_bool) & Input & A flag to determine if the previous information of particles loaded is cleared. If it is \texttt{.true.} {\small (in Fortran)}/\texttt{true} {\small (in C)}, the API performs clear. In Fortran, this argument is optional and \texttt{.true.} is used if the argument is not present.\\
\bottomrule
\end{tabularx}
\end{table}

\subsubsection*{Returned value}
None.

\subsubsection*{Function}
Set the identification number of a ParticleSystem object stored in the PM object indicated by the identification number \texttt{pm\_num}. FDPS performs particle mesh calculation using this ParticleSystem object.
\clearpage

%=============================================================
% API名::get_pm_force()
\subsection{get\_pm\_force}
\subsubsection*{Fortran syntax}
\begin{screen}
\begin{spverbatim}
subroutine fdps_ctrl%get_pm_force(pm_num,pos,f)
\end{spverbatim}
\end{screen}

\subsubsection*{C syntax}
\begin{screen}
\begin{spverbatim}
void fdps_get_pm_force(const int pm_num,
                       const fdps_f32vec *pos,
                       fdps_f32vec *force);
\end{spverbatim}
\end{screen}


\subsubsection*{Dummy argument specification}
\begin{table}[h]
\begin{tabularx}{\linewidth}{cp{5cm}cX}
\toprule
\rowcolor{Snow2}
Name & Data type & I/O Characteristics & Definition \\
\midrule
\texttt{pm\_num} & integer(kind=c\_int) & Input & Variable giving the identification number of a PM object.\\
\texttt{pos} & In Fortran, one of the followings: & Input & \multirow[t]{6}{\hsize}{Array or vector giving the position used to evaluate the mesh force.} \\
& real(kind=c\_float),\newline\hspace{1em} dimension(space\_dim) &&\\
& real(kind=c\_double),\newline\hspace{1em} dimension(space\_dim) &&\\
& type(fdps\_f32vec) &&\\
& type(fdps\_f64vec) &&\\
& In C, \textbf{Only \texttt{fdps\_f32vec *}} &&\\
\texttt{f} & the same data type as \texttt{pos} & Input and Output & Variable to receive the mesh force at the position \texttt{pos}.\\
\texttt{force} & \texttt{fdps\_f32vec *} & Input and Output & Variable to receive the mesh force at the position \texttt{pos}.{\setnoko\Euc{Note that users need to pass the address of the variable in C}}.\\
\bottomrule
\end{tabularx}
\end{table}
If the macro \texttt{PARTICLE\_SIMULATOR\_TWO\_DIMENSION} is defined at the compilation, \texttt{space\_dim} is equal to 2. Otherwise, 3.

\subsubsection*{Returned value}
None.

\subsubsection*{Function}
Return the mesh force at the position \texttt{pos}. This function is thread-safe. Before calling this API, an user must perform particle mesh calculation at least once using APIs \texttt{(fdps\_)calc\_pm\_force\_only} or \texttt{(fdps\_)calc\_pm\_force\_all\_and\_write\_back} with the same PM object.
\clearpage

%=============================================================
% API名::get_pm_potential()
\subsection{get\_pm\_potential}
\subsubsection*{Fortran syntax}
\begin{screen}
\begin{spverbatim}
subroutine fdps_ctrl%get_pm_potential(pm_num,pos,pot)
\end{spverbatim}
\end{screen}

\subsubsection*{C syntax}
\begin{screen}
\begin{spverbatim}
void fdps_get_pm_potential(const int pm_num,
                           const fdps_f32vec *pos,
                           fdps_f32 *pot);
\end{spverbatim}
\end{screen}

\subsubsection*{Dummy argument specification}
\begin{table}[h]
\begin{tabularx}{\linewidth}{cp{6cm}cX}
\toprule
\rowcolor{Snow2}
Name & Data type & I/O Characteristics & Definition \\
\midrule
\texttt{pm\_num} & integer(kind=c\_int) & Input & Variable giving the identification number of a PM object.\\
\texttt{pos} & In Fortran, one of the followings: & Input & \multirow[t]{6}{\hsize}{Array or vector giving the position used to evaluate the mesh potential.} \\
& real(kind=c\_float), \newline\hspace{1em} dimension(space\_dim) &&\\
& real(kind=c\_double),\newline\hspace{1em} dimension(space\_dim) &&\\
& type(fdps\_f32vec) & & \\
& type(fdps\_f64vec) & & \\
& In C, \textbf{Only \texttt{fdps\_f32vec *}} &&\\
\texttt{pot} & In Fortran, real(kind=c\_float) & Input and Output & Variable to receive the mesh potential at the position \texttt{pos}.\\
& In C, \texttt{fdps\_f32 *} &&\\
\bottomrule
\end{tabularx}
\end{table}
If the macro \texttt{PARTICLE\_SIMULATOR\_TWO\_DIMENSION} is defined at the compilation, \texttt{space\_dim} is equal to 2. Otherwise, 3. {\setnoko\Euc{Note that the arguments \texttt{pos} and \texttt{pot} is addresses in C}}.

\subsubsection*{Returned value}
None.

\subsubsection*{Function}
Return the mesh potential at the position \texttt{pos}. This function is thread-safe. Before calling this API, an user must perform Particle Mesh calculation at least once using APIs \texttt{(fdps\_)calc\_pm\_force\_only} or \texttt{(fdps\_)calc\_pm\_force\_all\_and\_write\_back} with the same PM object.

\clearpage

%=============================================================
% API名::calc_pm_force_only()
\subsection{calc\_pm\_force\_only}
\subsubsection*{Fortran syntax}
\begin{screen}
\begin{spverbatim}
subroutine fdps_ctrl%calc_pm_force_only(pm_num)
\end{spverbatim}
\end{screen}

\subsubsection*{C syntax}
\begin{screen}
\begin{spverbatim}
void fdps_calc_pm_force_only(const int pm_num);
\end{spverbatim}
\end{screen}

\subsubsection*{Dummy argument specification}
\begin{table}[h]
\begin{tabularx}{\linewidth}{cccX}
\toprule
\rowcolor{Snow2}
Name & Data type & I/O Characteristics & Definition \\
\midrule
\texttt{pm\_num} & integer(kind=c\_int) & Input & Variable giving the identification number of a PM object.\\
\bottomrule
\end{tabularx}
\end{table}


\subsubsection*{Returned value}
None.

\subsubsection*{Function}
Perform a particle mesh calculation using the PM object indicated by the identification number \texttt{pm\_num}. In order for it to work properly, the identification numbers of ParticleSystem and DomainInfo objects must be set in advance.
\clearpage

%=============================================================
% API名::calc_pm_force_all_and_write_back()
\subsection{calc\_pm\_force\_all\_and\_write\_back}
\subsubsection*{Fortran syntax}
\begin{screen}
\begin{spverbatim}
subroutine fdps_ctrl%calc_pm_force_all_and_write_back(pm_num,   &
                                                      psys_num, &
                                                      dinfo_num)
\end{spverbatim}
\end{screen}

\subsubsection*{C syntax}
\begin{screen}
\begin{spverbatim}
void fdps_calc_pm_force_all_and_write_back(const int pm_num,
                                           const int psys_num,
                                           const int dinfo_num);
\end{spverbatim}
\end{screen}


\subsubsection*{Dummy argument specification}
\begin{table}[h]
\begin{tabularx}{\linewidth}{cccX}
\toprule
\rowcolor{Snow2}
Name & Data type & I/O Characteristics & Definition \\
\midrule
\texttt{pm\_num} & integer(kind=c\_int) & Input & Variable giving the identification number of a PM object.\\
\texttt{psys\_num} & integer(kind=c\_int) & Input & Variable giving the identification number of a ParticleSystem object that is used to particle mesh calculation.\\
\texttt{dinfo\_num} & integer(kind=c\_int) & Input & Variable giving the identification number of a DomainInfo object that is related to the ParticleSystem object above.\\
\bottomrule
\end{tabularx}
\end{table}

\subsubsection*{Returned value}
None.

\subsubsection*{Function}
Perform a Particle Mesh calculation using the PM, ParticleSystem, and DomainInfo objects indicated respectively by the arguments \texttt{pm\_num}, \texttt{psys\_num}, and \texttt{dinfo\_num}, and stores the calculated mesh forces to the ParticleSystem object. The calculated mesh force is stored into a member variable specified by FDPS directive with keyword \texttt{copyFromForcePM} of FullParticle type.
\clearpage

