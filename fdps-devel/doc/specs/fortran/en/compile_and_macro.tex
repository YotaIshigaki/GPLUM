In previous chapters, we have described the necessary information to write a simulation code using FDPS Fortran/C interface and to generate the Fortran or C interface programs. In this chapter, we cover topic related to the compilation of user's code together with the interface programs. As shown in Figs.~\ref{fig:FDPS_ftn_if_file_str} and \ref{fig:FDPS_c_if_file_str} in Chap.~\ref{chap:file_str_and_ftn_if_overview}, the interface programs consist of C++ source codes and Fortran or C source codes. The first half of this chapter describes how to compile the interface programs. Some of the features of FDPS such as the type of coordinate used in a simulation and the method of parallelization should be specified at the compile time. Therefore, the last half of this chapter explains about the macros that are available in FDPS Fortran/C interface. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Compilation}
In this section, we describe how to compile user's codes together with the interface programs. Firstly, we describe a general procedure that does not depend on compilers. Then, we explain the compilation method for the case of  GCC (The GNU Compiler Collection) as an example.
%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Basic procedure of the compilation}
\label{subsec:compile:basic_procedures}
Here, we explain basic procedure of the compilation independent of the type of compiler. At first, we describe the case of using Fortran interface. Then, we describe the case of using C interface.

%%%%%%%%%%%%%%
\subsubsection{In case of using Fortran interface}
In order to obtain an executable file from source codes described both in C++ and Fortran, we must prepare a C++ compiler, a C++ linker, and a Fortran compiler that are interoperable with each other. Today, most of C++ compilers work as a C++ linker. Hence, we only have to prepare a C++ compiler and a Fortran compiler that are interoperable with each other. Fortran compiler must support Fortran 2003 standard (ISO/IEC 1539-1:2004(E)). In addition, C++ compiler must support C++03 standard (ISO/IEC 14882:2003) to compile FDPS itself.

As described in Chap.~\ref{chap:file_str_and_ftn_if_overview}, the so-called \path{main} function exists in the C++ side of user's codes. Therefore, to get the executable file, we must use a C++ linker to link the object files that are created from the source codes by using the both compilers. More specifically, the compilation is performed as follows:
\begin{enumerate}[leftmargin=*,label={[\arabic*]}]
\litem{Compiling Fortran source codes} Compile all the user's Fortran source codes, \path{FDPS_module.F90} (one of the interface programs), all the Fortran source codes provided by us (\path{src/fortran_interface/modules/*.F90}) to create the Fortran object files. You can obtain the object files by compiling with the compilation option \path{-c} in most cases.

One thing you should be careful of is the order of the files passed to the Fortran compiler. In most of Fortran compilers, when the module \path{foo} is used in the file \path{bar.F90}, the file that defines the module \path{foo} must be compiled before compiling the file \path{bar.F90}. Because the compiler processes the files in the same order as the argument, we must first pass the files in which independent modules are defined and then we need to pass the remaining files according to their dependency relation. To be more precise, we have to compile as follows:
\begin{Verbatim}[commandchars=\\\{\}]
\$ FC -c \textbackslash
  FDPS_time_profile.F90 \textbackslash
  FDPS_vector.F90 \textbackslash
  FDPS_matrix.F90 \textbackslash
  FDPS_super_particle.F90 \textbackslash
  user_defined_1.F90 ... user_defined_n.F90 \textbackslash
  FDPS_module.F90 \textbackslash
  user_code_1.F90 ... user_code_n.F90
\end{Verbatim}
where \path{FC} is a Fortran compiler. The symbol ``\textbackslash" shows that the command-line is continued to the next line. This symbol is introduced due to space limitation and it is unnecessary in practice. Here, we assumed that the subroutine \path{f_main()} is implemented in one of the user's codes (\path{user_code_*.F90}). The dependency relationship of the files in this example is as follows:
\begin{itemize}[leftmargin=*]
\item \path{FDPS_super_particle.F90} depends on both \path{FDPS_vector.F90} and \path{FDPS_matrix.F90}.
\item \path{FDPS_module.F90} depends on the $n$ files \path{user_defined_}$i$\path{.F90} ($i=1$-$n$) where the user-defined types are defined.
\item the $n$ files \path{user_code_}$i$\path{.F90} ($i=1$-$n$) where the main part of the simulation code are implemented depend on \path{FDPS_module.F90}.
\end{itemize}
\label{enum:compile:ftn_sources}

\litem{Compiling C++ source codes} Compile all the C++ files in the interface programs (\path{main.cpp}, \path{FDPS_Manipulators.cpp}, \path{FDPS_ftn_if.cpp}) to create the C++ object files. Because of the existence of header files, you do not need to worry about the order of the files in the C++ case. Hence, we compile as follows:
\begin{Verbatim}[commandchars=\\\{\}]
\$ CXX -c FDPS_Manipulators.cpp FDPS_ftn_if.cpp main.cpp
\end{Verbatim}
where \path{CXX} is a C++ compiler.
\label{enum:compile:cpp_sources}

\litem{Linking the object files} Using a C++ linker (actually a C++ compiler), Link the object files (\path{*.o}) created in the steps \ref{enum:compile:ftn_sources} and \ref{enum:compile:cpp_sources} to obtain the executable file. Depending the type of compiler, the compiler may require a special compilation option to link C++ objects with Fortran objects. Assuming that this option is \verb|LDFLAGS|, the link is performed as follows:
\begin{Verbatim}[commandchars=\\\{\}]
\$ CXX *.o [LDFLAGS]
\end{Verbatim}
where the symbols [] shows that the inside of it can be omitted and they should not be described in practice. If succeed in linking, the executable file will be created.
\end{enumerate}

In the procedure described above, we have omitted other compilation options such as the option that specifies the language specification. Also, we have omitted the options specifying libraries needed for parallel computation or the extended feature ``ParticleMesh". The way of specifying these things depend on the types of both compiler and system that users use. Users must specify them at the compilation accordingly.

%%%%%%%%%%%%%%
\subsubsection{In case of using C interface}
In order to obtain an executable file from source codes described both in C++ and C, we must prepare a C++ compiler, a C++ linker, and a C compiler that are interoperable with each other. Owing to the same reason described in the previous section, we only have to prepare a C++ compiler and a C compiler that are interoperable with each other. C compiler must support C99 (ISO/IEC 9899:1999). In addition, C++ compiler must support C++03 standard (ISO/IEC 14882:2003) to compile FDPS itself.

As described in Chap.~\ref{chap:file_str_and_ftn_if_overview}, the so-called \path{main} function exists in the C++ side of user's codes. Therefore, to get the executable file, we must use a C++ linker to link the object files that are created from the source codes by using the both compilers. More specifically, the compilation is performed as follows:
\begin{enumerate}[leftmargin=*,label={[\arabic*]}]
\litem{Compiling C source codes} Compile all the user's C source codes to create the C object files. You can obtain the object files by compiling with the compilation option \path{-c} in most cases.
\begin{Verbatim}[commandchars=\\\{\}]
\$ CC -c user_code_1.c ... user_code_n.c
\end{Verbatim}
where \path{CC} is a C compiler.
\label{enum:compile:c_sources}

\litem{Compiling C++ source codes} Compile all the C++ files in the interface programs (\path{main.cpp}, \path{FDPS_Manipulators.cpp}, \path{FDPS_ftn_if.cpp}) to create the C++ object files as follows:
\begin{Verbatim}[commandchars=\\\{\}]
\$ CXX -c FDPS_Manipulators.cpp FDPS_ftn_if.cpp main.cpp
\end{Verbatim}
where \path{CXX} is a C++ compiler.
\label{enum:compile:cpp_sources_in_c_if}

\litem{Linking the object files} Using a C++ linker (actually a C++ compiler), Link the object files (\path{*.o}) created in the steps \ref{enum:compile:c_sources} and \ref{enum:compile:cpp_sources_in_c_if} to obtain the executable file. Assuming \verb|LDFLAGS| be some link options, the link is performed as follows:
\begin{Verbatim}[commandchars=\\\{\}]
\$ CXX *.o [LDFLAGS]
\end{Verbatim}
where the symbols [] shows that the inside of it can be omitted and they should not be described in practice. If succeed in linking, the executable file will be created.
\end{enumerate}

In the procedure described above, we have omitted other compilation options such as the option that specifies the language specification. Also, we have omitted the options specifying libraries needed for parallel computation or the extended feature ``ParticleMesh". The way of specifying these things depend on the types of both compiler and system that users use. Users must specify them at the compilation accordingly.


%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Compilation with GCC}
In this section, we describe how to compile user's codes with GCC (ver. 4.8.3 or later) as an example. Throughout this section, we assume the following things: (i) the C++, Fortran, C compilers are \path{g++}, \path{gfortran}, and \path{gcc}, respectively, (ii) the compilers that support MPI are \path{mpic++}, \path{mpif90}, and \path{mpicc} (iii) the MPI library used is \href{https://www.open-mpi.org}{OpenMPI} (ver. 1.6.4 or later). In the following, we explain separately the cases with and without the use of MPI.

%%%%%%%%%%%%%%%%
\subsubsection{In case of using Fortran interface}
%%%%%%%
\subsubsubsection{The case without MPI}
In GCC, we need the compilation option \path{-std=f2003} to compile Fortran source codes according to Fortran 2003 standard. Also, we need the link option \path{-lgfortran} to link C++ object files to Fortran object files. Therefore, set the variables \path{FC}, \path{CXX}, and \path{LDFLAGS} in the procedure described in \S~\ref{subsec:compile:basic_procedures} as follows:
\begin{screen}
\begin{verbatim}
FC      = gfortran -std=f2003
CXX     = g++
LDFLAGS = -lgfortran
\end{verbatim}  
\end{screen}

%%%%%%%
\subsubsubsection{The case with MPI}
When using MPI, attention should be paid if users use MPI in the user's codes. In this case, we need link the MPI library for Fortran in addition to that for C++. Assuming that the names of both libraries are \path{libmpi} and \path{libmpi_f90} respectively, the compilation will succeed if you set the variables \path{FC}, \path{CXX}, and \path{LDFLAGS} in the procedure described in \S~\ref{subsec:compile:basic_procedures} as follows:
\begin{screen}
\begin{Verbatim}[commandchars=\\\{\}]
FC      = mpif90 -std=f2003
CXX     = mpic++
LDFLAGS = -lgfortran -L\vrbit{PATH} -lmpi -lmpi_f90
\end{Verbatim}  
\end{screen}
where \textit{\texttt{PATH}} is the absolute PATH of the directory where the MPI libraries are installed.

%%%%%%%%%%%%%%%%
\subsubsection{In case of using C interface}
%%%%%%%
\subsubsubsection{The case without MPI}
Set the variables \path{CC}, \path{CXX}, and \path{LDFLAGS} in the procedure described in \S~\ref{subsec:compile:basic_procedures} as follows:
\begin{screen}
\begin{verbatim}
CC      = gcc
CXX     = g++
LDFLAGS = 
\end{verbatim}  
\end{screen}

%%%%%%%
\subsubsubsection{The case with MPI}
Assuming that the name of MPI librarie is \path{libmpi}, the compilation will succeed if you set the variables \path{CC}, \path{CXX}, and \path{LDFLAGS} in the procedure described in \S~\ref{subsec:compile:basic_procedures} as follows:
\begin{screen}
\begin{Verbatim}[commandchars=\\\{\}]
CC      = mpicc
CXX     = mpic++
LDFLAGS = -L\vrbit{PATH} -lmpi
\end{Verbatim}  
\end{screen}
where \textit{\texttt{PATH}} is the absolute PATH of the directory where the MPI libraries are installed.



The names of MPI libraries will be different depending on the system users use. Regarding this point, please inquire the administrator of the computer system users use.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Macro at the compilation}
\label{sec:macro_definition_at_compling}

%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Coordinate system}
\label{subsec:macro_coordinate}
Users have alternatives of 2D and 3D Cartesian coordinate systems.

\subsubsection{3D Cartesian coordinate system}
3D Cartesian coordinate system is used by default.

\subsubsection{2D Cartesian coordinate system}
2D Cartesian coordinate system can be used by defining \path{PARTICLE_SIMULATOR_TWO_DIMENSION} as macro.

%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Parallel processing}
\label{subsec:macro_parallel}
Users choose whether OpenMP is used or not, and whether MPI is used or not.

\subsubsection{OpenMP}
OpenMP is disabled by default. If macro \path{PARTICLE_SIMULATOR_THREAD_PARALLEL} is defined, OpenMP becomes enabled. Compiler option \texttt{-fopenmp} is required for GCC compiler.

\subsubsection{MPI}
MPI is disabled by default. If macro \path{PARTICLE_SIMULATOR_MPI_PARALLEL} is defined, MPI becomes enabled.

%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Accuracy of data types}
\label{subsec:macro_FP_accuracy}
Users can change the accuracy of data types in Superparticle types.

\subsubsection{Accuracy of data types in superparticle types}
All the member variables in Superparticle types are 64 bit accuracy. They becomes 32 bit accuracy if macro \path{PARTICLE_SIMULATOR_SPMOM_F32} is defined at the compile time.

%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{The extended feature ``Particle Mesh"}
\label{subsec:macro_PM}
The extended feature ``Particle Mesh" is disabled by default. If macro \path{PARTICLE_SIMULATOR_USE_PM_MODULE} is defined, this feature becomes enabled.

%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Log output for debugging}
\label{subsec:macro_debug}
If macro \path{PARTICLE_SIMULATOR_DEBUG_PRINT} is defined, FDPS output detailed log. This may be useful for debugging.
