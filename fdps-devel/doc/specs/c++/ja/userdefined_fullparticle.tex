\subsubsection{概要}

FullParticleクラスは粒子情報すべてを持つクラスであり、
節\ref{sec:overview_action}の手順0で、粒子群クラスに渡されるユーザー定
義クラスの１つである。ユーザーはこのクラスに対して、どのようなメンバ変
数、メンバ関数を定義してもかまわない。ただし、FDPSからFullParticleクラ
スの情報にアクセスする ために、ユーザーはいくつかの決まった名前のメン
バ関数を定義する必要がある。以下、この節の前提、常に必要なメンバ関数と、
場合によっては必要なメンバ関数について記述する。

\subsubsection{前提}

この節の中では、以下のように、FullParticleクラスとしてFPというクラスを
一例とする。FPという名前は自由に変えることができる。
\begin{screen}
\begin{verbatim}
class FP;
\end{verbatim}
\end{screen}

\subsubsection{必要なメンバ関数}

\subsubsubsection{概要}

常に必要なメンバ関数はFP::getPosとFP::copyFromForceである。FP::getPos
はFullParticleの位置情報をFDPSに読み込ませるための関数で、
FP::copyFromForceは計算された相互作用の結果をFullParticleに書き戻す関
数である。これらのメンバ関数の記述例と解説を以下に示す。

\subsubsubsection{FP::getPos}

\begin{screen}
\begin{verbatim}
class FP {
public:
    PS::F64vec getPos() const;
};
\end{verbatim}
\end{screen}

\begin{itemize}

\item {\bf 引数}

  なし
  
\item {\bf 返値}

  PS::F32vec型またはPS::F64vec型。FPクラスのオブジェクトの位置情報を保
  持したメンバ変数。
  
\item {\bf 機能}

  FPクラスのオブジェクトの位置情報を保持したメンバ変数を返す。
  
\end{itemize}

\subsubsubsection{FP::copyFromForce}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\if 0
\begin{screen}
\begin{verbatim}
class Force {
public:
    PS::F64vec acc;
    PS::F64    pot;
};
class FP {
public:
    PS::F64vec acceleration;
    PS::F64    potential;
    void copyFromForce(const Force & force) {
        this->acceleration = force.acc;
        this->potential    = force.pot;
    }
};
\end{verbatim}
\end{screen}

\begin{itemize}

\item {\bf 前提}

  Forceクラスは粒子の相互作用の計算結果を保持するクラス。

\item {\bf 引数}

  force: 入力。const Force \&型。粒子の相互作用の計算結果を保持。
  
\item {\bf 返値}

  なし。
  
\item {\bf 機能}

  粒子の相互作用の計算結果をFPクラスへ書き戻す。Forceクラスのメンバ変
  数acc, potがそれぞれFPクラスのメンバ変数acceleration, potentialに対
  応。
  
\item {\bf 備考}

  Forceクラスというクラス名とそのメンバ変数名は変更可能。FPのメンバ変
  数名は変更可能。メンバ関数FP::copyFromForceの引数名は変更可能。

\end{itemize}
\fi
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{screen}
\begin{verbatim}
class Force;

class FP {
public:
    void copyFromForce(const Force & force);
};
\end{verbatim}
\end{screen}

\begin{itemize}

\item {\bf 引数}

  force: 入力。const Force \&型。粒子の相互作用の計算結果を保持。
  
\item {\bf 返値}

  なし。
  
\item {\bf 機能}

  粒子の相互作用の計算結果をFPクラスへ書き戻す。
  
\end{itemize}


\subsubsection{場合によっては必要なメンバ関数}

\subsubsubsection{概要}

本節では、以下に示す場合に必要となるメンバ関数について記述する:
\begin{enumerate}%[leftmargin=*,itemsep=-1ex,label={[\arabic*]}]
\item 相互作用ツリークラスのPS::SEARCH\_MODE型にPS::SEARCH\_MODE\_LONG以外を用いる場合
\item 粒子群クラスのファイル入出力APIを用いる場合
\item 粒子群クラスのAPIであるParticleSystem::adjustPositionIntoRootDomainを用いる場合
\item 拡張機能のParticle Meshクラスを用いる場合
\end{enumerate}

\subsubsubsection{相互作用ツリークラスのPS::SEARCH\_MODE型に\\PS::SEARCH\_MODE\_LONG以外を用いる場合}

\subsubsubsubsection{FP::getRSearch}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\if 0
\begin{screen}
\begin{verbatim}
class FP {
public:
    PS::F64 search_radius;
    PS::F64 getRSearch() const {
        return this->search_radius;
    }
};
\end{verbatim}
\end{screen}

\begin{itemize}

\item {\bf 前提}

  FPクラスのメンバ変数search\_radiusはある１つの粒子の近傍粒子を探す半
  径の大きさ。このsearch\_radiusのデータ型はPS::F32型またはPS::F64型。
  
\item {\bf 引数}

  なし
  
\item {\bf 返値}

  PS::F32型またはPS::F64型。 FPクラスのオブジェクトの近傍粒子を探す半
  径の大きさを保持したメンバ変数。
  
\item {\bf 機能}

  FPクラスのオブジェクトの近傍粒子を探す半径の大きさを保持したメンバ変
  数を返す。

\item {\bf 備考}

  FPクラスのメンバ変数search\_radiusの変数名は変更可能。
  
\end{itemize}
\fi
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{screen}
\begin{verbatim}
class FP {
public:
    PS::F64 getRSearch() const;
};
\end{verbatim}
\end{screen}

\begin{itemize}

\item {\bf 引数}

  なし
  
\item {\bf 返値}

  PS::F32型またはPS::F64型。 FPクラスのオブジェクトの近傍粒子を探す半
  径の大きさを保持したメンバ変数。
  
\item {\bf 機能}

  FPクラスのオブジェクトの近傍粒子を探す半径の大きさを保持したメンバ変
  数を返す。

\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsubsection{粒子群クラスのファイル入出力APIを用いる場合}
\label{sec:userdefined_fullparticle_io}

粒子群クラスのファイル入出力APIであるParticleSystem::readParticleAscii, ParticleSystem::writeParticleAscii, ParticleSystem::readParticleBinary, ParticleSystem::writeParticleBinaryを使用するときにそれぞれreadAscii, writeAscii, readBinary, writeBinaryというメンバ関数が必要となる(readAscii, writeAscii, readBinary, writeAscii以外の名前を使うことも可能。詳しくは節\ref{sec:ParticleSystem:IO}を参照)。以下、readAsciiとwriteAscii, readBinary, writeBinaryの規定について記述する。

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsubsubsection{FP::readAscii}
\label{sec:FP_readAscii}

\begin{screen}
\begin{verbatim}
class FP {
public:
    void readAscii(FILE *fp);
};
\end{verbatim}
\end{screen}

\begin{itemize}

\item {\bf 引数}

  fp: FILE *型。粒子データの入力ファイルを指すファイルポインタ。
  
\item {\bf 返値}

  なし。
  
\item {\bf 機能}

  アスキー形式の粒子データの入力ファイル1行からFPクラス1個の情報を読み取り、メンバ変数に値を入れる。ここで1行とは、FPクラス1個のデータの末尾に\textbf{必ず唯一つの}改行コード(\texttt{\textbackslash n})がある状態の意味である。
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsubsubsection{FP::writeAscii}
\label{sec:FP_writeAscii}

\begin{screen}
\begin{verbatim}
class FP {
public:
    void writeAscii(FILE *fp);
};
\end{verbatim}
\end{screen}

\begin{itemize}

\item {\bf 引数}

  fp: FILE *型。粒子データの出力ファイルを指すファイルポインタ。
  
\item {\bf 返値}

  なし。
  
\item {\bf 機能}

  粒子データの出力ファイルへFPクラス1個の情報を1行としてアスキー形式で書き出す。ここで1行とは、FPクラス1個のデータの末尾に\textbf{必ず唯一つの}改行コード(\texttt{\textbackslash n})がある状態の意味である。
  
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsubsubsection{FP::readBinary}
\label{sec:FP_readBinary}

\begin{screen}
\begin{verbatim}
class FP {
public:
    void readBinary(FILE *fp);
};
\end{verbatim}
\end{screen}

\begin{itemize}

\item {\bf 引数}

  fp: FILE *型。粒子データの入力ファイルを指すファイルポインタ。
  
\item {\bf 返値}

  なし。
  
\item {\bf 機能}

  バイナリ形式の粒子データの入力ファイルからFPクラス1個の情報を読み取り、メンバ変数に値を入れる。
  
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsubsubsection{FP::writeBinary}
\label{sec:FP_writeBinary}

\begin{screen}
\begin{verbatim}
class FP {
public:
    void writeBinary(FILE *fp);
};
\end{verbatim}
\end{screen}

\begin{itemize}

\item {\bf 引数}

  fp: FILE *型。粒子データの出力ファイルを指すファイルポインタ。
  
\item {\bf 返値}

  なし。
  
\item {\bf 機能}

  粒子データの出力ファイルへFPクラス1個の情報をバイナリ形式で書き出す。
  
\end{itemize}


\subsubsubsection{ParticleSystem::adjustPositionIntoRootDomainを用いる場合}

\subsubsubsubsection{FP::setPos}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\if 0
\begin{screen}
\begin{verbatim}
class FP {
public:
    PS::F64vec pos;
    void setPos(const PS::F64vec pos_new) {
        this->pos = pos_new;
    }
};
\end{verbatim}
\end{screen}

\begin{itemize}

\item {\bf 前提}

  FPクラスのメンバ変数posは１つの粒子の位置情報。このposのデータ型は
  PS::F32vecまたはPS::F64vec。

\item {\bf 引数}

  pos\_new: 入力。const PS::F32vecまたはconst PS::F64vec型。FDPS側で修
  正した粒子の位置情報。

\item {\bf 返値}

  なし。
  
\item {\bf 機能}

  FDPSが修正した粒子の位置情報をFPクラスのオブジェクトの位置情報に書き
  込む。

\item {\bf 備考}

  FPクラスのメンバ変数posの変数名は変更可能。メンバ関数FP::setPosの引
  数名pos\_newは変更可能。posとpos\_newのデータ型が異なる場合の動作は
  保証しない。

\end{itemize}
\fi
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{screen}
\begin{verbatim}
class FP {
public:
    void setPos(const PS::F64vec pos_new);
};
\end{verbatim}
\end{screen}

\begin{itemize}

\item {\bf 引数}

  pos\_new: 入力。const PS::F32vecまたはconst PS::F64vec型。FDPS側で修
  正した粒子の位置情報。

\item {\bf 返値}

  なし。
  
\item {\bf 機能}

  FDPSが修正した粒子の位置情報をFPクラスのオブジェクトの位置情報に書き
  込む。

\end{itemize}

\subsubsubsection{Particle Meshクラスを用いる場合}

Particle Meshクラスを用いる場合には、メンバ関数
FP::getChargeParticleMeshと\\FP::copyFromForceParticleMeshを用意する必要
がある。以下にそれぞれの規定を記述する。

\subsubsubsubsection{FP::getChargeParticleMesh}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\if 0
\begin{screen}
\begin{verbatim}
class FP {
public:
    PS::F64 mass;
    PS::F64 getChargeParticleMesh() const {
        return this->mass;
    }
};
\end{verbatim}
\end{screen}

\begin{itemize}

\item {\bf 前提}

  FPクラスのメンバ変数massは１つの粒子の質量または電荷の情報を持つ変数。
  データ型はPS::F32またはPS::F64型。

\item {\bf 引数}

  なし。

\item {\bf 返値}

  PS::F32型またはPS::F64型。１つの粒子の質量または電荷の変数を返す。
  
\item {\bf 機能}

  １つの粒子の質量または電荷を表すメンバ変数を返す。

\item {\bf 備考}

  FPクラスのメンバ変数massの変数名は変更可能。

\end{itemize}
\fi
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{screen}
\begin{verbatim}
class FP {
public:
    PS::F64 getChargeParticleMesh() const;
};
\end{verbatim}
\end{screen}

\begin{itemize}

\item {\bf 引数}

  なし。

\item {\bf 返値}

  PS::F32型またはPS::F64型。１つの粒子の質量または電荷の変数を返す。
  
\item {\bf 機能}

  １つの粒子の質量または電荷を表すメンバ変数を返す。

\end{itemize}


\subsubsubsubsection{FP::copyFromForceParticleMesh}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\if 0
\begin{screen}
\begin{verbatim}
class FP {
public:
    PS::F64vec accelerationFromPM;
    void copyFromForceParticleMesh(const PS::F32vec & acc_pm) {
        this->accelerationFromPM = acc_pm;
    }
};
\end{verbatim}
\end{screen}

\begin{itemize}

\item {\bf 前提}

  FPクラスのメンバ変数accelerationFromPM\_pmは１つの粒子のParticle
  Meshによる力の情報を保持する変数。このaccelerationFromPM\_pmのデータ
  型はPS::F32vecまたはPS::F64vec。

\item {\bf 引数}

  acc\_pm: const PS::F32vec型またはconst PS::F64vec型。１つの粒子の
  Particle Meshによる力の計算結果。

\item {\bf 返値}

  なし。
  
\item {\bf 機能}

  １つの粒子のParticle Meshによる力の計算結果をこの粒子のメンバ変数に
  書き込む。
  
\item {\bf 備考}

  FPクラスのメンバ変数acc\_pmの変数名は変更可能。メンバ関数
  FP::copyFromForceParticleMeshの引数acc\_pmの引数名は変更可能。

\end{itemize}
\fi
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{screen}
\begin{verbatim}
class FP {
public:
    void copyFromForceParticleMesh(const PS::F32vec & acc_pm);
};
\end{verbatim}
\end{screen}

\begin{itemize}

\item {\bf 引数}

  acc\_pm: const PS::F32vec型またはconst PS::F64vec型。１つの粒子の
  Particle Meshによる力の計算結果。

\item {\bf 返値}

  なし。
  
\item {\bf 機能}

  １つの粒子のParticle Meshによる力の計算結果をこの粒子のメンバ変数に
  書き込む。
  
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsubsection{粒子交換時に粒子データをシリアライズして送る場合}
\label{sec:FP:serialize}

粒子交換時に粒子データをシリアライズして送る場合には、メンバ関数に
FP::packとFP::unpackを用意する必要がある。以下にそれぞれの規定を記述す
る。

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsubsubsection{FP::pack}

\begin{screen}
\begin{verbatim}
class FP {
public:
    static PS::S32 pack(const PS::S32 n_ptcl, const FP *ptcl[], char *buf, 
                        size_t & packed_size, const size_t max_buf_size);
};
\end{verbatim}
\end{screen}

\begin{itemize}

\item {\bf 引数}

  n\_ptcl: 粒子交換時に送る粒子の数。\\
  ptcl: 送る粒子へのポインタの配列。\\
  buf: 送信バッファーの先頭アドレス。\\
  packed\_size: ユーザーがバッファーへ書き込むサイズ。単位はバイト。\\
  max\_buf\_size: 送信バッファーの書き込み可能な領域のサイズ。単位はバイト。

\item {\bf 返値}

  PS::S32型。packed\_sizeがmax\_buf\_sizeを超えた場合は-1を返す。それ
  以外の場合は0を返す。
  
\item {\bf 機能}

 粒子交換時に送信する粒子をシリアライズし、送信バッファーに書き込む。

\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsubsubsection{FP::unPack}

\begin{screen}
\begin{verbatim}
class FP {
public:
    static PS::S32 unPack(const PS::S32 n_ptcl, FP ptcl[], const char *buf);
};
\end{verbatim}
\end{screen}

\begin{itemize}

\item {\bf 引数}

  n\_ptcl: 粒子交換時に受け取る粒子の数。\\
  ptcl: 受け取る粒子の配列。\\
  buf: 受信バッファーの先頭アドレス。

\item {\bf 返値}

  PS::S32型。デシリアライズに失敗した場合は-1を返す。それ以外の場合は0
  を返す。

\item {\bf 機能}

 粒子交換時に受信する粒子をデシリアライズし、粒子配列に書き込む。詳し
 くはセクション\ref{sec:particleSystem:exchangeParticle}を参照。デシリ
 アライズに失敗した場合はPS::Abort()が呼ばれプログラムは終了する。

\end{itemize}
