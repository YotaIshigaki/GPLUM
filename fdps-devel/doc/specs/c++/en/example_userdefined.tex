%\subsection{FullParticleクラス}
\subsection{Class FullParticle}
\label{sec:example_fullparticle}

%\subsubsection{概要}
\subsubsection{Summary}

%%FullParticleクラスは粒子情報すべてを持つクラスであり、節
%%\ref{sec:overview_action}の手順0で、粒子群クラスに渡されるユーザー定
%%義クラスの１つである。ユーザーはこのクラスに対して、どのようなメンバ
%%変数、メンバ関数を定義してもかまわない。ただし、FDPSからFullParticle
%%クラスの情報にアクセスする ために、ユーザーはいくつかの決まった名前の
%%メンバ関数を定義する必要がある。以下、この節の前提、常に必要なメンバ
%%関数と、場合によっては必要なメンバ関数について記述する。

Class FullParticle has all the data of a particle, and a user-defined
class given to FDPS with procedure 0 in
section~\ref{sec:overview_action}. Users can attach any member
variables and functions to this class. However, they need to define
several member functions with fixed names. This is because FDPS
accesses information of class FullParticle, using these member
functions. In what follows, we describe presumptions in this section,
necessary member functions, and member functions necessary for some
situations.

%\subsubsection{前提}
\subsubsection{Presumptions}

%%この節の中では、以下のように、FullParticleクラスとしてFPというクラス
%%を一例とする。FPという名前は自由に変えることができる。
In this section, we use class FP as an example of class
FullParticle. Users can change the name of FP as they like.
\begin{screen}
\begin{verbatim}
class FP;
\end{verbatim}
\end{screen}

%\subsubsection{必要なメンバ関数}
\subsubsection{Necessary member functions}

%\subsubsubsection{概要}
\subsubsubsection{Summary}

%%常に必要なメンバ関数はFP::getPosとFP::copyFromForceである。
%%FP::getPosはFullParticleの位置情報をFDPSに読み込ませるための関数で、
%%FP::copyFromForceは計算された相互作用の結果をFullParticleに書き戻す関
%%数である。これらのメンバ関数の記述例と解説を以下に示す。

Necessary member functions are functions FP::getPos and
FP::copyFromForce. Using the function FP::getPos, FDPS reads a
position from class FullParticle. Using the function
FP::copyFromForce, FDPS writes results of interaction calculation to
class FullParticle. We present description examples of these
functions.

\subsubsubsection{FP::getPos}

\begin{screen}
\begin{verbatim}
class FP {
public:
    PS::F64vec getPos() const;
};
\end{verbatim}
\end{screen}

\begin{itemize}

\item {\bf Arguments}

  None
  
\item {\bf Return vale}

%%  PS::F32vec型またはPS::F64vec型。FPクラスのオブジェクトの位置情報を
%%  保 持したメンバ変数。
  Types PS::F32vec or PS::F64vec. A member variable keeping a position
  of class FP object.
  
\item {\bf Behavior}

%%  FPクラスのオブジェクトの位置情報を保持したメンバ変数を返す。
  Return a member variable keeping a position of class FP object.
  
\end{itemize}

\subsubsubsection{FP::copyFromForce}

\begin{screen}
\begin{verbatim}
class Force {
public:
    PS::F64vec acc;
    PS::F64    pot;
};
class FP {
public:
    PS::F64vec acceleration;
    PS::F64    potential;
    void copyFromForce(const Force & force) {
        this->acceleration = force.acc;
        this->potential    = force.pot;
    }
};
\end{verbatim}
\end{screen}

\begin{itemize}

\item {\bf Presumptions}

%  Forceクラスは粒子の相互作用の計算結果を保持するクラス。
  Class Force has results of interaction calculation of a particle.

\item {\bf Arguments}

%  force: 入力。const Force \&型。粒子の相互作用の計算結果を保持。
  force: input. Type const Force. The variable force has results of
  interaction calculation of a particle.
  
\item {\bf Return value}

  なし。
  
\item {\bf Behavior}

%%  粒子の相互作用の計算結果をFPクラスへ書き戻す。Forceクラスのメンバ変
%%  数acc, potがそれぞれFPクラスのメンバ変数acceleration, potentialに対
%%  応。
  Write results of interaction calculation of a particle to class FP
  object. The member variables acc and pot in class Force correspond
  to the member variables of acceleration and potential in class FP,
  respectively.
  
\item {\bf Remarks}

%%  Forceクラスというクラス名とそのメンバ変数名は変更可能。FPのメンバ変
%%  数名は変更可能。メンバ関数FP::copyFromForceの引数名は変更可能。
  The names of ``Force'' and its member variables are mutable. The
  names of member variables of class FP are also mutable. The argument
  name of member function FP::copyFromForce is mutable.

\end{itemize}

%\subsubsection{場合によっては必要なメンバ関数}
\subsubsection{Member functions necessary for some situations}

%\subsubsubsection{概要}
\subsubsubsection{Summary}

%%本節では、場合によっては必要なメンバ関数について記述する。相互作用ツ
%%リークラスのPS::SEARCH\_MODE型にPS::SEARCH\_MODE\_LONG以外を用いる場
%%合、粒子群クラスのファイル入出力APIを用いる場合、粒子群クラスのAPIで
%%ある\\ParticleSystem::adjustPositionIntoRootDomainを用いる場合、拡張
%%機能のParticle Meshクラスを用いる場合について必要となるメンバ関数を記
%%述する。

We describe member functions necessary for some situations. These
situations are where all the types of PS::SEARCH\_MODE but type
PS::SEARCH\_MODE\_LONG are used, where file I/O APIs of class
ParticleSystem are used, where
ParticleSystem::adjustPositionIntoRootDomain is used, and where class
Particle Mesh is used.

%%\subsubsubsection{相互作用ツリークラスのPS::SEARCH\_MODE型に\\PS::SEARCH\_MODE\_LONG以外を用いる場合}
\subsubsubsection{The cases where all the types of PS::SEARCH\_MODE
  but type \\ PS::SEARCH\_MODE\_LONG are used}

\subsubsubsubsection{FP::getRSearch}

\begin{screen}
\begin{verbatim}
class FP {
public:
    PS::F64 search_radius;
    PS::F64 getRSearch() const {
        return this->search_radius;
    }
};
\end{verbatim}
\end{screen}

\begin{itemize}

\item {\bf Presumptions}

%%  FPクラスのメンバ変数search\_radiusはある１つの粒子の近傍粒子を探す
%%  半 径の大きさ。このsearch\_radiusのデータ型はPS::F32型または
%%  PS::F64型。
  A member variable search\_radius is a radius of a particle which is
  used to search for neighbor particles of a particle.  The data type
  of the search\_radius is types PS::F32 or PS::F64.
  
\item {\bf Arguments}

  None
  
\item {\bf Return value}

%%  PS::F32型またはPS::F64型。 FPクラスのオブジェクトの近傍粒子を探す半
%%  径の大きさを保持したメンバ変数。
  Types PS::F32 or PS::F64. A member variable of class FP object which
  has a radius of a particle to search for neighbor particles.
  
\item {\bf Behavior}

%%  FPクラスのオブジェクトの近傍粒子を探す半径の大きさを保持したメンバ
%%  変 数を返す。
  Return the member variable of class FP object which has a radius of
  a particle to search for its neighbor particles.
  
\item {\bf Remarks}

%%  FPクラスのメンバ変数search\_radiusの変数名は変更可能。
  The name of member variable search\_radius is mutable.
  
\end{itemize}

%\subsubsubsection{粒子群クラスのファイル入出力APIを用いる場合}
\subsubsubsection{The case where file I/O APIs of class ParticleSystem is used}
\label{sec:example_userdefined_fullparticle_io}

Member functions \texttt{readAscii}, \texttt{writeAscii}, \texttt{readBinary}, and \texttt{writeBinary} are necessary when \texttt{ParticleSystem::readParticleAscii}, \texttt{ParticleSystem::writeParticleAscii}, \texttt{ParticleSystem::readParticleBinary}, and \texttt{ParticleSystem::writeParticleBinary} are used, respectively (users can also use different names for these member functions. For more details, please see section \ref{sec:ParticleSystem:IO}). In what follows, we describe how to describe these member functions.


\subsubsubsubsection{FP::readAscii}

\begin{screen}
\begin{verbatim}
class FP {
public:
    PS::S32 id;
    PS::F64 mass;
    PS::F64vec pos;
    void readAscii(FILE *fp) {
        fscanf(fp, "%d%lf%lf%lf%lf", &this->id, &this->mass,
               &this->pos[0], &this->pos[1], &this->pos[2]);
    }
};
\end{verbatim}
\end{screen}

\begin{itemize}

\item {\bf Premises}

  In the input file of particle data, the first, second, third,
  fourth, and fifth columns contain particle IDs, masses, and three components of positions, respectively. File format is Ascii. 3D Cartesian coordinate system is adopted.

\item {\bf Arguments}

  fp: type FILE *. File pointer which points to an input file with particle data.
  
\item {\bf Return value}

  None.
  
\item {\bf Behavior}

  Read information of id, mass, and pos of class FP from an input
  file.
  
\item {\bf Remarks}

  None.
  
\end{itemize}

\subsubsubsubsection{FP::writeAscii}

\begin{screen}
\begin{verbatim}
class FP {
public:
    PS::S32 id;
    PS::F64 mass;
    PS::F64vec pos;
    void writeAscii(FILE *fp) {
        fscanf(fp, "%d %lf %lf %lf %lf", this->id, this->mass,
               this->pos[0], this->pos[1], this->pos[2]);
    }
};
\end{verbatim}
\end{screen}

\begin{itemize}

\item {\bf Premises}

  In the output file of particle data, the first, second, third,
  fourth, and fifth columns contain particle IDs, masses, and three components of positions, respectively. File format is Ascii. 3D Cartesian coordinate system is adopted.
  

\item {\bf Arguments}

  fp: type FILE *. File pointer which points to an output file with particle data.
  
\item {\bf Return value}

  None.
  
\item {\bf Behavior}

  Write information of id, mass, and pos of class FP to an output
  file.
  
\item {\bf Remarks}

  None.
  
\end{itemize}

\subsubsubsubsection{FP::readBinary}

\begin{screen}
\begin{verbatim}
class FP {
public:
    PS::S32 id;
    PS::F64 mass;
    PS::F64vec pos;
    void readBinary(FILE *fp) {
        fread(&this->id, sizeof(PS::S32), 1, fp);
        fread(&this->mass, sizeof(PS::F64), 1, fp);
        fread(&this->pos, sizeof(PS::F64vec), 1, fp);
    }
};
\end{verbatim}
\end{screen}

\begin{itemize}

\item {\bf Premises}

  In the input file, particle data are assumed to be stored contiguously. In other words, there is no interval between any two particle data. Data of a single particle is stored as follows: particle ID, mass, and three components of position line up in this order. The file position indicator is assumed to point the head of a particle data. File format is binary. 3D Cartesian coordinate system is adopted.

\item {\bf Arguments}

  fp: type FILE *. File pointer which points to an input file with particle data.
  
\item {\bf Return value}

  None.
  
\item {\bf Behavior}

  Read information of id, mass, and pos of class FP from an input
  file.
  
\item {\bf Remarks}

  None.
  
\end{itemize}

\subsubsubsubsection{FP::writeBinary}

\begin{screen}
\begin{verbatim}
class FP {
public:
    PS::S32 id;
    PS::F64 mass;
    PS::F64vec pos;
    void writeBinary(FILE *fp) {
        fwrite(&this->id, sizeof(PS::S32), 1 , fp);
        fwrite(&this->mass, sizeof(PS::F64), 1, fp);
        fwrite(&this->pos, sizeof(PS::F64vec), 1, fp);
    }
};
\end{verbatim}
\end{screen}

\begin{itemize}

\item {\bf Premises}

  In the output file, particle data are assumed to be stored contiguously. In other words, there is no interval between any two particle data. The file position indicator is assumed to point the tail end of the data that is output previously. Now, we want to output a particle data as follows: particle ID, mass, and three components of position line up in this order. File format is binary. 3D Cartesian coordinate system is adopted.
  

\item {\bf Arguments}

  fp: type FILE *. File pointer which points to an output file with particle data.
  
\item {\bf Return value}

  None.
  
\item {\bf Behavior}

  Write information of id, mass, and pos of class FP to an output
  file.
  
\item {\bf Remarks}

  None.
  
\end{itemize}


%\subsubsubsection{ParticleSystem::adjustPositionIntoRootDomainを用いる場合}
\subsubsubsection{The case where ParticleSystem::adjustPositionIntoRootDomain is used}

\subsubsubsubsection{FP::setPos}

\begin{screen}
\begin{verbatim}
class FP {
public:
    PS::F64vec pos;
    void setPos(const PS::F64vec pos_new) {
        this->pos = pos_new;
    }
};
\end{verbatim}
\end{screen}

\begin{itemize}

\item {\bf Presumptions}

%  FPクラスのメンバ変数posは１つの粒子の位置情報。このposのデータ型は
%  PS::F32vecまたはPS::F64vec。
  The member variable pos is a position of a particle. Its data type
  is PS::F32vec or PS::F64vec.

\item {\bf Arguments}

%  pos\_new: 入力。const PS::F32vecまたはconst PS::F64vec型。FDPS側で修
%  正した粒子の位置情報。
  pos\_new: input. Type const PS::F32vec or const PS::F64vec. Position
  data modified by FDPS.

\item {\bf Return value}

%  なし。
  None.
  
\item {\bf Behavior}

%  FDPSが修正した粒子の位置情報をFPクラスのオブジェクトの位置情報に書き
%  込む。
  Write position data modified by FDPS to class FP object.

\item {\bf Remarks}

%  FPクラスのメンバ変数posの変数名は変更可能。メンバ関数FP::setPosの引
%  数名pos\_newは変更可能。posとpos\_newのデータ型が異なる場合の動作は
%  保証しない。
  The name of member variable pos is mutable. The argument name of
  pos\_new is mutable. If the data types of pos and pos\_new are
  different, it may not work well.

\end{itemize}

%\subsubsubsection{Particle Meshクラスを用いる場合}
\subsubsubsection{The case where class Particle Mesh is used}

%%Particle Meshクラスを用いる場合には、メンバ関数
%%FP::getChargeParticleMeshと\\FP::copyFromForceParticleMeshを用意する
%%必要がある。以下にそれぞれの規定を記述する。
When class Particle Mesh is used, member functions
FP::getChargeParticleMesh and FP::copyFromForceParticleMesh are
necessary. In the following, we describe how to describe them.

\subsubsubsubsection{FP::getChargeParticleMesh}

\begin{screen}
\begin{verbatim}
class FP {
public:
    PS::F64 mass;
    PS::F64 getChargeParticleMesh() const {
        return this->mass;
    }
};
\end{verbatim}
\end{screen}

\begin{itemize}

\item {\bf Presumptions}

%  FPクラスのメンバ変数massは１つの粒子の質量または電荷の情報を持つ変数。
%  データ型はPS::F32またはPS::F64型。
  The member variable mass has particle mass or charge. Its data type
  is PS::F32 or PS::F64.

\item {\bf Arguments}

%  なし。
  None.

\item {\bf Return value}

%  PS::F32型またはPS::F64型。１つの粒子の質量または電荷の変数を返す。
  Types PS::F32 or PS::F64. Return particle mass or charge.
  
\item {\bf Behavior}

%  １つの粒子の質量または電荷を表すメンバ変数を返す。
  Return a member variable keeping particle mass or charge.

\item {\bf Remarks}

%  FPクラスのメンバ変数massの変数名は変更可能。
  The variable name of mass is mutable.

\end{itemize}


\subsubsubsubsection{FP::copyFromForceParticleMesh}

\begin{screen}
\begin{verbatim}
class FP {
public:
    PS::F64vec accelerationFromPM;
    void copyFromForceParticleMesh(const PS::F32vec & acc_pm) {
        this->accelerationFromPM = acc_pm;
    }
};
\end{verbatim}
\end{screen}

\begin{itemize}

\item {\bf Presumptions}

%  FPクラスのメンバ変数accelerationFromPM\_pmは１つの粒子のParticle
%  Meshによる力の情報を保持する変数。このaccelerationFromPM\_pmのデータ
%  型はPS::F32vecまたはPS::F64vec。
  The member variable accelerationFromPM\_pm has force data exerted on
  a particle. Its data type is PS::F32vec or PS::F64vec.

\item {\bf Arguments}

%  acc\_pm: const PS::F32vec型またはconst PS::F64vec型。１つの粒子の
%  Particle Meshによる力の計算結果。
  acc\_pm: type const PS::F32vec or const PS::F64vec. Results of class
  Particle Mesh.

\item {\bf Return value}

%  なし。
  None.
  
\item {\bf Behavior}

%  １つの粒子のParticle Meshによる力の計算結果をこの粒子のメンバ変数に
%  書き込む。
  Write a force on a particle from class Particle Mesh to the member
  variable.
  
\item {\bf Remarks}

%  FPクラスのメンバ変数acc\_pmの変数名は変更可能。メンバ関数
%  FP::copyFromForceParticleMeshの引数acc\_pmの引数名は変更可能。
  The variable name of acc\_pm is mutable. The argument name acc\_pm
  is mutable.

\end{itemize}

%\subsection{EssentialParticleIクラス}
\subsection{Class EssentialParticleI}
\label{sec:example_essentialparticlei}

%\subsubsection{概要}
\subsubsection{Summary}

%EssentialParticleIクラスは相互作用の計算に必要なi粒子の情報を持つクラ
%スであり、相互作用の定義(節\ref{sec:overview_action}の手順0)に必要とな
%る。EssentialParticleIクラスはFullParticleクラス(節
%\ref{sec:fullparticle})のサブセットである。FDPSは、このクラスのデータ
%にアクセスする必要がある。そのため、EssentialParticleIクラスはいくつか
%のメンバ関数を持つ必要がある。以下、この節の前提、常に必要なメンバ関数
%と、場合によっては必要なメンバ関数について記述する。
Class EssentialParticleI has $i$-particle data, and is necessary when
users define particle-particle interaction (procedure 0 in section
\ref{sec:overview_action}). The data set of class EssentialParticleI
is a subset of the data set of class FullParticle. FDPS accesses the
data variables of class EssentialParticleI. In what follows, we
describe the presumptions in this section, necessary member functions,
and member functions necessary for some situations.

\subsubsection{Presumptions}

%この節の中では、EssentialParticleIクラスとしてEPIというクラスを一例と
%して使う。また、FullParticleクラスの一例としてFPというクラスを使う。
%EPI, FPというクラス名は変更可能である。
In this section, we use class EPI and FP as examples of classes
EssentialParticleI and FullParticle, respectively. The names EPI and
FP are mutable.

%EPIとFPの宣言は以下の通りである。
The classes EPI and FP are declared as follows.
\begin{screen}
\begin{verbatim}
class FP;
class EPI;
\end{verbatim}
\end{screen}

%\subsubsection{必要なメンバ関数}
\subsubsection{Necessary member functions}

%\subsubsubsection{概要}
\subsubsubsection{Summary}

%%常に必要なメンバ関数はEPI::getPosとEPI::copyfromFPである。
%%EPI::getPosはEPIクラスの位置情報をFDPSに読み込ませるための関数で、
%%EPI::copyFromFPはFPクラスの情報をEPIクラスに書きこむ関数である。これ
%%らのメンバ関数の記述例と解説を以下に示す。
The member functions EPI::getPos and EPI::copyfromFP are
necessary. FDPS uses the former to read position data in class EPI,
and the latter to write class FP data to class EPI. We present how to
describe these functions.

\subsubsubsection{EPI::getPos}

\begin{screen}
\begin{verbatim}
class EPI {
public:
    PS::F64vec pos;
    PS::F64vec getPos() const {
        return this->pos;
    }
};
\end{verbatim}
\end{screen}

\begin{itemize}

\item {\bf Presumptions}
  
%  EPIのメンバ変数posはある１つの粒子の位置情報。このposのデー タ型は
%  PS::F64vec型。
  The member variable pos is particle position. Its data type is
  PS::F64vec.
  
\item {\bf Arguments}

%  なし
  None.
  
\item {\bf Return value}

%  PS::F64vec型。EPIクラスの位置情報を保持したメンバ変数。
  Type PS::F64vec. Member variable keeping position data of class EPI.
  
\item {\bf Behavior}

%  EPIクラスのオブジェクトの位置情報を保持したメンバ変数を返す。
  Return a memeber variable with position data of class EPI object.
  
\item {\bf Remarks}

%  EPIクラスのメンバ変数posの変数名は変更可能。
  The variable name pos is mutable.

\end{itemize}

\subsubsubsection{EPI::copyFromFP}

\begin{screen}
\begin{verbatim}
class FP {
public:
    PS::S64    identity;
    PS::F64    mass;
    PS::F64vec position;
    PS::F64vec velocity;
    PS::F64vec acceleration;
    PS::F64    potential;
};
class EPI {
public:
    PS::S64    id;
    PS::F64vec pos;
    void copyFromFP(const FP & fp) {
        this->id  = fp.identity;
        this->pos = fp.position;
    }
};
\end{verbatim}
\end{screen}

\begin{itemize}

\item {\bf Presumptions}

%  FPクラスのメンバ変数identity, positionとEPI クラスのメンバ変数id,
%  posはそれぞれ対応する情報を持つ。
  The member variable identity and position in class FP correspond to
  the member variables id and pos in class EPI.

\item {\bf Arguments}

%  fp: 入力。const FP \&型。FPクラスの情報を持つ。
  fp: input. Type const FP \&. Information of class FP object.
  
\item {\bf Return value}

%  なし。
  None.
  
\item {\bf Behavior}

%  FPクラスの持つ１粒子の情報の一部をEssnetialParticleIクラス に書き込
%  む。
  Write a part of particle data of class FP to class EPI object.
  
\item {\bf Remarks}

%  FPクラスのメンバ変数の変数名、EPIクラスのメ ンバ変数の変数名は変更可
%  能。メンバ関数EPI::copyFromFP の引数名は変更可能。EPIクラスの粒子情
%  報はFP クラスの粒子情報のサブセット。対応する情報を持つメンバ変数同
%  士のデー タ型が一致している必要はないが、実数型とベクトル型(または整
%  数型とベ クトル型)という違いがある場合に正しく動作する保証はない。
  The member variables of classes FP and EPI are mutable. The argument
  name of EPI::copyFromFP is mutable. The particle data of class EPI
  is a subset of the particle data of class FP. 

\end{itemize}

%\subsubsection{場合によっては必要なメンバ関数}
\subsubsection{Member functions necessary for some situations}

%\subsubsubsection{概要}
\subsubsubsection{Summary}

%本節では、場合によっては必要なメンバ関数について記述する。相互作用ツリー
%クラスのPS::SEARCH\_MODE型にPS::SEARCH\_MODE\_GATHERまたは
%PS::SEARCH\_MODE\_SYMMETRYを用いる場合に必要となるメンバ関数ついて記述
%する。
In this section, we describe member functions necessary for some
situations. The situations are where PS::SEARCH\_MODE\_GATHER and
PS::SEARCH\_MODE\_SYMMETRY are adopted for type PS::SEARCH\_MODE.

%\subsubsubsection{相互作用ツリークラスのPS::SEARCH\_MODE型に\\PS::SEARCH\_MODE\_GATHERまたはPS::SEARCH\_MODE\_SYMMETRYを用いる場合}
\subsubsubsection{The case where PS::SEARCH\_MODE\_GATHER and
  \\ PS::SEARCH\_MODE\_SYMMETRY are adopted for type
  \\ PS::SEARCH\_MODE}

\subsubsubsubsection{EPI::getRSearch}

\begin{screen}
\begin{verbatim}
class EPI {
public:
    PS::F64 search_radius;
    PS::F64 getRSearch() const {
        return this->search_radius;
    }
};
\end{verbatim}
\end{screen}

\begin{itemize}

\item {\bf Presumptions}

%  EPIクラスのメンバ変数search\_radiusはある１つの粒子の 近傍粒子を探す
%  半径の大きさ。このsearch\_radiusのデータ型はPS::F32型 またはPS::F64
%  型。
  A member variable search\_radius is a radius of a particle which is
  used to search for neighbor particles of a particle.  The data type
  of the search\_radius is types PS::F32 or PS::F64.
    
\item {\bf Arguments}

%  なし
  None.
  
\item {\bf Return value}

%  PS::F32型またはPS::F64型。 EPIクラスの近傍粒子を探す 半径の大きさを
%  保持したメンバ変数。
  Types PS::F32 or PS::F64. A member variable of class EPI object which
  has a radius of a particle to search for neighbor particles.
  
\item {\bf Behavior}

%  EPIクラスの近傍粒子を探す半径の大きさを保持したメンバ 変数を返す。
  Return the member variable of class EPI object which has a radius of
  a particle to search for its neighbor particles.

\item {\bf Remarks}

%  EPIクラスのメンバ変数search\_radiusの変数名は変更可能。
  The name of member variable search\_radius is mutable.
  
\end{itemize}

%\subsection{EssentialParticleJクラス}
\subsection{Class EssentialParticleJ}
\label{sec:example_essentialparticlej}

%\subsubsection{概要}
\subsubsection{Summary}

%EssentialParticleJクラスは相互作用の計算に必要なj粒子の情報を持つクラ
%スであり、相互作用の定義(節\ref{sec:overview_action}の手順0)に必要とな
%る。EssentialParticleJクラスはFullParticleクラス(節
%\ref{sec:fullparticle})のサブセットである。FDPSは、このクラスのデータ
%にアクセスする必要がある。このために、EssentialParticleJクラスはいくつ
%かのメンバ関数を持つ必要がある。以下、この節の前提、常に必要なメンバ関
%数と、場合によっては必要なメンバ関数について記述する。
Class EssentialParticleJ has $j$-particle data necessary for
interaction calculations, and is necessary for the definition of
interactions (procedure 0 in section \ref{sec:overview_action}). The
data of class EssentialParticleJ is a subset of the data of class
FullParticle (section \ref{sec:fullparticle}). FDPS accesses the data
of this class. For this purpose, class EssntialParticleJ must have
some member functions. In the following, we describe the presumptions
of this section, necessary member functions, and member functions
necessary for some situations.

\subsubsection{Presumptions}

%この節の中では、EssentialParticleJクラスとしてEPJというクラスを一例と
%して使う。また、FullParticleクラスの一例としてFPというクラスを使う。
%EPJ, FPというクラス名は変更可能である。
In this section, we use class EPJ and FP as examples of classes
EssentialParticleJ and FullParticle, respectively. The class names of
EPJ and FP are mutable.

%EPJとFPの宣言は以下の通りである。
The declarations of EPJ and FP are as follows.
\begin{screen}
\begin{verbatim}
class FP;
class EPJ;
\end{verbatim}
\end{screen}

%\subsubsection{必要なメンバ関数}
\subsubsection{Necessary member functions}

%\subsubsubsection{概要}
\subsubsubsection{Summary}

%常に必要なメンバ関数はEPJ::getPosとEPJ::copyfromFPである。EPJ::getPos
%はEPJクラスの位置情報をFDPSに読み込ませるための関数で、
%EPJ::copyFromFPはFPクラスの情報をEPJクラスに書きこむ関数である。これら
%のメンバ関数の記述例と解説を以下に示す。
Necessary member functions are EPJ::getPos and EPJ::copyfromFP. Using
the former function, FDPS reads the position data of class FP, and
write it to class EPJ. Using the latter funciton, FDPS reads the
various data of class FP, and write them to class EPJ. We describe
these functions in this section.

\subsubsubsection{EPJ::getPos}

\begin{screen}
\begin{verbatim}
class EPJ {
public:
    PS::F64vec pos;
    PS::F64vec getPos() const {
        return this->pos;
    }
};
\end{verbatim}
\end{screen}

\begin{itemize}

\item {\bf Presumptions}
  
%  EPJのメンバ変数posはある１つの粒子の位置情報。このposのデー タ型は
%  PS::F64vec型。
  Member variable pos is the position data of one particle. Its data
  type is PS::F64vec.
  
\item {\bf Arguments}

%  なし
  None.
  
\item {\bf Return value}

%  PS::F64vec型。EPJクラスの位置情報を保持したメンバ変数。
  Type PS::F64vec. Member variable keeping position data.
  
\item {\bf Behavior}

%  EPJクラスの位置情報を保持したメンバ変数を返す。
  Return position data of class EPJ object.
  
\item {\bf Remarks}

%  EPJクラスのメンバ変数posの変数名は変更可能。
  The member variable name of pos is mutable.

\end{itemize}

\subsubsubsection{EPJ::copyFromFP}

\begin{screen}
\begin{verbatim}
class FP {
public:
    PS::S64    identity;
    PS::F64    mass;
    PS::F64vec position;
    PS::F64vec velocity;
    PS::F64vec acceleration;
    PS::F64    potential;
};
class EPJ {
public:
    PS::S64    id;
    PS::F64    m;
    PS::F64vec pos;
    void copyFromFP(const FP & fp) {
        this->id  = fp.identity;
        this->m   = fp.mass;
        this->pos = fp.position;
    }
};
\end{verbatim}
\end{screen}

\begin{itemize}

\item {\bf Presumptions}

%  FPクラスのメンバ変数identity, mass, positionと EPJクラスのメンバ変数
%  id, m, posはそれぞれ対応する情報 を持つ。
  Member variables of identity, mass, and position in class FP
  correspond to those of id, m, and pos in class EPJ.

\item {\bf Arguments}

%  fp: 入力。const FP \&型。FPクラスの情報を持つ。
  fp: input. Type const FP \&. The variable keeping the data of class
  FP object.
  
\item {\bf Return value}

%  なし。
  None.
  
\item {\bf Behavior}

%  FPクラスの持つ１粒子の情報の一部をEPJクラスに書き込む。
  Read a part of the data of class FP object, and write them to class
  EPJ object.
  
\item {\bf Remarks}

%  FPクラスのメンバ変数の変数名、EPJクラスのメンバ変数の変数名は変更可
%  能。メンバ関数EPJ::copyFromFPの引数名は変更可能。対応する情報を持つ
%  メンバ変数同士のデータ型が一致している必要はないが、実数型とベクトル
%  型(または整数型とベクトル型)という違いがある場合に正しく動作する保証
%  はない。
  The member variable names of classes FP and EPJ are mutable. The
  argument name of a member function EPJ::copyFromFP is mutable.

\end{itemize}

%\subsubsection{場合によっては必要なメンバ関数}
\subsubsection{Member functions necessary for some situations}

%\subsubsubsection{概要}
\subsubsubsection{Summary}

%本節では、場合によっては必要なメンバ関数について記述する。相互作用ツリー
%クラスのPS::SEARCH\_MODE型にPS::SEARCH\_MODE\_LONG以外を用いる場合に必
%要なメンバ関数、列挙型のBOUNDARY\_CONDITION型に
%PS::BOUNDARY\_CONDITION\_OPEN以外を選んだ場合に必要となるメンバ関数に
%ついて記述する。なお、既存のMomentクラスやSuperParticleJクラスを用いる
%際に必要となるメンバ変数はこれら既存のクラスの節を参照のこと。
In this section, we describe member functions necessary for some
situations. The situations are where users adopt all but
PS::SEARCH\_MODE\_LONG for data type PS::SEARCH\_MODE, and where they
adopt all but PS::BOUNDARY\_CONDITION\_OPEN for data type
BOUNDARY\_CONDITION. We do not describe member functions necessary for
situations where pre-existing Moment and SuperParticleJ classes. These
member functions are explained in sections~\ref{sec:moment} and
\ref{sec:superparticlej}.

%\subsubsubsection{相互作用ツリークラスのPS::SEARCH\_MODE型に\\PS::SEARCH\_MODE\_LONG以外を用いる場合}
\subsubsubsection{The cases where all but PS::SEARCH\_MODE\_LONG are
  used for data type PS::SEARCH\_MODE}

\subsubsubsubsection{EPJ::getRSearch}

\begin{screen}
\begin{verbatim}
class EPJ {
public:
    PS::F64 search_radius;
    PS::F64 getRSearch() const {
        return this->search_radius;
    }
};
\end{verbatim}
\end{screen}

\begin{itemize}

\item {\bf Presumptions}

%  EPJクラスのメンバ変数search\_radiusはある１つの粒子の 近傍粒子を探す
%  半径の大きさ。このsearch\_radiusのデータ型はPS::F32型 またはPS::F64
%  型。
  The member variable search\_radius is a radius of a
  particle. Neighbor particles of the particle are defined as those
  inside the particle. The data type of search\_radius may be PS::F32
  or PS::F64.
  
\item {\bf Arguments}

%  なし
  None.
  
\item {\bf Return value}

%  PS::F32型またはPS::F64型。 EPJクラスの近傍粒子を探す 半径の大きさを
%  保持したメンバ変数。
  Data types PS::F32 or PS::F64. A radius of a particle.
  
\item {\bf Behavior}

%  EPJクラスの近傍粒子を探す半径の大きさを保持したメンバ 変数を返す。
  Return a radius of particle.

\item {\bf Remarks}

%  EPJクラスのメンバ変数search\_radiusの変数名は変更可能。
  The member variable name of search\_radius is mutable.
  
\end{itemize}

%\subsubsubsection{BOUNDARY\_CONDITION型にPS::BOUNDARY\_CONDITION\_OPEN以外を用いる場合}
\subsubsubsection{The cases where all but
  PS::BOUNDARY\_CONDITION\_OPEN are used for data type
  BOUNDARY\_CONDITION}

\subsubsubsubsection{EPJ::setPos}

\begin{screen}
\begin{verbatim}
class EPJ {
public:
    PS::F64vec pos;
    void setPos(const PS::F64vec pos_new) {
        this->pos = pos_new;
    }
};
\end{verbatim}
\end{screen}

\begin{itemize}

\item {\bf Presumptions}
  
%  EPJクラスのメンバ変数posは１つの粒子の位置情報。この posのデータ型は
%  PS::F32vecまたはPS::F64vec。EPJクラス のメンバ変数posの元データとなっ
%  ているのはFPクラスのメンバ 変数position。このデータ型はPS::F32vecま
%  たはPS::F64vec。
  The member variable pos is a position data of a particle. The data
  type of pos may be PS::F32vec or PS::F64vec. The original data of
  the variable pos is a member variable of class FP, position. This
  data type may be PS::F32vec or PS::F64vec.

\item {\bf Arguments}

%  pos\_new: 入力。const PS::F32vecまたはconst PS::F64vec型。FDPS側で修
%  正した粒子の位置情報。
  pos\_new: Input. Type const PS::F32vec or const PS::F64vec. Position
  data modified by FDPS.

\item {\bf Return value}

%  なし。
  None.
  
\item {\bf Behavior}

%  FDPSが修正した粒子の位置情報をEPJクラスの位置情報に書き込む。
  FDPS writes modified position data to a position data of class EPJ.

\item {\bf Remarks}

%  EPJクラスのメンバ変数posの変数名は変更可能。メンバ関 数EPJ::setPosの
%  引数名pos\_newは変更可能。posと pos\_newのデータ型が異なる場合の動作
%  は保証しない。
  The member variable name of pos is mutable. The argument name of
  pos\_new is mutable. 

\end{itemize}

%\subsection{Momentクラス}
\subsection{Class Moment}
\label{sec:example_moment}

%\subsubsection{概要}
\subsubsection{Summary}

%Momentクラスは近い粒子同士でまとまった複数の粒子のモーメント情報を持つ
%クラスであり、相互作用の定義(節\ref{sec:overview_action}の手順0)に必要
%となる。モーメント情報の例としては、複数粒子の単極子や双極子、さらにこ
%れら粒子の持つ最大の大きさなど様々なものが考えられる。このクラスは、
%EssentialParticleJクラスからSuperParticleJクラスを作るための中間変数の
%ような役割を果す。従って、このクラスが持つメンバ関数は、
%EssentialParticleJクラスから情報を読み出してモーメントを計算するメンバ
%関数、少ない数の粒子のモーメントからそれらの粒子を含むより多くの粒子の
%モーメントを計算するメンバ関数などがある。
Class Moment has moment data of several particles close to each other,
and is necessary for the definition of interaction (procedure 0 in
section \ref{sec:overview_action}). Examples of moment data are
monopole and dipole of several particles, and the maximum size of
these particles. This class plays a role like intermediate variables
between classes EssentialParticleJ and SuperParticleJ. Necessary
member functions of this class are, for example, a member function
which reads some data from class EssnetialParticleJ, and calculate
moment of particles.

%このようなモーメント情報にはある程度決っているものが多いので、それらに
%ついてはFDPS側で用意した。これら既存のクラスについてまず記述する。その
%後にユーザーがモーメントクラスを自作する際に必ず必要なメンバ関数、場合
%によっては必要になるメンバ関数について記述する。
Some classes are pre-existing. We first describe these classes. Next,
we describe how to make class Moment, and what member functions are
needed.

%\subsubsection{既存のクラス}
\subsubsection{Pre-existing classes}

%\subsubsubsection{概要}
\subsubsubsection{Summary}

%FDPSはいくつかのMomentクラスを用意している。これらは相互作用ツリークラ
%スで特定のPS::SEARCH\_MODE型を選んだ場合に有効である。以下、各
%PS::SEARCH\_MODE型において選ぶことのできるMoment型を記述する。
%PS::SEARCH\_MODE\_GATHER,
%\\PS::SEARCH\_MODE\_SCATTER,PS::SEARCH\_MODE\_SYMMETRYについては
%Momentクラスを意識してコーディングする必要がないので、これらについては
%記述しない。
There are several pre-existing classes. These classes are available
when some PS::SEARCH\_MODE types are adopted. In the following, we
describe class Moment available when \\ PS::SEARCH\_MODE\_LONG and
PS::SEARCH\_MODE\_LONG\_CUTOFF are adopted. When the other
PS::SEARCH\_MODE are adopted, users need not to program, considering
class Moment.

\subsubsubsection{PS::SEARCH\_MODE\_LONG}
\label{sec:MomentForSearchModeLong}
In the \texttt{Moment} classes described below,
for \texttt{MomentMonopole} and \texttt{MomentQuadrupole},
their equivalents are defined for
\texttt{PS::SEARCH\_MODE\_LONG\_SCATTER} which can be used for the
neighbor search. They are \texttt{MomentMonopoleScatter}
and \texttt{MomentQuadrupoleScatter}, respectively.



\subsubsubsubsection{PS::MomentMonopole}

%単極子までを情報として持つクラス。単極子を計算する際の座標系の中心には
%粒子の重心や粒子電荷の重心を取る。以下、このクラスの概要を記述する。
This class has moment up to monopole. When this moment is calculated,
the center of the coordinate is taken to the center of mass or
charge. In the following, we describe an overview of this class.
\begin{screen}
\begin{verbatim}
namespace ParticleSimulator {
    class MomentMonopole {
    public:
        F32    mass;
        F32vec pos;
    };
}
\end{verbatim}
\end{screen}

\begin{itemize}
%\item クラス名
\item Class name
  PS::MomentMonopole

%\item メンバ変数とその情報
\item Member variables and their information

%  mass: 近傍でまとめた粒子の全質量、または全電荷
  mass: the total mass or charge of particles close to each other.

%  pos: 近傍でまとめた粒子の重心、または粒子電荷の重心
  pos: the center of mass or charge of particles close to each other.

%\item 使用条件
\item Use conditions

%  EssentialParticleJクラス(節\ref{sec:essentialparticlej})がメンバ関数
%  EssentialParticleJ::getChargeとEssentialParticleJ::getPosを持ち、そ
%  れぞれが粒子質量(または粒子電荷)、粒子位置を返すこと。
%  EssentialParticleJクラスのクラス名は変更自由。
  Class EssentialParticleJ (section~\ref{sec:essentialparticlej}) has
  member functions EssentialParticleJ::getCharge and
  EssentialParticleJ::getPos.

  In the case of \texttt{MomentMonopoleScatter},
  class \texttt{EssentialParticleJ} has the member function
  \texttt{getRSearch()}

\end{itemize}


\subsubsubsubsection{PS::MomentQuadrupole}

%単極子と四重極子を情報として持つクラス。これらのモーメントを計算する際
%の座標系の中心には粒子の重心を取る。以下、このクラスの概要を記述する。
This class has moment up to quadrupole. When this moment is
calculated, the center of the coordinate is taken to the center of
mass or charge. In the following, we describe an overview of this
class.
\begin{screen}
\begin{verbatim}
namespace ParticleSimulator {
    class MomentQuadrupole {
    public:
        F32    mass;    
        F32vec pos;
        F32mat quad;
    };
}
\end{verbatim}
\end{screen}

\begin{itemize}
%\item クラス名
\item Class name
  PS::MomentQuadrupole

%\item メンバ変数とその情報
\item Member variables and their information

%  mass: 近傍でまとめた粒子の全質量
  mass: the total mass of particles close to each other.

%  pos: 近傍でまとめた粒子の重心
  pos: the center of mass of particles close to each other.

%  quad: 近傍でまとめた粒子の四重極子
  quad: the quadrupole of mass of particles close to each other.

%\item 使用条件
\item Use conditions

%  EssentialParticleJクラス(節\ref{sec:essentialparticlej})がメンバ関数
%  EssentialParticleJ::getChargeとEssentialParticleJ::getPosを持ち、そ
%  れぞれが粒子質量(または粒子電荷)、粒子位置を返すこと。
%  EssentialParticleJクラスのクラス名は変更自由。
  Class EssentialParticleJ (section~\ref{sec:essentialparticlej}) has
  member functions EssentialParticleJ::getCharge and
  EssentialParticleJ::getPos.

  In the case of \texttt{MomentQuadlepoleScatter},
  class \texttt{EssentialParticleJ} has the member function
  \texttt{getRSearch()}
  
\end{itemize}

\subsubsubsubsection{PS::MomentMonopoleGeometricCenter}

%単極子までを情報として持つクラス。これらのモーメントを計算する際の座標
%系の中心には粒子の幾何中心を取る。以下、このクラスの概要を記述する。
This class has moment up to monopole. When this moment is calculated,
the center of the coordinate is taken to the geometric center of
particles. In the following, we describe an overview of this class.
\begin{screen}
\begin{verbatim}
namespace ParticleSimulator {
    class MomentMonopoleGeometricCenter {
    public:
        F32    charge;    
        F32vec pos;
    };
}
\end{verbatim}
\end{screen}

\begin{itemize}
%\item クラス名
\item Class name
  PS::MomentMonopoleGeometricCenter

%\item メンバ変数とその情報
\item Member variables and their information

%  charge: 近傍でまとめた粒子の全質量、または全電荷
  charge: the total mass or charge of particles close to each other.

%  pos: 近傍でまとめた粒子の幾何中心
  pos: the geometric center of particles close to each other.

%\item 使用条件
\item Use conditions

%  EssentialParticleJクラス(節\ref{sec:essentialparticlej})がメンバ関数
%  EssentialParticleJ::getChargeとEssentialParticleJ::getPosを持ち、そ
%  れぞれが粒子質量(または粒子電荷)、粒子位置を返すこと。
%  EssentialParticleJクラスのクラス名は変更自由。
  Class EssentialParticleJ (section~\ref{sec:essentialparticlej}) has
  member functions EssentialParticleJ::getCharge and
  EssentialParticleJ::getPos.

\end{itemize}

\subsubsubsubsection{PS::MomentDipoleGeometricCenter}

%双極子までを情報として持つクラス。これらのモーメントを計算する際の座標
%系の中心には粒子の幾何中心を取る。以下、このクラスの概要を記述する。
This class has moment up to dipole. When this moment is calculated,
the center of the coordinate is taken to the geometric center of
particles. In the following, we describe an overview of this class.
\begin{screen}
\begin{verbatim}
namespace ParticleSimulator {
    class MomentDipoleGeometricCenter {
    public:
        F32    charge;    
        F32vec pos;
        F32vec dipole;
    };
}
\end{verbatim}
\end{screen}

\begin{itemize}
%\item クラス名
\item Class name

  PS::MomentDipoleGeometricCenter

%\item メンバ変数とその情報
\item Member variables and their information

%  charge: 近傍でまとめた粒子の全質量、または全電荷
  charge: the total mass or charge of particles close to each other.

%  pos: 近傍でまとめた粒子の幾何中心
  pos: the geometric center of particles close to each other.

%  dipole: 粒子の質量または電荷の双極子
  dipole: dipole of particle masses or charges.

%\item 使用条件
\item Use conditions

%  EssentialParticleJクラス(節\ref{sec:essentialparticlej})がメンバ関数
%  EssentialParticleJ::getChargeとEssentialParticleJ::getPosを持ち、そ
%  れぞれが粒子質量(または粒子電荷)、粒子位置を返すこと。
%  EssentialParticleJクラスのクラス名は変更自由。
  Class EssentialParticleJ (section~\ref{sec:essentialparticlej}) has
  member functions EssentialParticleJ::getCharge and
  EssentialParticleJ::getPos.

\end{itemize}

\subsubsubsubsection{PS::MomentQuadrupoleGeometricCenter}

%四重極子までを情報として持つクラス。これらのモーメントを計算する際の座
%標系の中心には粒子の幾何中心を取る。以下、このクラスの概要を記述する。
This class has moment up to quadrupole. When this moment is
calculated, the center of the coordinate is taken to the geometric
center of particles. In the following, we describe an overview of this
class.
\begin{screen}
\begin{verbatim}
namespace ParticleSimulator {
    class MomentQuadrupoleGeometricCenter {
    public:
        F32    charge;    
        F32vec pos;
        F32vec dipole;
        F32mat quadrupole;
    };
}
\end{verbatim}
\end{screen}

\begin{itemize}
%\item クラス名
\item Class name

  PS::MomentQuadrupoleGeometricCenter

%\item メンバ変数とその情報
\item Member variables and their information

%  charge: 近傍でまとめた粒子の全質量、または全電荷
  charge: the total mass or charge of particles close to each other.

%  pos: 近傍でまとめた粒子の幾何中心
  pos: the geometric center of particles close to each other.

%  dipole: 粒子の質量または電荷の双極子
  dipole: dipole of particle masses or charges.

%  quadrupole: 粒子の質量または電荷の四重極子
  quadrupole: quadrupole of particle masses or charges.

%\item 使用条件
\item Use conditions

%  EssentialParticleJクラス(節\ref{sec:essentialparticlej})がメンバ関数
%  EssentialParticleJ::getChargeとEssentialParticleJ::getPosを持ち、そ
%  れぞれが粒子質量(または粒子電荷)、粒子位置を返すこと。
%  EssentialParticleJクラスのクラス名は変更自由。
  Class EssentialParticleJ (section~\ref{sec:essentialparticlej}) has
  member functions EssentialParticleJ::getCharge and
  EssentialParticleJ::getPos.

\end{itemize}

\subsubsubsection{PS::SEARCH\_MODE\_LONG\_CUTOFF}

In the \texttt{Moment} classes described below,
for \texttt{MomentMonopoleCutoff},
its equivalent is defined for
\texttt{PS::SEARCH\_MODE\_LONG\_CUTOFF\_CATTER} which can be used for the
neighbor search. It is  \texttt{MomentMonopoleCutoffScatter}.

\subsubsubsubsection{PS::MomentMonopoleCutoff}

%単極子までを情報として持つクラス。単極子を計算する際の座標系の中心には
%粒子の重心や粒子電荷の重心を取る。以下、このクラスの概要を記述する。
This class has moment up to monopole. When this moment is calculated,
the center of the coordinate is taken to the center of mass or
charge. In the following, we describe an overview of this class.
\begin{screen}
\begin{verbatim}
namespace ParticleSimulator {
    class MomentMonopoleCutoff {
    public:
        F32    mass;
        F32vec pos;
    };
}
\end{verbatim}
\end{screen}

\begin{itemize}
%\item クラス名
\item Class name

  PS::MomentMonopoleCutoff

%\item メンバ変数とその情報
\item Member variables and their information

%  mass: 近傍でまとめた粒子の全質量、または全電荷
  mass: the total mass or charge of particles close to each other.

%  pos: 近傍でまとめた粒子の重心、または粒子電荷の重心
  pos: the center of mass or charge of particles close to each other.

%\item 使用条件
\item Use conditions

%  EssentialParticleJクラス(節\ref{sec:essentialparticlej})がメンバ関数
%  EssentialParticleJ::getCharge, EssentialParticleJ::getPos,
%  EssentialParticleJ::getRSearchを持ち、それぞれが粒子質量(または粒子
%  電荷)、粒子位置、粒子の力の到達距離を返すこと。EssentialParticleJク
%  ラスのクラス名は変更自由。
  Class EssentialParticleJ (section~\ref{sec:essentialparticlej}) has
  member functions EssentialParticleJ::getCharge and
  EssentialParticleJ::getPos.

  In the case of \texttt{MomentMonopoleCutoffScatter},
  class \texttt{EssentialParticleJ} has the member function
  \texttt{getRSearch()}
  
\end{itemize}

%\subsubsection{必要なメンバ関数}
\subsubsection{Necessary member functions}

%\subsubsubsection{概要}
\subsubsubsection{Summary}

%以下ではMomentクラスを定義する際に、必要なメンバ関数を記述する。このと
%きMomentクラスのクラス名をMomとする。これは変更自由である。
In the following, we describe necessary member functions when users
define class Moment. As an example, we use Mom for class Moment
name. This name is mutable.

%\subsubsubsection{コンストラクタ}
\subsubsubsection{Constructor}

\begin{screen}
\begin{verbatim}
class Mom {
public:
    PS::F32    mass;
    PS::F32vec pos;
    Mom () {
        mass = 0.0;
        pos  = 0.0;
    }
};
\end{verbatim}
\end{screen}

\begin{itemize}

\item {\bf Presumptions}

%  Momクラスのメンバ変数mass, posはMomの質量と位置。
  Member variables mass and pos are mass and position information of
  class Mom, respectively.
  
\item {\bf Arguments}

%  なし
  None.
  
\item {\bf Return value}

%  なし
  None.

\item {\bf Behavior}

%  Momクラスのオブジェクトの初期化をする。
  Initialize class Mom object.
  
\item {\bf Remarks}

%  メンバ変数名の変更可能。メンバ変数を加えることも可能。
  The member variable names are mutable. Some member variables can be
  added.

\end{itemize}

\begin{screen}
\begin{verbatim}
class Mom {
public:
    PS::F32    mass;
    PS::F32vec pos;
    Mom(const PS::F32 m,
        const PS::F32vec & p) {
        mass = m;
        pos  = p;
    }
};
\end{verbatim}
\end{screen}

\begin{itemize}

\item {\bf Presumptions}

%  Momクラスのメンバ変数mass, posはMomの質量と位置。
  Member variables mass and pos are mass and position information of
  class Mom, respectively.
  
\item {\bf Arguments}

%  m: 入力。const PS::F32型。質量
  m: input. Type const PS::F32. Mass.

%  p: 入力。const PS::F32vec \&型。位置。
  p: Input. Type const PS::F32vec \&. Position.
  
\item {\bf Return value}

%  なし
  None.

\item {\bf Behavior}

%  Momクラスのオブジェクトの初期化をする。
  Initialize class Mom object.
  
\item {\bf Remarks}

%  メンバ変数名の変更可能。メンバ変数を加えることも可能。
  The member variable names are mutable. Some member variables can be
  added.

\end{itemize}

\subsubsubsection{Mom::init}

\begin{screen}
\begin{verbatim}
class Mom {
public:
    void init();
};
\end{verbatim}
\end{screen}

\begin{itemize}

\item {\bf Presumptions}

%  なし
  None.
  
\item {\bf Arguments}

%  なし
  None.
  
\item {\bf Return value}

%  なし
  None.

\item {\bf Behavior}

%  Momクラスのオブジェクトの初期化をする。
  Initialize class Mom object.
  
\item {\bf Remarks}

%  なし
  None.

\end{itemize}

\subsubsubsection{Mom::getPos}

\begin{screen}
\begin{verbatim}
class Mom {
public:
    PS::F32vec pos;
    PS::F32vec getPos() const {
        return pos;
    }
};
\end{verbatim}
\end{screen}

\begin{itemize}

\item {\bf Presumptions}

%  Momのメンバ変数posは近傍でまとめた粒子の代表位置。このposのデータ 型
%  はPS::F32vecまたはPS::F64vec型。
  A member variable pos is a representative position of particles
  close to each other. This data type is PS::F32vec or PS::F64vec.
  
\item {\bf Arguments}

%  なし
  None.
  
\item {\bf Return value}

%  PS::F32vecまたはPS::F64vec型。Momクラスのメンバ変数pos。
  PS::F32vec or PS::F64vec. The member variable pos.

\item {\bf Behavior}

%  Momクラスのメンバ変数posを返す。
  Return the member variable pos.
  
\item {\bf Remarks}

%  Momクラスのメンバ変数posの変数名は変更自由。
  The member variable name is mutable.

\end{itemize}

\subsubsubsection{Mom::getCharge}

\begin{screen}
\begin{verbatim}
class Mom {
public:
    PS::F32 mass;
    PS::F32 getCharge() const {
        return mass;
    }
};
\end{verbatim}
\end{screen}

\begin{itemize}

\item {\bf Presumptions}

%  Momのメンバ変数massは近傍でまとめた粒子の全質量または全電荷。この
%  massのデータ型はPS::F32またはPS::F64型。
  A member variable mass is the total mass or charge of particles
  close to each other. This data type is PS::F32 or PS::F64.

\item {\bf Arguments}

%  なし
  None.
  
\item {\bf Return value}

%  PS::F32またはPS::F64型。Momクラスのメンバ変数mass。
  Type PS::F32 or PS::F64. The member variable mass.

\item {\bf Behavior}

%  Momクラスのメンバ変数massを返す。
  Return the member variable mass.
  
\item {\bf Remarks}

%  Momクラスのメンバ変数massの変数名は変更自由。
  The member variable name is mutable.

\end{itemize}

\subsubsubsection{Mom::accumulateAtLeaf}

\begin{screen}
\begin{verbatim}
class Mom {
public:
    PS::F32    mass;
    PS::F32vec pos;
    template <class Tepj>
    void accumulateAtLeaf(const Tepj & epj) {
        mass += epj.getCharge();
        pos  += epj.getPos();
    }
};
\end{verbatim}
\end{screen}

\begin{itemize}

\item {\bf Presumptions}

%  Momのメンバ変数massは近傍でまとめた粒子の全質量または全電荷。この
%  massのデータ型はPS::F32またはPS::F64型。Momのメンバ変数posは近傍 で
%  まとめた粒子の代表位置。このposのデータ型はPS::F32vecまたは
%  PS::F64vec型。テンプレート引数TepjにはEssentialParticleJクラスが入り、
%  クラスはメンバ関数getChargeとgetPosを持つ。
  A member variable mass is the total mass or charge of particles
  close to each other. This data type is PS::F32 or PS::F64. A member
  variable pos is a representative position of particles close to each
  other. This data type is PS::F32vec or PS::F64vec. Class
  EssentialParticleJ is inserted into the template argument Tepj, and
  has member functions getCharge and getPos.

\item {\bf Arguments}

%  epj: 入力。const Tepj \&型。Tepjのオブジェクト。
  epj: input. Type const Tepj \&. An object of class Tpj.
  
\item {\bf Return value}

%  なし。
  None.

\item {\bf Behavior}

%  EssentialParticleJクラスのオブジェクトからモーメントを計算する。
  Calculate moment from an object of class EssentialParticleJ.
  
\item {\bf Remarks}

%  Momクラスのメンバ変数mass, posの変数名は変更自由。引数epjの引数名 は
%  変更自由。その他の変数を加えるのも可能。
  The member variable names mass and pos are mutable. The argument
  name epj is mutable.

\end{itemize}

\subsubsubsection{Mom::accumulate}

\begin{screen}
\begin{verbatim}
class Mom {
public:
    PS::F32    mass;
    PS::F32vec pos;
    void accumulate(const Mom & mom) {
        mass += mom.mass;
        pos  += mom.mass * mom.pos;
    }
};
\end{verbatim}
\end{screen}

\begin{itemize}

\item {\bf Presumptions}

%  Momのメンバ変数massは近傍でまとめた粒子の全質量または全電荷。この
%  massのデータ型はPS::F32またはPS::F64型。Momのメンバ変数posは近傍 で
%  まとめた粒子の重心または電荷の重心。このposのデータ型はPS::F32vec ま
%  たはPS::F64vec型。
  A member variable mass is the total mass or charge of particles
  close to each other. This data type is PS::F32 or PS::F64. A member
  variable pos is the center of mass of particles close to each
  other. This data type is PS::F32vec or PS::F64vec. Class
  EssentialParticleJ is inserted into the template argument Tepj, and
  has member functions getCharge and getPos.

\item {\bf Arguments}

%  mom: 入力。const Mom \&型。Momクラスのオブジェクト。
  mom: input. Type const Mom \&. An object of class Mom.
  
\item {\bf Return value}

%  なし。
  None.

\item {\bf Behavior}

%  MomクラスのオブジェクトからさらにMomクラスの情報を計算する。
  Calculate information of class Mom from an object of class Mom.
  
\item {\bf Remarks}

%  Momクラスのメンバ変数mass, posの変数名は変更自由。引数epjの引数名 は
%  変更自由。その他の変数を加えるのも可能。
  The member variable names mass and pos are mutable. The argument
  name epj is mutable.  

\end{itemize}

\subsubsubsection{Mom::set}

\begin{screen}
\begin{verbatim}
class Mom {
public:
    PS::F32    mass;
    PS::F32vec pos;
    void set() {
        pos = pos / mass;
    }
};
\end{verbatim}
\end{screen}

\begin{itemize}

\item {\bf Presumptions}

%  Momのメンバ変数massは近傍でまとめた粒子の全質量または全電荷。この
%  massのデータ型はPS::F32またはPS::F64型。Momのメンバ変数posは近傍 で
%  まとめた粒子の重心または電荷の重心。このposのデータ型はPS::F32vec ま
%  たはPS::F64vec型。
  A member variable mass is the total mass or charge of particles
  close to each other. This data type is PS::F32 or PS::F64. A member
  variable pos is the center of mass of particles close to each
  other. This data type is PS::F32vec or PS::F64vec. Class
  EssentialParticleJ is inserted into the template argument Tepj, and
  has member functions getCharge and getPos.

\item {\bf Arguments}

%  なし
  None.
  
\item {\bf Return value}

%  なし
  None.

\item {\bf Behavior}

%  上記のメンバ関数Mom::accumulateAtLeaf, Mom::accumulateではモー メン
%  トの位置情報の規格化ができていない場合ので、ここで規格化する。
  Normalize position data of moment, since they are not normalized in
  the member functions in Mom::accumulateAtLeaf and Mom::accumulate.
  
\item {\bf Remarks}

%  Momクラスのメンバ変数mass, posの変数名は変更自由。引数epjの引数名 は
%  変更自由。
  The member variable names mass and pos are mutable. The argument
  name epj is mutable.  

\end{itemize}

\subsubsubsection{Mom::accumulateAtLeaf2}

\begin{screen}
\begin{verbatim}
class Mom {
public:
    PS::F32    mass;
    PS::F32vec pos;
    PS::F32mat quad;
    template <class Tepj>
    void accumulateAtLeaf2(const Tepj & epj) {
        PS::F64 ctmp    = epj.getCharge();
        PS::F64vec ptmp = epj.getPos() - pos;
        PS::F64 cx = ctmp * ptmp.x;
        PS::F64 cy = ctmp * ptmp.y;
        PS::F64 cz = ctmp * ptmp.z;
        quad.xx += cx * ptmp.x;
        quad.yy += cy * ptmp.y;
        quad.zz += cz * ptmp.z;
        quad.xy += cx * ptmp.y;
        quad.xz += cx * ptmp.z;
        quad.yz += cy * ptmp.z;
    }
};
\end{verbatim}
\end{screen}

\begin{itemize}

\item {\bf Presumptions}

%  Momのメンバ変数massは近傍でまとめた粒子の全質量または全電荷。この
%  massのデータ型はPS::F32またはPS::F64型。Momのメンバ変数posは近傍でま
%  とめた粒子の代表位置。このposのデータ型はPS::F32vecまたはPS::F64vec
%  型。このposはMom::accumulateAtLeafですでに求めている。Momのメンバ変
%  数quadは近傍でまとめた粒子の四重極子。このquadのデータ型は
%  PS::F32mat またはPS::F64mat型。テンプレート引数Tepjには
%  EssentialParticleJクラス が入り、クラスはメンバ関数getChargeと
%  getPosを持つ。
  A member variable mass is the total mass or charge of particles
  close to each other. This data type is PS::F32 or PS::F64. A member
  variable pos is a representative position of particles close to each
  other. This data type is PS::F32vec or PS::F64vec. This has been
  already obtained in the member function Mom::accumulateAtLeaf. A
  member variable quad is quadrupole of particles close to each
  other. This data type is PS::F32mat or PS::F64mat. Class
  EssentialParticleJ is inserted into the template argument Tepj, and
  has member functions getCharge and getPos.  

\item {\bf Arguments}

%  epj: 入力。const Tepj \&型。Tepjのオブジェクト。
  epj: input. Type const Tepj \&. An object of class Tepj.
  
\item {\bf Return value}

%  なし。
  None.

\item {\bf Behavior}

%  EssentialParticleJクラスのオブジェクトからモーメントを計算する。
  Calculate moment from an object of class EssentialParticleJ.
  
\item {\bf Remarks}

%  Momクラスのメンバ変数mass, pos, quadの変数名は変更自由。引数epjの引
%  数名は変更自由。その他の変数を加えるのも可能。
  The member variable names mass, pos and quad are mutable. The
  argument name epj is mutable.  

\end{itemize}

\subsubsubsection{Mom::accumulate2}

\begin{screen}
\begin{verbatim}
class Mom {
public:
    PS::F32    mass;
    PS::F32vec pos;
    PS::F32mat quad;
    void accumulate(const Mom & mom) {
        PS::F64 mtmp    = mom.mass;
        PS::F64vec ptmp = mom.pos - pos;
        PS::F64 cx = mtmp * ptmp.x;
        PS::F64 cy = mtmp * ptmp.y;
        PS::F64 cz = mtmp * ptmp.z;
        quad.xx += cx * ptmp.x + mom.quad.xx;
        quad.yy += cy * ptmp.y + mom.quad.yy;
        quad.zz += cz * ptmp.z + mom.quad.zz;
        quad.xy += cx * ptmp.y + mom.quad.xy;
        quad.xz += cx * ptmp.z + mom.quad.xz;
        quad.yz += cy * ptmp.z + mom.quad.yz;
    }
};
\end{verbatim}
\end{screen}

\begin{itemize}

\item {\bf Presumptions}

%  Momのメンバ変数massは近傍でまとめた粒子の全質量または全電荷。この
%  massのデータ型はPS::F32またはPS::F64型。Momのメンバ変数posは近傍でま
%  とめた粒子の代表位置。このposのデータ型はPS::F32vecまたはPS::F64vec
%  型。このposはMom::accumulateですでに求めている。Momのメンバ変数quad
%  は近傍でまとめた粒子の四重極子。このquadのデータ型はPS::F32matまたは
%  PS::F64mat型。
  A member variable mass is the total mass or charge of particles
  close to each other. This data type is PS::F32 or PS::F64. A member
  variable pos is a representative position of particles close to each
  other. This data type is PS::F32vec or PS::F64vec. This has been
  already obtained in the member function Mom::accumulate. A member
  variable quad is quadrupole of particles close to each other. This
  data type is PS::F32mat or PS::F64mat.

\item {\bf Arguments}

%  mom: 入力。const Mom \&型。Momクラスのオブジェクト。
  mom: input. Type const Mom \&. An object of class Mom.
  
\item {\bf Return value}

%  なし。
  None.

\item {\bf Behavior}

%  MomクラスのオブジェクトからさらにMomクラスの情報を計算する。
  Calculate information of class Mom from an object of class Mom
  
\item {\bf Remarks}

%  Momクラスのメンバ変数mass, pos, quadの変数名は変更自由。引数epjの引
%  数名は変更自由。その他の変数を加えるのも可能。
  The member variable names mass, pos and quad are mutable.

\end{itemize}

%\subsection{SuperParticleJクラス}
\subsection{Class SuperParticleJ}
\label{sec:example_superparticlej}

%\subsubsection{概要}
\subsubsection{Summary}

%SuperParticleJクラスは近い粒子同士でまとまった複数の粒子を代表してまと
%めた超粒子の情報を持つクラスであり、相互作用の定義(節
%\ref{sec:overview_action}の手順0)に必要となる。このクラスが必要となる
%のはPS::SEARCH\_MODEにPS::SEARCH\_MODE\_LONGまたは
%\\PS::SEARCH\_MODE\_LONG\_CUTOFFを選んだ場合だけである。このクラスのメ
%ンバ関数には、超粒子の位置情報をFDPS側とやりとりするメンバ関数がある。
%また、超粒子の情報とMomentクラスの情報は対になるものである。従って、こ
%のクラスのメンバ関数には、Momentクラスからこのクラスへ情報を変換(また
%はその逆変換)するメンバ関数がある。
Class SuperPrticleJ has information of superparticle which is a
representative of particles close to each other. This is required for
the definition of interaction (procedure 0 in
section~\ref{sec:overview_action}). This class is necessary only when
PS::SEARCH\_MODE\_LONG and \\ PS::SEARCH\_MODE\_LONG\_CUTOFF are
adopted for type PS::SEARCH\_MODE. This class has member functions
communicating position data with FDPS. Information of classes
SuperParticleJ and Moment pairs up. Therefore, this class has member
functions which transform from data of class Moment to that of class
SuperParticleJ, and vice versa.

%SuperParticleJクラスもMomentクラス同様、ある程度決っているものが多いの
%で、それらについてはFDPS側で用意した。以下、既存のクラス、
%SuperParticleJクラスを作るときに必要なメンバ関数、場合によっては必要な
%メンバ関数について記述する。
Some classes are pre-existing. We first describe these classes. Next,
we describe how to make class SuperParticleJ, and what member
functions are needed.

%\subsubsection{既存のクラス}
\subsubsection{Pre-existing classes}

%FDPSはいくつかのSuperParticleJクラスを用意している。以下、各
%PS::SEARCH\_MODEに対し選ぶことのできるクラスについて記述する。まず、
%PS::SEARCH\_MODE\_LONGの場合、次にPS::SEARCH\_MODE\_LONG\_CUTOFFの場合
%について記述する。その他の\\PS::SEARCH\_MODEでは超粒子を必要としない。
There are several pre-existing classes. These classes are available
when some PS::SEARCH\_MODE types are adopted. In the following, we
describe class SuperParticleJ available when \\ PS::SEARCH\_MODE\_LONG
and PS::SEARCH\_MODE\_LONG\_CUTOFF are adopted. When the other
PS::SEARCH\_MODE are adopted, users need not to program, considering
class SuperParticleJ.

\subsubsubsection{PS::SEARCH\_MODE\_LONG}

\subsubsubsubsection{PS::SPJMonopole}

%単極子までの情報を持つMomentクラスPS::MomentMonopoleと対になる
%SuperParticleJクラス。以下、このクラスの概要を記述する。
This class has moment up to monopole, and is paired with class
PS::MomentMonopole. We overview this class as follows.
\begin{screen}
\begin{verbatim}
namespace ParticleSimulator {
    class SPJMonopole {
    public:
        F64    mass;
        F64vec pos;
    };
}
\end{verbatim}
\end{screen}

\begin{itemize}
%\item クラス名
\item Class name
  PS::SPJMonopole

%\item メンバ変数とその情報
\item Member variables and their information

%  mass: 近傍でまとめた粒子の全質量、または全電荷
  mass: the total mass or charge of particles close to each other.

%  pos: 近傍でまとめた粒子の重心、または粒子電荷の重心
  pos: the center of mass or charge of particles close to each other.

%\item 使用条件
\item Use conditions

%  MomentクラスであるPS::MomentMonopoleクラスの使用条件に準ずる。
  The same as class PS::MomentMonopole.

\end{itemize}

\subsubsubsubsection{PS::SPJQuadrupole}

%単極子と四重極子を情報を持つMomentクラスPS::MomentQuadrupoleと対になる
%SuperParticleJクラス。以下、このクラスの概要を記述する。
This class has monopole and quadrupole moments, and is paired with
class PS::MomentQuadrupole. In the following, we describe an overview
of this class.
\begin{screen}
\begin{verbatim}
namespace ParticleSimulator {
    class SPJQuadrupole {
    public:
        F32    mass;
        F32vec pos;
        F32mat quad;
    };
}
\end{verbatim}
\end{screen}

\begin{itemize}
%\item クラス名
\item Class name
  PS::SPJQuadrupole

%\item メンバ変数とその情報
\item Member variables and their information

%  mass: 近傍でまとめた粒子の全質量
  mass: the total mass of particles close to each other.

%  pos: 近傍でまとめた粒子の重心
  pos: the center of mass of particles close to each other.

%  quad: 近傍でまとめた粒子の四重極子
  quad: the quadrupole of mass of particles close to each other.

%\item 使用条件
\item Use conditions

%  MomentクラスであるPS::MomentQuadrupoleクラスの使用条件に準ずる。
  The same as class PS::MomentQuadrupole.

\end{itemize}

\subsubsubsubsection{PS::SPJMonopoleGeometricCenter}

%単極子までを情報として持つ(ただしモーメント計算の際の座標系の中心は粒
%子の幾何中心)MomentクラスPS::MomentMonopoleGeometricCenterと対となる
%SuperParticleJクラス。以下、このクラスの概要を記述する。
This class has moment up to monopole, and is paired with class \\
PS::MomentMonpoleGeometricCenter. In the following, we describe an
overview of this class.
\begin{screen}
\begin{verbatim}
namespace ParticleSimulator {
    class SPJMonopoleGeometricCenter {
    public:
        F32    charge;    
        F32vec pos;
    };
}
\end{verbatim}
\end{screen}

\begin{itemize}
%\item クラス名
\item Class name

  PS::SPJMonopoleGeometricCenter

%\item メンバ変数とその情報
\item Member variables and their information

%  charge: 近傍でまとめた粒子の全質量、または全電荷
  charge: the total mass or charge of particles close to each other.

%  pos: 近傍でまとめた粒子の幾何中心
  pos: the geometric center of particles close to each other.

%\item 使用条件
\item Use conditions

%  PS::MomentMonopoleGeometricCenterの使用条件に準ずる。
  The same as class PS::MomentMonopoleGeometricCenter.

\end{itemize}

\subsubsubsubsection{PS::SPJDipoleGeometricCenter}

%双極子までを情報として持つ(ただしモーメント計算の際の座標系の中心は粒
%子の幾何中心)MomentクラスPS::MomentDipoleGeometricCenterと対となる
%SuperParticleJクラス。以下、このクラスの概要を記述する。
This class has moment up to dipole, and is paired with class
PS::MomentDipoleGeometricCenter. In the following, we describe an
overview of this class.
\begin{screen}
\begin{verbatim}
namespace ParticleSimulator {
    class SPJDipoleGeometricCenter {
    public:
        F32    charge;    
        F32vec pos;
        F32vec dipole;
    };
}
\end{verbatim}
\end{screen}

\begin{itemize}
%\item クラス名
\item Class name

  PS::SPJDipoleGeometricCenter

%\item メンバ変数とその情報
\item Member variables and their information

%  charge: 近傍でまとめた粒子の全質量、または全電荷
  charge: the total mass or charge of particles close to each other.

%  pos: 近傍でまとめた粒子の幾何中心
  pos: the geometric center of particles close to each other.

%  dipole: 粒子の質量または電荷の双極子
  dipole: dipole of particle masses or charges.

%\item 使用条件
\item Use conditions

%  PS::MomentDipoleGeometricCenterの使用条件に準ずる。
  The same as class PS::MomentDipoleGeometricCenter.

\end{itemize}

\subsubsubsubsection{PS::SPJQuadrupoleGeometricCenter}

%四重極子までを情報として持つ(ただしモーメント計算の際の座標系の中心は
%粒子の幾何中心)MomentクラスPS::MomentQuadrupoleGeometricCenterと対とな
%るSuperParticleJクラス。以下、このクラスの概要を記述する。
This class has moment up to quadrupole, and is paired with class \\
PS::MomentQuadrupoleGeometricCenter. In the following, we describe an
overview of this class.
\begin{screen}
\begin{verbatim}
namespace ParticleSimulator {
    class SPJQuadrupoleGeometricCenter {
    public:
        F32    charge;    
        F32vec pos;
        F32vec dipole;
        F32mat quadrupole;
    };
}
\end{verbatim}
\end{screen}

\begin{itemize}
%\item クラス名
\item Class name

  PS::SPJQuadrupoleGeometricCenter

%\item メンバ変数とその情報
\item Member variables and their information

%  charge: 近傍でまとめた粒子の全質量、または全電荷
  charge: the total mass or charge of particles close to each other.

%  pos: 近傍でまとめた粒子の幾何中心
  pos: the geometric center of particles close to each other.

%  dipole: 粒子の質量または電荷の双極子
  dipole: dipole of particle masses or charges.

%  quadrupole: 粒子の質量または電荷の四重極子
  quadrupole: quadrupole of particle masses or charges.

%\item 使用条件
\item Use conditions

%  PS::MomentQuadrupoleGeometricCenterの使用条件に準ずる。
  The same as class PS::MomentQuadrupoleGeometricCenter.

\end{itemize}

\subsubsubsection{PS::SEARCH\_MODE\_LONG\_CUTOFF}

\subsubsubsubsection{PS::SPJMonopoleCutoff}

%単極子までを情報として持つクラスMomentクラスPS::MomentMonopoleCutoffと
%対となるSuperParticleJクラス。以下、このクラスの概要を記述する。
This class has moment up to monopole, and is paired with class
PS::MomentMonopoleCutoff. In the following, we describe an overview of
this class.
\begin{screen}
\begin{verbatim}
namespace ParticleSimulator {
    class SPJMonopoleCutoff {
    public:
        F32    mass;
        F32vec pos;
    };
}
\end{verbatim}
\end{screen}

\begin{itemize}
%\item クラス名
\item Class name

  PS::SPJMonopoleCutoff

%\item メンバ変数とその情報
\item Member variables and their information

%  mass: 近傍でまとめた粒子の全質量、または全電荷
  mass: the total mass or charge of particles close to each other.

%  pos: 近傍でまとめた粒子の重心、または粒子電荷の重心
  pos: the center of mass or charge of particles close to each other.

%\item 使用条件
\item Use conditions

%  PS::MomentMonopoleCutoffの使用条件に準ずる。
  The same as class PS::MomentMonopoleCutoff.

\end{itemize}

%\subsubsection{必要なメンバ関数}
\subsubsection{Necessary member functions}

%\subsubsubsection{概要}
\subsubsubsection{Summary}

%以下ではSuperParticleJクラスを作る際に必要なメンバ関数を記述する。この
%ときSuperParticleJクラスのクラス名をSPJとする。これは変更自由である。
We describe necessary member functions when users make class
SuperParticleJ. We use class SPJ for an example of class
SuperParticleJ. This name is mutable.

\subsubsubsection{SPJ::getPos}

\begin{screen}
\begin{verbatim}
class SPJ {
public:
    PS::F64vec pos;
    PS::F64vec getPos() const {
        return this->pos;
    }
};
\end{verbatim}
\end{screen}

\begin{itemize}

\item {\bf Presumptions}
  
%  SPJのメンバ変数posはある１つの超粒子の位置情報。このposのデータ型は
%  PS::F32vecまたはPS::F64vec型。
  Member variables pos is position information of this class. This
  data type is PS::F32vec or PS::F64vec.
  
\item {\bf Arguments}

%  なし
  None.
  
\item {\bf Return value}

%  PS::F32vec型またはPS::F64vec型。SPJクラスの位置情報を保持したメンバ
%  変数。
  Type PS::F32vec or PS::F64vec. Member variable keeping position data
  of class SPJ.
  
\item {\bf Behavior}

%  SPJクラスの位置情報を保持したメンバ変数を返す。
  Return position data of an object of class SPJ.
  
\item {\bf Remarks}

%  SPJクラスのメンバ変数posの変数名は変更可能。
  The member variable name is mutable.

\end{itemize}

\subsubsubsection{SPJ::setPos}

\begin{screen}
\begin{verbatim}
class SPJ {
public:
    PS::F64vec pos;
    void setPos(const PS::F64vec pos_new) {
        this->pos = pos_new;
    }
};
\end{verbatim}
\end{screen}

\begin{itemize}

\item {\bf Presumptions}
  
%  SPJクラスのメンバ変数posは１つの粒子の位置情報。このposのデータ型は
%  PS::F32vecまたはPS::F64vec。
  A member variable pos is position data of a particle. This data type
  is PS::F32vec or PS::F64vec.

\item {\bf Arguments}

%  pos\_new: 入力。const PS::F32vecまたはconst PS::F64vec型。FDPS側で修
%  正した粒子の位置情報。
  pos\_new: input. Type const PS::F32vec or const PS::F64vec. Position
  modified by FDPS.

\item {\bf Return value}

%  なし。
  None.
  
\item {\bf Behavior}

%  FDPSが修正した粒子の位置情報をSPJクラスの位置情報に書き込む。
  Write position data modified by FDPS to position data of an object
  of class SPJ.

\item {\bf Remarks}

%  SPJクラスのメンバ変数posの変数名は変更可能。メンバ関数SPJ::setPosの
%  引数名pos\_newは変更可能。posとpos\_newのデータ型が異なる場合の動作
%  は保証しない。
  The member variable name is mutable. The argument name is mutable.

\end{itemize}

\subsubsubsection{SPJ::copyFromMoment}

\begin{screen}
\begin{verbatim}
class Mom {
public:
    PS::F32    mass;
    PS::F32vec pos;
}
class SPJ {
public:
    PS::F32    mass;
    PS::F32vec pos;
    void copyFromMoment(const Mom & mom) {
        mass = mom.mass;
        pos  = mom.pos;
    }
};
\end{verbatim}
\end{screen}

\begin{itemize}

\item {\bf Presumptions}

%  なし
  None.
  
\item {\bf Arguments}

%  mom: 入力。const Mom \&型。Momにはユーザー定義またはFDPS側で用意した
%  Momentクラスが入る。
   mom: input. Type const Mom \&. User-defined class Moment.

\item {\bf Return value}

%  なし。
  None.
  
\item {\bf Behavior}

%  Momクラスの情報をSPJクラスにコピーする。
  Copy an object of class Mom to that of class SPJ.

\item {\bf Remarks}

%  Momクラスのクラス名は変更可能。MomクラスとSPJクラスのメンバ変数名は
%  変更可能。メンバ関数SPJ::copyFromMomentの引数名は変更可能。
  Class name Mom is mutable. Member variables of classes Mom and SPJ
  are mutable. The argument name of the function SPJ::copyFromMoment
  is mutable.

\end{itemize}

\subsubsubsection{SPJ::convertToMoment}

\begin{screen}
\begin{verbatim}
class Mom {
public:
    PS::F32    mass;
    PS::F32vec pos;
    Mom(const PS::F32 m,
        const PS::F32vec & p) {
        mass = m;
        pos  = p;
    }
}
class SPJ {
public:
    PS::F32    mass;
    PS::F32vec pos;
    Mom convertToMoment() const {
        return Mom(mass, pos);
    }
};
\end{verbatim}
\end{screen}

\begin{itemize}

\item {\bf Presumptions}

%  なし
  None.
  
\item {\bf Arguments}

%  なし
  None.

\item {\bf Return value}

%  Mom型。Momクラスのコンストラクタ。
  Type Mom. Constructor of class Mom.
  
\item {\bf Behavior}

%  Momクラスのコンストラクタを返す。
  Return the constructor of class Mom.

\item {\bf Remarks}

%  Momクラスのクラス名は変更可能。MomクラスとSPJクラスのメンバ変数名は
%  変更可能。メンバ関数SPJ::copyFromMomentの引数名は変更可能。メンバ関
%  数SPJ::convertToMomentで使用されるMomクラスのコンストラクタが定義さ
%  れている必要がある。
  Class name Mom is mutable. Member variable names of classes Mom and
  SPJ are mutable. The argument name of the function
  SPJ::copyFromMoment is mutable. Pre-definition of the constructor of
  class Mom is necessary.

\end{itemize}

\subsubsubsection{SPJ::clear}

\begin{screen}
\begin{verbatim}
class SPJ {
public:
    PS::F32    mass;
    PS::F32vec pos;
    void clear() {
        mass = 0.0;
        pos  = 0.0;
    }
};
\end{verbatim}
\end{screen}

\begin{itemize}

\item {\bf Presumptions}

%  なし
  None.
  
\item {\bf Arguments}

%  なし
  None.

\item {\bf Return value}

%  なし
  None.
  
\item {\bf Behavior}

%  SPJクラスのオブジェクトの情報をクリアする。
  Clear information of an object of class SPJ.

\item {\bf Remarks}

%  メンバ変数名は変更可能。
  Member variable names are mutable.

\end{itemize}

%\subsection{Forceクラス}
\subsection{Class Force}
\label{sec:example_force}

%\subsubsection{概要}
\subsubsection{Summary}

%Forceクラスは相互作用の結果を保持するクラスであり、相互作用の定義(節
%\ref{sec:overview_action}の手順0)に必要となる。以下、この節の前提、常
%に必要なメンバ関数について記述する。
This class has results of interaction calculations, and is necessary
for the definition of interaction (procedure 0 in
section~\ref{sec:overview_action}). We describe presumptions in this
section, and necessary member functions.

\subsubsection{Presumptions}

%この節で用いる例としてForceクラスのクラス名をResultとする。このクラス
%名は変更自由である。
We use class Result as an example of class Force. This name is
mutable.

%\subsubsection{必要なメンバ関数}
\subsubsection{Necessary member functions}

%常に必要なメンバ関数はResult::clearである。この関数は相互作用の計算結
%果を初期化する。以下、Result::clearについて記述する。
A necessary member function is Result::clear. This function
initializes results of interaction calculations.

\subsubsubsection{Result::clear}

\begin{screen}
\begin{verbatim}
class Result {
public:
    PS::F32vec acc;
    PS::F32    pot;
    void clear() {
        acc = 0.0;
        pot = 0.0;
    }
};
\end{verbatim}
\end{screen}

\begin{itemize}

\item {\bf Presumptions}
  
%  Resultクラスのメンバ変数はaccとpot。
  Member variables are acc and pot.
  
\item {\bf Arguments}

%  なし
  None.
  
\item {\bf Return value}

%  なし。
  None.
  
\item {\bf Behavior}

%  Resultクラスのメンバ変数を初期化する。
  Initialize member variables.
  
\item {\bf Remarks}

%  Resultクラスのメンバ変数acc, potの変数名は変更可能。他のメンバ変数を
%  加えることも可能。
  The member variable names are mutable.

\end{itemize}

%\subsection{ヘッダクラス}
\subsection{Class Header}
\label{sec:example_userdefined_header}

%\subsubsection{概要}
\subsubsection{Summary}

%ヘッダクラスは入出力ファイルのヘッダの形式を決めるクラスである。ヘッダ
%クラスはFDPSが提供する粒子群クラスのファイル入出力APIを使用し、かつ入
%出力ファイルにヘッダを含ませたい場合に必要となるクラスである。粒子群ク
%ラスのファイル入出力APIとは、
%ParticleSystem::readParticleAscii,ParticleSystem::writeParticleAscii,
%である。以下、この節における前提と、これらのAPIを使用する際に必要とな
%るメンバ関数とその記述の規定を述べる。この節において、常に必要なメンバ
%関数というものは存在しない。
Class Header defines a format of a header of I/O files. This class is
used in file I/O APIs of class ParticleSystem. These APIs are
ParticleSystem::readParticleAscii and
ParticleSystem::writeParticleAscii. We present presumptions in this
section and member functions necessary when users use these APIs.

\subsubsection{Presumptions}

%この節では、ヘッダクラスのクラス名をHdrとする。このクラス名は変更可能
%である。
We use class Hdr as an example of class Header. This name is mutable.

%\subsubsection{場合によっては必要なメンバ関数}
\subsubsection{Member functions necessary for some situations}

\subsubsubsection{Hdr::readAscii}

\begin{screen}
\begin{verbatim}
class Hdr {
public:
    PS::S32 nparticle;
    PS::F64 time;
    PS::S32 readAscii(FILE *fp) {
        fscanf(fp, "%d%lf", &this->nparticle, &this->time);
        return this->nparticle;
    }
};
\end{verbatim}
\end{screen}

\begin{itemize}

\item {\bf Presumptions}

%  このヘッダは粒子数、時刻の情報を持つ。これらのメンバ変数はそれぞれ
%  nparticleとtimeである。
  This header has the number of particles ``nparticle'' and time
  ``time''.

\item {\bf Arguments}

%  fp: 入力。FILE *型。粒子データの入力ファイルを指すファイルポインタ。
  fp: input. Type FILE *. File pointer to an input file.
  
\item {\bf Return value}

%  PS::S32型。粒子数の情報を返す。ヘッダに粒子数の情報がない場合は-1を
%  返す。
  Type PS::S32. Return the number of particles, and return -1 unless
  there is the number of particles in the header.
  
\item {\bf Behavior}

%  粒子データの入力ファイルからヘッダ情報を読みこむ。
  Read the header information from the input file of particle data.
  
\item {\bf Remarks}

%  メンバ変数名は入力ファイルに合わせて変更可能。返値に粒子数の情報を指
%  定しない場合、または-1を指定しない場合の動作は保証しない。
  The member variable names are mutable. It is undefined when the
  return value is neither the number of particles and -1.
  
\end{itemize}

\subsubsubsection{Hdr::writeAscii}

\begin{screen}
\begin{verbatim}
class Hdr {
public:
    PS::S32 nparticle;
    PS::F64 time;
    void writeAscii(FILE *fp) {
        fprintf(fp, "%d %lf", this->nparticle, this->time);
    }
};
\end{verbatim}
\end{screen}

\begin{itemize}

\item {\bf Presumptions}

%  このヘッダは粒子数、時刻の情報を持つ。これらのメンバ変数はそれぞれ
%  nparticleとtimeである。
  This header has the number of particles ``nparticle'' and time
  ``time''.

\item {\bf Arguments}

%  fp: 入力。FILE *型。粒子データの出力ファイルを指すファイルポインタ。
  fp: input. Type FILE *. File pointer to an output file.
  
\item {\bf Return value}

%  なし。
  None.
  
\item {\bf Behavior}

%  粒子データの出力ファイルへヘッダ情報を書き込む。
  Write the header information to the output file.
  
\item {\bf Remarks}

%  メンバ変数名は出力ファイルに合わせて変更可能。
  The member variable names are mutable.
  
\end{itemize}

%\subsection{関数オブジェクトcalcForceEpEp}
\subsection{Function object calcForceEpEp}
\label{sec:example_userdefined_calcForceEpEp}

%\subsubsection{概要}
\subsubsection{Summary}

%関数オブジェクトcalcForceEpEpは粒子同士の相互作用を記述するものであり、
%相互作用の定義(節\ref{sec:overview_action}の手順0)に必要となる。以下、
%これの書き方の規定を記述する。
Function object calcForceEpEp presents an interaction, and is
necessary for the definition of the interaction (procedure 0 in
section \ref{sec:overview_action}). In what follows, we describe how
to describe this.

\subsubsection{Presumptions}

%ここで示すのは重力N体シミュレーションの粒子間相互作用の記述の仕方であ
%る。関数オブジェクトcalcForceEpEpの名前はgravityEpEpとする。これは変更
%自由である。また、EssentialParitlceIクラスのクラス名を
%EPI,EssentialParitlceJクラスのクラス名をEPJ, Forceクラスのクラス名を
%Resultとする。
We show the function object for calculating gravitational $N$-body
simulation. The object name is gravityEpEp, and is mutable. We use
classes EPI and EPJ for classes EssentialParitlceI and
EssentialParitlceJ, respectively.

\subsubsection{gravityEpEp::operator ()}

\begin{lstlisting}[caption=calcForceEpEp]
class Result {
public:
    PS::F32vec acc;
};
class EPI {
public:
    PS::S32    id;
    PS::F32vec pos;
};
class EPJ {
public:
    PS::S32    id;
    PS::F32    mass;
    PS::F32vec pos;
};
struct gravityEpEp {
    static PS::F32 eps2;
    void operator () (const EPI *epi,
                      const PS::S32 ni,
                      const EPJ *epj,
                      const PS::S32 nj,
                      Result *result) {

        for(PS::S32 i = 0; i < ni; i++) {
            PS::S32    ii = epi[i].id;
            PS::F32vec xi = epi[i].pos;
            PS::F32vec ai = 0.0;
            for(PS::S32 j = 0; j < nj; j++) {
                PS::S32    jj = epj[j].id;
                PS::F32    mj = epj[j].mass;
                PS::F32vec xj = epj[j].pos;

                PS::F32vec dx   = xi - xj;
                PS::F32    r2   = dx * dx + eps2;
                PS::F32    rinv = (ii != jj) ? 1. / sqrt(r2)
                                             : 0.0;

                ai += mj * rinv * rinv * rinv * dx;
            }
            result.acc = ai;
        }
    }
};
PS::F32 gravityEpEp::eps2 = 9.765625e-4;
\end{lstlisting}

\begin{itemize}

\item {\bf Presumptions}

%  クラスResult, EPI, EPJに必要なメンバ関数は省略した。クラスResultのメ
%  ンバ変数accはi粒子がj粒子から受ける重力加速度である。クラスEPIとEPJ
%  のメンバ変数idとposはそれぞれの粒子IDと粒子位置である。クラスEPJのメ
%  ンバ変数massはj粒子の質量である。関数オブジェクトgravityEpEpのメンバ
%  変数eps2は重力ソフトニングの2乗である。ここの外側でスレッド並列になっ
%  ているため、ここでOpenMPを記述する必要はない。
  Member functions necessary for classes Result, EPI, and EPJ are
  omitted. A member variable acc in class Result is gravitational
  acceleration from $j$-particle to $i$-particle. Member variables id
  and pos in classes EPI and EPJ are particle ID and position,
  respectively. A member variable mass in class EPJ is mass of
  $j$-particle. A member variable eps2 in function object gravityEpEp
  is square of gravitational softening. Users need not to consider
  multi-threading, since multi-threading is defined outside this
  function object.

\item {\bf Arguments}

%  epi: 入力。const EPI *型またはEPI *型。i粒子情報を持つ配列。
  epi: input. Type const EPI * or EPI *. Array of $i$-particle data.

%  ni: 入力。const PS::S32型またはPS::S32型。i粒子数。
  ni: input. Type const PS::S32 or PS::S32. The number of
  $i$-particles.

%  epj: 入力。const EPJ *型またはEPJ *型。j粒子情報を持つ配列。
  epj: input. Type const EPJ * or EPJ *. Array of $j$-particle data.
  
%  nj: 入力。const PS::S32型またはPS::S32型。j粒子数。
  nj: input. Type const PS::S32 or PS::S32. The number of
  $j$-particles.

%  result: 出力。Result *型。i粒子の相互作用結果を返す配列。
  result: output. Type Result *. Array of results of interactions of
  $i$-particles.

\item {\bf Return value}

%  なし。
  None.
  
\item {\bf Behavior}

%  j粒子からi粒子への作用を計算する。
  Calculate forces exerted by $j$-particles on $i$-particles.
  
\item {\bf Remarks}

%  引数名すべて変更可能。関数オブジェクトの内容などはすべて変更可能。
  All the argument names are mutable. The contents of the function
  object are mutable.
  
\end{itemize}

%\subsection{関数オブジェクトcalcForceSpEp}
\subsection{Function object calcForceSpEp}
\label{sec:example_userdefined_calcForceSpEp}

%\subsubsection{概要}
\subsubsection{Summary}

%関数オブジェクトcalcForceSpEpは超粒子から粒子への作用を記述するもので
%あり、相互作用の定義(節\ref{sec:overview_action}の手順0)に必要となる。
%以下、これの書き方の規定を記述する。
Function object calcForceSpEp presents forces exerted by
superparticles on particles, and is necessary for the definition of
the interaction (procedure 0 in section \ref{sec:overview_action}). In
what follows, we describe how to describe this.

\subsubsection{Presumptions}

%ここで示すのは重力N体シミュレーションにおける超粒子から粒子への作用の
%記述の仕方である。超粒子は単極子までの情報で作られているものとする。関
%数オブジェクトcalcForceSpEpの名前はgravitySpEpとする。これは変更自由で
%ある。また、EssentialParitlceIクラスのクラス名をEPI, SuperParitlceJク
%ラスのクラス名をSPJ, Forceクラスのクラス名をResultとする。
We show the function object for calculating gravitational $N$-body
simulation. The object name is gravitySpEp, and is mutable. We use
classes EPI and SPJ for classes EssentialParitlceI and SuperParitlceJ,
respectively.

\subsubsection{gravitySpEp::operator ()}

\begin{lstlisting}[caption=calcForceSpEp]
class Result {
public:
    PS::F32vec accfromspj;
};
class EPI {
public:
    PS::S32    id;
    PS::F32vec pos;
};
class SPJ {
public:
    PS::F32    mass;
    PS::F32vec pos;
};
struct gravitySpEp {
    static PS::F32 eps2;
    void operator () (const EPI *epi,
                      const PS::S32 ni,
                      const SPJ *spj,
                      const PS::S32 nj,
                      Result *result) {
                      
        for(PS::S32 i = 0; i < ni; i++) {
            PS::F32vec xi = epi[i].pos;
            PS::F32vec ai = 0.0;
            for(PS::S32 j = 0; j < nj; j++) {
                PS::F32    mj = spj[j].mass;
                PS::F32vec xj = spj[j].pos;

                PS::F32vec dx   = xi - xj;
                PS::F32    r2   = dx * dx + eps2;
                PS::F32    rinv = 1. / sqrt(r2);

                ai += mj * rinv * rinv * rinv * dx;
            }
            result.accfromspj = ai;
        }
    }
};
PS::F32 gravitySpEp::eps2 = 9.765625e-4;
\end{lstlisting}

\begin{itemize}

\item {\bf Presumptions}

%  クラスResult, EPI, SPJに必要なメンバ関数は省略した。クラスResultのメ
%  ンバ変数accfromspjはi粒子が超粒子から受ける重力加速度である。クラス
%  EPIとSPJのメンバ変数posはそれぞれの粒子位置である。クラスSPJのメンバ
%  変数massは超粒子の質量である。ファンクタgravitySpEpのメンバ変数eps2
%  は重力ソフトニングの2乗である。ここの外側でスレッド並列になっている
%  ため、ここでOpenMPを記述する必要はない。
  Member functions necessary for classes Result, EPI, and SPJ are
  omitted. A member variable accfromspj in class Result is
  gravitational acceleration from superparticle to
  $i$-particle. Member variables pos in classes EPI and SPJ are
  particle position. A member variable mass in class SPJ is mass of
  superparticle. A member variable eps2 in function object gravitySpEp
  is square of gravitational softening. Users need not to consider
  multi-threading, since multi-threading is defined outside this
  function object.

\item {\bf Arguments}

%  epi: 入力。const EPI *型またはEPI *型。i粒子情報を持つ配列。
  epi: input. Type const EPI * or EPI *. Array of $i$-particle data.

%  ni: 入力。const PS::S32型またはPS::S32型。i粒子数。
  ni: input. Type const PS::S32 or PS::S32. The number of
  $i$-particles.

%  spj: 入力。const SPJ *型またはSPJ *型。超粒子情報を持つ配列。
  spj: input. Type const SPJ * or SPJ *. Array of superparticle data.
  
%  nj: 入力。const PS::S32型またはPS::S32型。超粒子数。
  nj: input. Type const PS::S32 or PS::S32. The number of
  superparticles.

%  result: 出力。Result *型。i粒子の相互作用結果を返す配列。
  result: output. Type Result *. Array of results of interactions of
  $i$-particles.

\item {\bf Return value}

%  なし。
  None.
  
\item {\bf Behavior}

%  超粒子からi粒子への作用を計算する。
  Calculate forces exerted by superparticles on $i$-particles.
  
\item {\bf Remarks}

%  引数名すべて変更可能。関数オブジェクトの内容などはすべて変更可能。
  All the argument names are mutable. The contents of the function
  object are mutable.
  
\end{itemize}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\subsection{関数オブジェクトcalcForceDispatch}
\subsection{Functor calcForceDispatch}
\label{sec:example_userdefined_calcForceDispatch}

%\subsubsection{概要}
\subsubsection{Summary}

%% 関数オブジェクトcalcForceDispatchは相互作用計算にアクセラレータを使う
%% 場合に用いられ、粒子をアクセラレータに送り、相互作用カーネルを発行する。
%% 以下、これの書き方の規定を記述する。

Functor {\tt calcForceDispatch} is used in the case when some
accelerator hardware is used for the interaction calculation.
It sends the particles to the acclerator and startup the interaction
calculation kernel on the accelator. In the following, we present an
example implementattion of this function.

%\subsubsection{前提}
\subsubsection{Premises}

%% ここで示すのは重力N体シミュレーションにおける相互作用をcudaを用いて記
%% 述する方法である。関数オブジェクトcalcForceDispatchの名前は
%% CalcForceDispatchとする。これは変更自由である。また、
%% EssentialParitlceIクラスのクラス名をEPI, SuperParitlceJクラスのクラス
%% 名をSPJ, Forceクラスのクラス名をResultとする。


Here we present one example of using Cuda to implement gravitational
interaction between particles.  The name of functor {\tt
  calcForceDispatch} is {\tt CalcForceDispatch}. The names for classes
{\tt EssentialParitlceI},  {\tt SuperParitlceJ}, and 
{\tt Force} are {\tt EPI}, {\tt SPJ}, and {\tt Result}, respectively.
These name can be changed to any names legal within C++ grammer.


%\subsubsection{例}
\subsubsection{The example}

\begin{lstlisting}[caption=calcForceDispatch]

class EpiGPU{
public:
    float2 pos[3];
    int id_walk;
};

class EpjGPU{
public:
    float mass;
    float2 pos[3];
};

class ForceGPU{
public:
    float2 acc[3];
    float2 pot;
};
  
__global__ void ForceKernel(const EpiGPU * epi,
                            const EpjGPU * epj, 
                            const int    * nj_disp,
                            ForceGPU     * force,
                            const float eps2){
    int id_i = blockDim.x * blockIdx.x + threadIdx.x;
    const EpiGPU & ip = epi[id_i];
    float2 poti;
    float2 acci[3];
    poti = acci[0] = acci[1] = acci[2] = make_float2(0.0, 0.0);
    const int j_head = nj_disp[ip.id_walk];
    const int j_tail = nj_disp[ip.id_walk+1];
    const int nj = j_tail - j_head;
    for(int j=j_head; j<j_tail; j++){
        EpjGPU jp = epj[j];
        const float dx = (jp.pos[0].x - ip.pos[0].x) + (jp.pos[0].y - ip.pos[0].y);
        const float dy = (jp.pos[1].x - ip.pos[1].x) + (jp.pos[1].y - ip.pos[1].y);
        const float dz = (jp.pos[2].x - ip.pos[2].x) + (jp.pos[2].y - ip.pos[2].y);
        const float r2 = ((eps2 + dx*dx) + dy*dy) + dz*dz;
        const float r_inv = rsqrtf(r2);
        const float pij = jp.mass * r_inv * (r2 > eps2); 
        const float r2_inv = r_inv * r_inv; 
        const float pij_r3_inv = pij * r2_inv; 
        const float ax = pij_r3_inv * dx; 
        const float ay = pij_r3_inv * dy;
        const float az = pij_r3_inv * dz;
        poti = float2_accum(poti, pij);
        acci[0] = float2_accum(acci[0], ax);
        acci[1] = float2_accum(acci[1], ay);
        acci[2] = float2_accum(acci[2], az);
    }
    poti = float2_regularize(poti);
    acci[0] = float2_regularize(acci[0]);
    acci[1] = float2_regularize(acci[1]);
    acci[2] = float2_regularize(acci[2]);
    force[id_i].pot = poti;
    force[id_i].acc[0] = acci[0];
    force[id_i].acc[1] = acci[1];
    force[id_i].acc[2] = acci[2];
}

static ForceGPU * force_d;
static ForceGPU * force_h;
static EpiGPU * epi_d;
static EpiGPU * epi_h;
static EpjGPU * epj_d;
static EpjGPU * epj_h;
static int * ni_disp_h;
static int * nj_disp_d;
static int * nj_disp_h;

int DispatchKernelWithSP(const PS::S32 tag,
                         const int    n_walk,
                         const EPIGrav ** epi,
                         const int  *  n_epi,
                         const EPJGrav ** epj,
                         const int  *  n_epj,
                         const PS::SPJMonopole ** spj,
                         const int  *  n_spj){
    static bool first = true;
    assert(n_walk <= N_WALK_LIMIT);
    if(first){
        CUDA_SAFE_CALL( cudaMalloc(     (void**)&nj_disp_d,  (N_WALK_LIMIT+1)*sizeof(int) ) );
        CUDA_SAFE_CALL( cudaMallocHost( (void**)&ni_disp_h,  (N_WALK_LIMIT+1)*sizeof(int) ) );
        CUDA_SAFE_CALL( cudaMallocHost( (void**)&nj_disp_h,  (N_WALK_LIMIT+1)*sizeof(int) ) );
        CUDA_SAFE_CALL( cudaMalloc( (void**)&epi_d,       NI_LIMIT*sizeof(EpiGPU) ) );
        CUDA_SAFE_CALL( cudaMalloc( (void**)&epj_d,       NJ_LIMIT*sizeof(EpjGPU) ) );
        CUDA_SAFE_CALL( cudaMalloc( (void**)&force_d,     NI_LIMIT*sizeof(ForceGPU) ) );
        CUDA_SAFE_CALL( cudaMallocHost( (void**)&epi_h,   NI_LIMIT*sizeof(EpiGPU) ) );
        CUDA_SAFE_CALL( cudaMallocHost( (void**)&epj_h,   NJ_LIMIT*sizeof(EpjGPU) ) );
        CUDA_SAFE_CALL( cudaMallocHost( (void**)&force_h, NI_LIMIT*sizeof(ForceGPU) ) );
        first = false;
    }
    const float eps2 = EPIGrav::eps * EPIGrav::eps;
    ni_disp_h[0] = nj_disp_h[0] = 0;
    for(int i=0; i<n_walk; i++){
        ni_disp_h[i+1] = ni_disp_h[i] + n_epi[i];
        nj_disp_h[i+1] = nj_disp_h[i] + n_epj[i] + n_spj[i];
    }
    int ni_tot = ni_disp_h[n_walk];
    const int ni_tot_reg = ni_disp_h[n_walk] + ( (ni_tot%N_THREAD_GPU != 0) ? (N_THREAD_GPU - (ni_tot%N_THREAD_GPU)) : 0);
    assert(ni_tot_reg <= NI_LIMIT);
    assert(nj_disp_h[n_walk] <= NJ_LIMIT);
    ni_tot = 0;
    int nj_tot = 0;
    for(int iw=0; iw<n_walk; iw++){
        for(int ip=0; ip<n_epi[iw]; ip++){
            epi_h[ni_tot].pos[0]  = float2_split(epi[iw][ip].pos.x);
            epi_h[ni_tot].pos[1]  = float2_split(epi[iw][ip].pos.y);
            epi_h[ni_tot].pos[2]  = float2_split(epi[iw][ip].pos.z);
            epi_h[ni_tot].id_walk = iw;
            force_h[ni_tot].acc[0] = force_h[ni_tot].acc[1] 
                = force_h[ni_tot].acc[2] = force_h[ni_tot].pot = make_float2(0.0, 0.0);
            ni_tot++;
        }
        for(int jp=0; jp<n_epj[iw]; jp++){
            epj_h[nj_tot].mass    = epj[iw][jp].mass;
            epj_h[nj_tot].pos[0]  = float2_split(epj[iw][jp].pos.x);
            epj_h[nj_tot].pos[1]  = float2_split(epj[iw][jp].pos.y);
            epj_h[nj_tot].pos[2]  = float2_split(epj[iw][jp].pos.z);
            nj_tot++;
        }
        for(int jp=0; jp<n_spj[iw]; jp++){
            epj_h[nj_tot].mass    = spj[iw][jp].getCharge();
            epj_h[nj_tot].pos[0]  = float2_split(spj[iw][jp].getPos().x);
            epj_h[nj_tot].pos[1]  = float2_split(spj[iw][jp].getPos().y);
            epj_h[nj_tot].pos[2]  = float2_split(spj[iw][jp].getPos().z);
            nj_tot++;
        }
    }
    for(int ip=ni_tot; ip<ni_tot_reg; ip++){
        epi_h[ni_tot].pos[0]  = epi_h[ni_tot].pos[1]  = epi_h[ni_tot].pos[2]  = make_float2(0.0, 0.0);
        epi_h[ni_tot].id_walk = 0;
        force_h[ni_tot].acc[0] = force_h[ni_tot].acc[1] 
            = force_h[ni_tot].acc[2] = force_h[ni_tot].pot = make_float2(0.0, 0.0);
    }
    CUDA_SAFE_CALL( cudaMemcpy(epi_d, epi_h, ni_tot_reg*sizeof(EpiGPU), cudaMemcpyHostToDevice) );
    CUDA_SAFE_CALL( cudaMemcpy(epj_d, epj_h, nj_tot*sizeof(EpjGPU), cudaMemcpyHostToDevice) );
    CUDA_SAFE_CALL( cudaMemcpy(nj_disp_d, nj_disp_h, (n_walk+1)*sizeof(int), cudaMemcpyHostToDevice) );
    const int n_grid = ni_tot_reg/N_THREAD_GPU + ((ni_tot_reg%N_THREAD_GPU == 0) ? 0 : 1);
    dim3 size_grid(n_grid, 1, 1);
    dim3 size_thread(N_THREAD_GPU, 1, 1);
    ForceKernel<<<size_grid, size_thread>>> (epi_d, epj_d, nj_disp_d, force_d, float(eps2));

    return 0;
}
\end{lstlisting}

\begin{itemize}

%% \item {\bf 引数}

%%   tag: 入力。const PS::S32型。対応するCalcForceRetrieve()のtag番号と一
%%   致させる必要がある。
  
%%   nwalk: 入力。const PS::S32型。マルチウォークにより作成する相互作用リ
%%   ストの数。
  
%%   epi: 入力。const EPI** 型またはEPI** 型。i粒子情報を持つ配列。

%%   ni: 入力。const PS::S32* 型またはPS::S32* 型。i粒子数。

%%   spj: 入力。const EPJ** 型またはEPJ** 型。超粒子情報を持つ配列。
  
%%   nj: 入力。const PS::S32* 型またはPS::S32* 型。超粒子数。

%% \item {\bf 返値}

%%   正常終了ならば0、それ以外の場合は0以外の値を返す。
  
%% \item {\bf 機能}

%%   epi,epjをアクセラレータに送り、アクセラレータ上で相互作用計算を行わ
%%   せる。
  
%% \item {\bf 備考}

%%   引数名すべて変更可能。関数オブジェクトの内容などはすべて変更可能。

\item {\bf Arguments}

  {\tt tag}: input. Type {\tt const PS::S32}. Corresponding call to {\tt
    CalcForceRetrieve()} should use the same value for {\tt tag}
  
  {\tt nwalk}: input.Type {\tt const PS::S32}. The number of
  interaction lists. 
  
  {\tt epi:} input. Type {\tt const EPI**} or {\tt EPI**}. Array of
  the array of i-particles.

  {\tt ni:} input. Type {\tt const PS::S32*} or {\tt PS::S32*}. Array
  of the numbers of i-particles.

  {\tt spj:} input. Type {\tt const EPJ**} or {\tt EPJ**}. Array of
  the array of j-particles.
  
  {\tt nj:} input. Type {\tt const PS::S32*} or {\tt PS::S32*}. Array
  of the number of j-paricles.

\item {\bf return value}
   Returns 0 upon normal completion. Otherwize non-zero values are returned.
  
\item {\bf Function}

  Send {\tt epi} and {\tt epj} to the accelerator and let the
  accelerator do the interaction calculation.
  
\item {\bf Remarks}

    All the argument names are mutable. The contents of the function
  object are mutable.

  
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\subsection{関数オブジェクトcalcForceRetrieve}
\subsection{Functor calcForceRetrieve}
\label{sec:example_userdefined_calcForceRetrieve}

%\subsubsection{概要}
\subsubsection{Summary}

%% 関数オブジェクトcalcForceRetrieveはアクセラレータで計算された結果を回
%% 収する関数である。以下、これの書き方の規定を記述する。
Functor  {\tt calcForceRetrieve} retrieves the results calculated on
the accelerator. 
In the following, we present an
example implementattion of this function.

%\subsubsection{前提}
\subsubsection{Premises}

%% ここで示すのは重力N体シミュレーションにおける相互作用をcudaを用いて記
%% 述する方法である。関数オブジェクトcalcForceRetrieveの名前は
%% RetieveKernelとする。これは変更自由である。また、Forceクラスのクラス名
%% をForceGravとする。

Here we present one example of using Cuda to implement gravitational
interaction between particles.  The name of functor {\tt
  calcForceRetrieve} is {\tt RetieveKernel}. The name for the class
{\tt Force} is  {\tt ForceGrav}.
These name can be changed to any names legal within C++ grammer.


\begin{lstlisting}[caption=calcForceRetrieve]
int RetrieveKernel(const PS::S32 tag,
                   const PS::S32    n_walk,
                   const PS::S32 *  ni,
                   ForceGrav     ** force){
    int ni_tot = 0;
    for(int i=0; i<n_walk; i++){
        ni_tot += ni[i];
    }
    CUDA_SAFE_CALL( cudaMemcpy(force_h, force_d,      ni_tot*sizeof(ForceGPU), cudaMemcpyDeviceToHost) );
    int n_cnt = 0;
    for(int iw=0; iw<n_walk; iw++){
        for(int ip=0; ip<ni[iw]; ip++){
            force[iw][ip].acc.x = (double)force_h[n_cnt].acc[0].x + (double)force_h[n_cnt].acc[0].y;
            force[iw][ip].acc.y = (double)force_h[n_cnt].acc[1].x + (double)force_h[n_cnt].acc[1].y;
            force[iw][ip].acc.z = (double)force_h[n_cnt].acc[2].x + (double)force_h[n_cnt].acc[2].y;
            force[iw][ip].pot   = (double)force_h[n_cnt].pot.x    + (double)force_h[n_cnt].pot.y;
            force[iw][ip].pot *= -1.0;
            n_cnt++;
        }
    }
    return 0;
}

\end{lstlisting}

\begin{itemize}

%% \item {\bf 引数}

%%   tag: 入力。const PS::S32型。対応するCalcForceDispatch()のtag番号と一
%%   致させる必要がある。
  
%%   nwalk: 入力。const PS::S32型。マルチウォークにより作成する相互作用リ
%%   ストの数。
  
%%   ni: 入力。const PS::S32* 型またはPS::S32* 型。i粒子数。

%%   force: 入力。Result** 型。
  
%% \item {\bf 返値}

%%   正常終了ならば0、それ以外の場合は0以外の値を返す。
  
%% \item {\bf 機能}

%%   calcForceDispachで計算された結果をforceに格納する。
  
%% \item {\bf 備考}

%%   引数名すべて変更可能。関数オブジェクトの内容などはすべて変更可能。

\item {\bf Arguments}

  {\tt tag}: input. Type {\tt const PS::S32}. Corresponding call to {\tt
    CalcForceDispatch()} should use the same value for {\tt tag}
  
  {\tt nwalk}: input.Type {\tt const PS::S32}. The number of
  interaction lists. 
  

  {\tt ni:} input. Type {\tt const PS::S32*} or {\tt PS::S32*}. Array
  of the numbers of i-particles.

  {\tt force:} output. Type {\tt Result**}. 
  
\item {\bf return value}
   Returns 0 upon normal completion. Otherwize non-zero values are returned.
  
\item {\bf Function}

  Store the results calculated on the accielerator to the array {\tt
    force}.

\item {\bf Remarks}

    All the argument names are mutable. The contents of the function
  object are mutable.

  
\end{itemize}

