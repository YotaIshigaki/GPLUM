\documentclass[12pt,a4paper]{jarticle}%\topmargin=-5mm\oddsidemargin=-5mm\evensidemargin=-5mm\textheight=235mm\textwidth=165mm%\title{FDPS並列版実装記述書}\author{粒子系シミュレータ研究チーム}\date{}%\pagestyle{empty}\usepackage{graphicx}\usepackage{wrapfig}\usepackage{lscape}\usepackage{amssymb}\usepackage{amsmath}\usepackage{bm}\usepackage{setspace}\usepackage{listings,jlisting}\usepackage{color}\usepackage{ascmac}\usepackage{here}\usepackage[dvipdfmx]{hyperref}\usepackage{pxjahyper}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\setcounter{secnumdepth}{8}\makeatletter\newcommand{\subsubsubsection}{\@startsection{paragraph}{4}{\z@}%{1.5\baselineskip \@plus.5\dp0 \@minus.2\dp0}%{.5\baselineskip \@plus2.3\dp0}%{\reset@font\normalsize\bfseries}}\newcommand{\subsubsubsubsection}{\@startsection{subparagraph}{5}{\z@}%{1.5\baselineskip \@plus.5\dp0 \@minus.2\dp0}%{.5\baselineskip \@plus2.3\dp0}%{\reset@font\normalsize\bfseries}}\makeatother\setcounter{tocdepth}{5}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\newcommand{\underbold}[1]{\underline{\bf #1}}\newcommand{\redtext}[1]{\textcolor{red}{#1}}%\twocolumn%\setstretch{1.5}\lstset{language = C,numbers = left,numbersep = 8pt,breaklines = true,breakindent = 40pt,frame = lines,basicstyle = \ttfamily,}\begin{document}\maketitle\tableofcontents\newpage%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\section{変更記録}\begin{itemize}\item 2014/09/01 作成\item 2014/09/23 「リアル粒子のサンプル」が領域クラスに属することに決定.  境界条件を考慮した動作概略の記述. コーディング規約の記述.\item 2014/09/30 「リアル粒子のサンプル」が粒子群クラスへ移動. 境界条件  を考慮した動作概略の記述を整理. \item 2014/09/30 詳細記述のファイル入力、粒子交換のセクションを追加。\item 2014/10/07 詳細記述の領域クラスセクションを追加。\end{itemize}\newpage%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\section{TODOリスト}\begin{itemize}\item 実装関係(1.0)  \begin{itemize}  \item 周期境界の短距離力  \item 長距離力のツリー判定に幾何中心  \item 長距離力のquadrupole moment  \item PMの組み込み  \item 相互作用リストを返すメソッド  \item ツリーのコピー  \item ファイルIO  \item エラー処理  \end{itemize}\item 性能評価\item リリース版整備  \begin{itemize}  \item サンプルコード  \item テストスィート  \item confiture, make, make check, make install, etc.  \item インストールに必要になることもあるソフトウェア(MPI, FFTW)  \end{itemize}\item 文書  \begin{itemize}  \item 外部仕様書  \item チュートリアル  \item 論文  \item 英語版ドキュメント  \end{itemize}  \item ユーザーサポート体制\item デモ(スパイラル, PPPT, cosmology, アルゴン, サンタバーバラクラス  タ, ダムブレイク, 粉体なにか, MPI, 渦糸法)\item 実装関係(1.0 --)  \begin{itemize}  \item 可視化対応(zindaiji, Yt, splash etc.)  \item 任意境界条件  \item アクセラレータ対応  \item fortran対応  \end{itemize}\end{itemize}\newpage%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\section{はじめに}\label{sec:at_first}この文書は, Framework for Developing Particle Simulator (FDPS) の並列版実装仕様書である. \ref{sec:brief}節に動作概略, \ref{sec:detail}節に詳細仕様, \ref{sec:test}節にテスト定義を記述する.\newpage%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\section{FDPS並列版の動作概略}\label{sec:brief}FDPSは粒子シミュレーションのコード開発を支援するフレームワークである.粒子シミュレーションは, 相互作用の計算と軌道積分の繰り返しであるが,FDPSは相互作用の計算のみを行う. 軌道積分はユーザーが行う. また, FDPSが支援する相互作用は, 2粒子間相互作用の重ね合わせで記述できるもののみである. この相互作用はユーザー定義である. これ以外の相互作用の計算はユーザーが行う. FDPSは, 直交座標系, $D$次元空間($D=2,3$), 様々な境界条件に対応している. 相互作用の計算は, マルチプロセス, マルチスレッド, SIMD演算を用いて, 並列に処理される. FDPSはC++言語にて記述される.対応する2粒子間相互作用を具体的に述べる. 大きく分けて2種類の相互作用に対応し, 1つは長距離力, もう1つは短距離力である. この2つの力は, 遠くの複数の粒子からの作用を1つの超粒子からの作用にまとめるか(長距離力), まとめないか(短距離力)という基準でもって分類される. 長距離力には, 小分類があり, 無限遠に存在する粒子からの力も計算するカットオフなし長距離力と, ある距離以上離れた粒子からの力は計算しないカットオフあり長距離力がある.  前者は開境界条件下における重力やクーロン力に対して, 後者は周期境界条件下の重力やクーロン力に使うことができる. 短距離力にも, 小分類が4つ存在する. 短距離力の場合, 粒子はある距離より離れた粒子からの作用は受けない. すなわち必ずカットオフが存在する. このカットオフ長の決め方によって, 小分類がなされる. すなわち, 全粒子のカットオフ長が等しいコンスタントカーネル, カットオフ長が作用を受ける粒子固有の性質で決まるギャザーカーネル, カットオフ長が作用を与える粒子固有の性質で決まるスキャッタカーネル, カットオフ長が作用を受ける粒子と作用を与える粒子の両方の性質で決まるシンメトリックカーネルである. コンスタントカーネルは分子動力学におけるLJ力に適用でき, その他のカーネルはSPHなどに適用できる.対応した境界条件には3種類があり, その選択はユーザーが行う. 1つめは非周期境界である. これは開境界に対応する. ユーザーが粒子を適切に配置して壁を作れば, 閉境界を作ることもできる. 2つめは並進対称の周期境界である.これによって, $x$, $y$, $z$ 軸方向の周期境界やシアリングボックスなどに対応できる. \redtext{???} 3つめはユーザー定義の周期境界である. 例えば,球の一部を取ってマントル対流を表現することも可能だろう. また鏡面境界もできるはずである.この節の構成は以下の通り. \ref{sec:brief_action}節では, 相互作用を計算するための動作を記述する. \ref{sec:brief_module},\ref{sec:brief_interface}節では, これらを実現するためのモジュールとそれらモジュールのインターフェースを概説する.%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\subsection{動作}\label{sec:brief_action}FDPSにおいて, 相互作用の計算は, 大きく3つの動作に分かれる. 1つは, ルートドメインを, 1プロセスが担当するドメインに分割することである. 2つめは,各プロセスが, 担当するドメイン内に存在するリアル粒子を持つように, リアル粒子を交換することである. 3つめは, 実際の相互作用の計算である. これらを3つのモジュールに対応させる. 1つめは領域クラスである. このモジュールは, ルートドメインの分割を行い, ドメイン情報を持つ. 2つめは粒子群クラスである. これは粒子交換を行い, 粒子情報を持つ. 3つめは相互作用ツリークラスである. これは相互作用計算を行い, それに必要なツリー情報を持つ.以上3つのモジュールは, MPIを用いて並列に処理される. MPIで使用される変数は, 通信用データクラスというモジュールで管理される. 通信用データクラスはシングルトンパターンを用いて実装されるクラスである. どこからでもアクセスできるため, ここでは特に記述しない.%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\subsection{モジュール概略}\label{sec:brief_module}この節では, \ref{sec:brief_action}節で触れた3つのモジュール, すなわち領域クラス, 粒子群クラス, 相互作用ツリークラスの動作を記述する. 様々なデータ構造が現れるが, 断らないかぎり, そのデータ構造はそのクラスに属す.\subsubsection{領域クラス}\label{sec:brief_module_domain_info}このモジュールはルートドメインのドメインへの分割と, ドメイン情報の管理を行う. ルートドメインをドメインに分割する方法は, 各プロセスのリアル粒子のサンプルをすること, サンプルされたリアル粒子を参照して実際のドメイン分割すること, の2段階で行われる. ドメインは$D$次元直方体である. 第1段階は粒子群クラスで行われる. ここでは第2段階の動作を概略する. なお, ルードドメインの分割に関わるパラメータの設定は, ここでは記述しない.\subsubsubsection{ルートドメインの分割}各プロセスは, 粒子群クラスからサンプル粒子の位置ベクトルの配列{\tt  pos\_sample\_ptcl\_}(この配列はC++ ベクタに変更される可能性がある. 以下で現れる配列も同様である)を受け取り, 配列{\tt pos\_sample\_}に保存する. ある1つのプロセス(この節の中でのみアルファプロセスと呼ぶ)は, 全プロセスの配列{\tt pos\_sample\_}を集めて, 配列{\tt pos\_sample\_tot\_}に保存する.  アルファプロセスは, 配列{\tt pos\_sample\_tot\_}を使って, サンプル粒子が適切に配分されるように, ルートドメインをドメインに分割する.さらに, そのドメインを表す$D$次元直方体のデータを配列{\tt  domain\_glb\_}に保存する.  最後に, アルファプロセスは配列{\tt  domain\_glb\_}を全プロセスに放送する. 各プロセスは, アルファプロセスから受け取った配列を, 各々の配列{\tt domain\_glb\_}に保存する.\subsubsection{粒子群クラス}\label{sec:brief_module_paricle_system}このモジュールは2つのことを行う. 1つめは, ルートドメインの分割に必要な粒子のサンプルである. 2つめは, リアル粒子の交換である. なお, リアル粒子のフル粒子データをファイルから読み込むことや, ファイルへの書き込むことは, このモジュールで行われるが, ここでは記述しない. リアル粒子のフル粒子データは各プロセスの配列{\tt ptcl\_}にすでに存在するものとする\subsubsubsection{リアル粒子のサンプル}各プロセスは, リアル粒子のフル粒子データが保存された配列{\tt ptcl\_}からランダムにリアル粒子をサンプルする. サンプルされたリアル粒子の位置ベクトルを抜き出し, ローカルなサンプル粒子の位置ベクトルの配列{\tt  pos\_sample\_ptcl\_}に保存する.\subsubsubsection{リアル粒子の交換}各プロセスは, リアル粒子のフル粒子データの配列{\tt ptcl\_}とドメインの配列{\tt domain\_glb\_}(領域クラスに属す)を比べる. もし自分の持つリアル粒子で自分のドメインからはみだしたリアル粒子があれば, 適切なドメインを担当するプロセスへ, そのリアル粒子を送信し, そのフル粒子データを配列{\tt  ptcl} から削除する.  他のプロセスからリアル粒子をを受信したならば, そのフル粒子データを配列{\tt ptcl\_} へ加える.\subsubsection{相互作用ツリークラス}\label{sec:brief_module_tree_for_force}相互作用の計算は次の6段階で行われる. i) リアル粒子のフル粒子データから相互作用の計算に必要なデータを抜きとる. ii) 自分のプロセスが持つリアル粒子のみからなるローカルツリーを構築する. iii) 自分のプロセスが持つリアル粒子への作用の計算に必要なリアル粒子を他のプロセスから受け取る. iv)自分のプロセスが持つリアル粒子と他のプロセスから受け取ったリアル粒子からなるグローバルツリーを構築する.  v) グローバルツリーを用いて, 自分のプロセスが持つリアル粒子への作用を計算する.  vi) 計算した作用をリアル粒子のフル粒子データへ書き込む. 以下では各節ごとにi)からvi)の概略を記述する.\subsubsubsection{相互作用計算に必要な粒子データの読込}各プロセスが, リアル粒子のフル粒子データの配列{\tt ptcl\_}(粒子群クラスに属す)から別々のデータを抜きとって, 3つの配列に保存する. a)ローカルツリーの作成に必要なデータを抜きとりツリー粒子データの配列{\tt tp\_buf\_}に保存する. b) 作用される粒子に必要なデータを抜きとり, $i$粒子データの配列{\tt ep\_i\_buf\_}に保存する.  c) 作用する粒子に必要なデータを抜きとり,$j$粒子データの配列{\tt ep\_j\_buf\_}に保存する.\subsubsubsection{ローカルツリーの作成}各プロセスが, 配列{\tt tp\_buf\_}を使って, $2^D$ 分木構造であるローカルツリーを作り, 配列{\tt tc\_loc\_[0]}に保存する. ローカルツリーのリーフセルには, リーフセルに含まれるツリー粒子データ, $i$粒子データ, $j$粒子データがそれぞれ, 配列{\tt tp\_loc\_[0]}, {\tt ep\_i\_[0]}, {\tt  ep\_j\_loc\_[0]}(概念上はリスト)に保存されている.ユーザー定義の境界条件の場合, これに追加してなされることがあるので, 記述する. ルートドメインに対して, 複数のイメージドメインが存在するはずである. これらそれぞれに対して, ローカルツリーを構築する. まず, ユーザープログラムから関数{\tt pfunc\_map\_image\_}を受け取る. 各プロセスは自分が担当するリアル粒子に対するイメージ粒子を作る. これらのイメージ粒子を使って, ローカルツリーである$2^D$ 分木構造を作り, 配列{\tt  tc\_loc\_[id]} に保存する({\tt id}はイメージドメインのID). それぞれのリーフセルには, リーフセルに含まれるツリー粒子データ, $i$粒子データ,$j$粒子データがそれぞれ, 配列{\tt tp\_loc\_[id]}, {\tt ep\_i\_[id]},{\tt ep\_j\_loc\_[id]}(概念上はリスト)に保存されている. この中には全くいらないローカルツリーもあるはずなので, そのようなものは作らない仕掛はある.\subsubsubsection{相互作用計算に必要な粒子の交換}各プロセスが, 自分のドメインに属するリアル粒子, リアル超粒子, イメージ粒子, イメージ超粒子のうち, 別ドメインの相互作用計算に必要なものを, ドメインデータの配列{\tt domain\_glb\_}(領域クラスに属す)とルートドメインのローカルツリーを表す配列{\tt tc\_loc\_[0]}, イメージドメインのローカルツリーを表す配列{\tt tc\_loc\_[id]}を使って探す. 見つけたリアル粒子,リアル超粒子, イメージ粒子, イメージ超粒子をその別ドメインに送信する.ドメインに属するリアル粒子への作用を計算するのに必要な別ドメインのリアル粒子, リアル超粒子, イメージ粒子, イメージ超粒子を受信する.受信したリアル粒子, リアル超粒子, イメージ粒子, イメージ超粒子のうち,グローバルツリーの作成に必要なデータを抜き出し, ツリー粒子データの配列{\tt tp\_buf\_}へ加える.  さらに, 受信したリアル粒子とイメージ粒子は配列{\tt ep\_j\_buf\_}に加え, 受信したリアル超粒子とイメージ超粒子は配列{\tt sp\_j\_buf\_}に保存する.\subsubsubsection{グローバルツリーの作成}各プロセスが, ツリー粒子データの配列{\tt tp\_buf\_}を使って, $2^D$分木構造であるグローバルツリーを作り, 配列{\tt tc\_glb\_}に保存する. グローバルツリーのリーフセルには, リーフセルに含まれるツリー粒子データ, $i$粒子データ, $j$粒子データがそれぞれ, 配列{\tt tp\_glb\_}, {\tt ep\_i\_},{\tt ep\_j\_glb\_}(概念上はリスト)に保存されている.\subsubsubsection{相互作用の計算}各プロセスは, グローバルツリーである配列{\tt tc\_glb\_}を使って, 同じリアル粒子やリアル超粒子から作用を受けるリアル粒子のグループを作り, その$i$粒子データを配列{\tt ip\_group\_}に保存する. グローバルツリーである配列{\tt tc\_glb\_}を使って, このリアル粒子のグループに作用するリアル粒子を探して配列{\tt ep\_j\_}に, リアル超粒子を探して配列{\tt sp\_j\_}に保存する. 粒子から粒子への作用を計算する関数{\tt pfunc\_ep\_ep}と, 超粒子から粒子への作用を計算する関数{\tt pfunc\_ep\_sp}をユーザーからもらう.このとき配列{\tt ip\_group\_}, {\tt ep\_j\_}, {\tt sp\_j\_}を使って作用を計算し, 結果を配列{\tt force\_i\_}に書き込む.  自分のドメインに属する全リアル粒子への作用を計算し終わるまでこれを繰り返す.\subsubsubsection{相互作用の書込}各プロセスは, 作用の結果が保存された{\tt force\_i\_}をリアル粒子のフル粒子データの配列{\tt ptcl\_}(粒子群クラスに属す)にコピーする.\subsubsection{データ構造まとめ}この節で登場したデータ構造がどのクラスに属するか記述する.領域クラスは, ドメインデータの配列{\tt domain\_glb\_}, 自分のプロセスからサンプルされたリアル粒子の位置ベクトルの配列{\tt pos\_sample\_}, 全プロセスからサンプルされたリアル粒子の位置ベクトルの配列{\tt  pos\_sample\_tot\_}を持つ.粒子群クラスは, リアル粒子のフル粒子データの配列{\tt ptcl\_}, サンプル粒子の位置ベクトルの配列{\tt pos\_sample\_ptcl\_}を持つ.相互作用ツリークラスは, ツリー粒子データの配列{\tt tp\_buf\_}, $i$粒子データの配列{\tt ep\_i\_buf\_}, $j$粒子データの配列{\tt ep\_j\_buf\_},ローカルツリーの配列{\tt tc\_loc\_[]}, ローカルツリーのリーフセルにぶらさがるツリー粒子データの配列{\tt tp\_loc\_[]}(概念上はリスト), $i$粒子データの配列{\tt ep\_i\_[]}(概念上はリスト), $j$粒子データの配列{\tt  ep\_j\_loc\_[]}(概念上はリスト), グローバルツリーのである配列{\tt  tc\_glb\_}, グローバルツリーのリーフセルにぶらさがるツリー粒子データのリスト{\tt tp\_glb\_}(概念上はリスト), $j$粒子データのリスト{\tt  ep\_j\_glb\_}(概念上はリスト), 実際の相互作用をする際に使う$i$粒子データの配列{\tt ip\_group\_}とその相互作用リストである$j$粒子データの配列{\tt ep\_j\_}とリアル超粒子データの配列{\tt sp\_j\_}, 作用の結果の配列{\tt force\_i\_}を持つ.\begin{table}  \begin{center}    \begin{tabular}{llll}      \hline      モジュール & 名前 & データ構造 & 要素の型 \\            \hline      \hline      領域クラス & {\tt domain\_glb\_}      & 配列 & $D$次元直方体 \\                 & {\tt pos\_sample\_}      & 配列 & 位置ベクトル \\                 & {\tt pos\_sample\_tot\_} & 配列 & 位置ベクトル \\      \hline      粒子群クラス & {\tt pos\_sample\_ptcl\_} & 配列 & 位置ベクトル   \\                   & {\tt ptcl\_}              & 配列 & フル粒子データ \\      \hline      相互作用ツリークラス & {\tt tp\_buf\_}             & 配列 & ツリー粒子データ \\                           & {\tt ep\_i\_buf\_}          & 配列 & $i$粒子データ \\                           & {\tt ep\_j\_buf\_}          & 配列 & $j$粒子データ \\                           & {\tt tc\_loc\_[]}           & 配列 & ツリーセル \\                           & {\tt tp\_loc\_[]}           & 配列 & ツリー粒子データ \\                           & {\tt ep\_i\_[]}             & 配列 & $i$粒子データ \\                           & {\tt ep\_j\_loc\_[]}        & 配列 & $j$粒子データ \\                           & {\tt tc\_glb\_}             & 配列 & ツリーセル \\                           & {\tt tp\_glb\_}             & 配列 & ツリー粒子データ \\                           & {\tt ep\_j\_glb\_}          & 配列 & $j$粒子データ \\                           & {\tt ip\_group\_}           & 配列 & $i$粒子データ \\                           & {\tt ep\_j\_}               & 配列 & $j$粒子データ \\                           & {\tt sp\_j\_}               & 配列 & 超粒子データ \\                           & {\tt force\_i\_}            & 配列 & 作用の結果 \\      \hline      ユーザープログラム & {\tt pfunc\_map\_image\_} & 関数ポインタ(ファンクタ) & -- \\                         & {\tt pfunc\_ep\_ep\_}     & 関数ポインタ(ファンクタ) & -- \\                         & {\tt pfunc\_ep\_sp\_}     & 関数ポインタ(ファンクタ) & -- \\      \hline    \end{tabular}  \end{center}\end{table}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\subsection{モジュールインターフェース}\label{sec:brief_interface}この節では領域クラス, 粒子群クラス, 相互作用ツリークラスの3つのモジュールでどのようなデータ構造が入出力されるのかを記述する. またユーザープログラムから供給されるものも記述する. この模式図を図\ref{fig:brief_interface}に載せる.\begin{figure}  \begin{center}    \includegraphics[width=10cm,bb=0 0 600 500]{fig/brief_interface.jpg}  \end{center}  \caption{モジュールインターフェースの模式図}  \label{fig:brief_interface}\end{figure}\subsubsection{領域クラス}\label{sec:brief_interface_domain_info}%%このクラスが持つデータ構造は, 1プロセスでサンプルした粒子の位置ベクト%%ルの配列{\tt pos\_sample\_}, 全プロセスでサンプルした粒子の位置ベクト%%ルの配列{\tt pos\_sample\_tot\_}, 全ドメインの境界のデータを保存した%%配列{\tt domain\_glb\_}である.このクラスへの入力は, 粒子群クラスから{\tt pos\_sample\_ptcl\_}である.このクラスからの出力は, 粒子群クラスへの{\tt domain\_glb\_}, 相互作用ツリークラスへの{\tt domain\_glb\_}である.\subsubsection{粒子群クラス}\label{sec:brief_interface_paricle_system}%%このクラスが持つデータ構造は, 各プロセスが担当するドメインに存在する%%粒子のデータを保存した配列{\tt ptcl\_}である.このクラスへの入力は, 領域クラスからの{\tt domain\_glb\_}, 相互作用ツリークラスからの{\tt force\_i\_}, ユーザープログラムからのフル粒子データである. このクラスからの出力は, 領域クラスへの{\tt pos\_sample\_ptcl\_},相互作用ツリークラスへの{\tt ptcl\_}である.\subsubsection{相互作用クラス}\label{sec:brief_interface_tree_for_force}このクラスへの入力は, 領域クラスからの{\tt domain\_glb\_}, 粒子群クラスから{\tt ptcl\_}である. このクラスからの出力は, 粒子群クラスへの{\tt  force\_i\_}, ユーザープログラムからの関数{\tt pfunc\_map\_image\_},{\tt pfunc\_ep\_ep\_}, {\tt pfunc\_ep\_sp\_}である.\subsubsection{ユーザープログラムから供給される関数}ユーザープログラムからの出力は次の通り. 粒子群クラスへのフル粒子データ,相互作用ツリークラスへのイメージ粒子を与える関数{\tt  pfunc\_map\_image\_}と作用を計算する関数{\tt pfunc\_ep\_ep}, {\tt  pfunc\_ep\_sp}である.\newpage%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\input{detail_description.tex}%\section{FDPS並列版詳細記述}%\label{sec:detail}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\subsection{データ構造}%\subsubsection{etc}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\subsection{モジュール定義}%\subsubsection{トップレベルのモジュール}%\subsubsection{領域分割・粒子交換}%\subsubsection{etc}\newpage%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\input{detail_test.tex}%\section{テスト定義}%\label{sec:test}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\subsection{領域分割・粒子交換}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\subsection{etc}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\subsection{結合テスト}\newpage%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\input{detail_sample.tex}\newpage%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\section{コーディング規約}\label{sec:rules}\subsection{使用言語}基本的にC++実装。C++11以降、MPI2以降の機能は使わない。\subsection{命名規則}\label{sec:naming_rules}\subsubsection{原則}名前はその意味が分かるように英語で付ける。単語は全て単数形にする。\subsubsection{ファイル名}ファイル名は全て小文字で単語と単語の間はアンダースコアでつなぐ。{\ttparticle\_system.hpp}。\subsubsection{型名}型名は大文字で始まり単語の一番最初の文字も大文字とし、それ以外は小文字にする。{\tt DomainInfo}。\subsubsection{変数名}クラスのメンバ変数名は全て小文字で単語と単語の間はアンダースコアでつなぎ、一番最後もアンダースコアで終わらす。{\tt pos\_sample\_}。\subsubsection{関数名}クラスのメンバ関数名は最初の文字を小文字とし、単語の一番最初の文字は大文字とする。アクセサーは単語の最初を{\tt get}、{\tt set}で始める。{\ttloadParticle}。グローバル関数は最初の文字を大文字とし、単語の一番最初の文字も大文字とする。{\tt Initialize}。\subsubsection{マクロ名}全て大文字とし、単語と単語の間はアンダースコアでつなぐ。{\ttPARTICLE\_SIMULATOR\_TWO\_DIMENSION}。\newpage%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\section{用語集}\label{sec:terms}\begin{description}\item[イメージ粒子] リアル粒子を境界に映した粒子\item[イメージ超粒子] イメージ粒子をまとめた粒子\item[イメージドメイン] ルートドメインを境界に映したドメイン\item[リアル粒子] 実際に存在する粒子. 対となるのがイメージ粒子\item[リアル超粒子] リアル粒子をまとめた粒子\item[ツリー粒子データ] フル粒子データのサブセットで, ツリー作成に必要  なデータ\item[ドメイン] 1プロセスが担当する計算領域\item[プロセス] MPIプロセスの略\item[フル粒子データ] リアル粒子の持つ全データ\item[リーフセル] ツリーセルであり, 子セルを持たないセル\item[ルートドメイン] 全計算領域\item[$i$粒子データ] フル粒子データのサブセットで, 作用を計算する際に,  作用される側の粒子が必要とするデータ\item[$j$粒子データ] フル粒子データのサブセットで, 作用を計算する際に,  作用する側の粒子が必要とするデータ\end{description}\end{document}