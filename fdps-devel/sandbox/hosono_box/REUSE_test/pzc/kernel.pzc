#include <pzc_builtin.h>
#include "./class_device.hpp"

struct kernel_t_device{
	real plus(const real x) const{
		return (x > 0) ? x : 0;
	}
	real pow8(const real x) const{
		const real x2 = x  * x ;
		const real x4 = x2 * x2;
		return x4 * x4;
	}
	real pow7(const real x) const{
		const real x2 = x  * x ;
		const real x4 = x2 * x2;
		return x4 * x2 * x;
	}
	real pow6(const real x) const{
		const real x2 = x  * x ;
		const real x4 = x2 * x2;
		return x4 * x2;
	}
	kernel_t_device(){
	}
	//W
	real W(const real dr, const real h) const{
		const real H = supportRadius() * h;
		const real s = dr / H;
		real r_value;
		
		r_value = (1.0f + s * (8.0f + s * (25.0f + s * (32.0f)))) * pow8(plus(1.0f - s));
		r_value *= (1365.f/64.f) / (H * H * H * M_PI);
		return r_value;
	}
	//gradW
	real gradW(const real dr, const real h) const{
		const real H = supportRadius() * h;
		const real s = dr / H;
		real r_value;
		r_value = pow7(plus(1.0f - s)) * (plus(1.0f - s) * (8.0f + s * (50.0f + s * (96.0f))) - 8.0f * (1.0f + s * (8.0f + s * (25.0f + s * (32.0f)))));
		r_value *= (1365.f/64.f) / (H * H * H * M_PI);
		return r_value / (H + 0.01f * h);
	}
	static real supportRadius(){
		return 3.5f;
	}
};

/*
float fast_rsqrt(float number){
	long i;
	float x2, y;
	x2 = number * 0.5f;
	y  = number;
	i  = *(long*)&y;
	i  = 0x5f3759df - (i >> 1);
	y  = *(float *)&i;
	y  = y * (1.5f - (x2 * y * y));
	return y;
}
*/

float fast_rsqrt(float x) {
	int i = *(int*)&x;
	i = 0x5f3759df - (i >> 1);
	float y = *(float*)&i;
	return y * (1.5f - 0.5f * x * y * y);
}

void pzc_DensityKernel(const int* const j_disp, const Dens::EpiDev* const epi, const Dens::EpjDev* const epj, Dens::ForceDev* force, const int n_total){
	const int tid = get_tid();
	const int pid = get_pid();
	const int index_offset = pid * get_maxtid() + tid;
	const int index_base   = get_maxtid() * get_maxpid();
	const kernel_t_device kernel;

	for(int i = index_offset ; i < n_total ; i += index_base){
		real dens = 0.0f;
		const Dens::EpiDev& ith = epi[i];
		const int id_walk = ith.id_walk;
		const int j_head = j_disp[id_walk];
		const int j_tail = j_disp[id_walk + 1];
		for(int j = j_head ; j < j_tail ; ++ j){
			const Dens::EpjDev& jth = epj[j];
			const real drx = jth.rx - ith.rx;
			const real dry = jth.ry - ith.ry;
			const real drz = jth.rz - ith.rz;
			const real r   = sqrtf(drx * drx + dry * dry + drz * drz);
			dens += jth.mass * kernel.W(r, ith.smth);
		}
		force[i].dens = dens;
	}
	flush();
}

void pzc_DerivativeKernel(const int* const j_disp, const Drvt::EpiDev* const epi, const Drvt::EpjDev* const epj, Drvt::ForceDev* force, const int n_total){
	const int tid = get_tid();
	const int pid = get_pid();
	const int index_offset = pid * get_maxtid() + tid;
	const int index_base   = get_maxtid() * get_maxpid();
	const kernel_t_device kernel;

	for(int i = index_offset ; i < n_total ; i += index_base){
		force[i].div_v  = 0;
		force[i].rot_vx = 0;
		force[i].rot_vy = 0;
		force[i].rot_vz = 0;
		const Drvt::EpiDev& ith = epi[i];
		const int id_walk = ith.id_walk;
		const int j_head = j_disp[id_walk];
		const int j_tail = j_disp[id_walk + 1];
		for(int j = j_head ; j < j_tail ; ++ j){
			const Drvt::EpjDev& jth = epj[j];
			const real drx  = jth.rx - ith.rx;
			const real dry  = jth.ry - ith.ry;
			const real drz  = jth.rz - ith.rz;
			#if 1
			const real r2   = drx * drx + dry * dry + drz * drz;
			const real rinv = fast_rsqrt(r2) + 1.0e-4f;
			const real r    = r2 * rinv;
			#else
			const real r2   = drx * drx + dry * dry + drz * drz;
			const real r    = sqrtf(r2);
			const real rinv = rsqrt(r2) + 1.0e-4f;
			#endif
			const real dvx  = jth.vx - ith.vx;
			const real dvy  = jth.vy - ith.vy;
			const real dvz  = jth.vz - ith.vz;
			//if(r <= 0.0) continue;
			const real drdv  = drx * dvx + dry * dvy + drz * dvz;
			const real ith_abs_gradW = kernel.gradW(r, ith.smth) * rinv;
			force[i].div_v  += - jth.mass * drdv * ith_abs_gradW;
			force[i].rot_vx += - jth.mass * (dry * dvz - drz * dvy) * ith_abs_gradW;
			force[i].rot_vy += - jth.mass * (drz * dvx - drx * dvz) * ith_abs_gradW;
			force[i].rot_vz += - jth.mass * (drx * dvy - dry * dvx) * ith_abs_gradW;
		}
		const real dens_inv = 1.0f / ith.dens;
		force[i].div_v  *= dens_inv;
		force[i].rot_vx *= dens_inv;
		force[i].rot_vy *= dens_inv;
		force[i].rot_vz *= dens_inv;
	}
	flush();
}

#if 1
void pzc_HydroKernel(const int* const j_disp, const Hydr::EpiDev* const epi, const Hydr::EpjDev* const epj, Hydr::ForceDev* force, const int n_total){
	const int tid = get_tid();
	const int pid = get_pid();
	const int index_offset = pid * get_maxtid() + tid;
	const int index_base   = get_maxtid() * get_maxpid();
	const kernel_t_device kernel;

	for(int i = index_offset ; i < n_total ; i += index_base){
		force[i].ax = 0;
		force[i].ay = 0;
		force[i].az = 0;
		force[i].eng_dot = 0;
		force[i].dt = 1.0e+30;

		const Hydr::EpiDev& ith = epi[i];
		const int id_walk = ith.id_walk;
		const int j_head = j_disp[id_walk];
		const int j_tail = j_disp[id_walk + 1];

		const real ith_p_over_dens2 = ith.pres / (ith.dens * ith.dens);

		for(int j = j_head ; j < j_tail ; ++ j){
			const Hydr::EpjDev& jth = epj[j];
			const real drx   = jth.rx - ith.rx;
			const real dry   = jth.ry - ith.ry;
			const real drz   = jth.rz - ith.rz;
			const real dvx   = jth.vx - ith.vx;
			const real dvy   = jth.vy - ith.vy;
			const real dvz   = jth.vz - ith.vz;
			#if 0
				const real r     = sqrtf(drx * drx + dry * dry + drz * drz) + 1.0e-4f;
				const real rinv  = 1.0f / r;
			#else
				const real r2    = drx * drx + dry * dry + drz * drz + 1.0e-4f;
				const real rinv  = fast_rsqrt(r2);
				const real r     = r2 * rinv;
			#endif
			const real drdv  = drx * dvx + dry * dvy + drz * dvz;
			const real w_ij  = (drdv < 0.0f) ? drdv * rinv : 0.0f;
			const real v_sig = ith.snds + jth.snds - 3.0f * w_ij;
			const real AV    = - v_sig * w_ij / ((ith.dens + jth.dens)) * 0.5f * (ith.Bal + jth.Bal);
			#if 0
			const real ith_abs_gradW = kernel.gradW(r, ith.smth);
			const real jth_abs_gradW = kernel.gradW(r, jth.smth);
			const real abs_gradW     = 0.5f * (ith_abs_gradW + jth_abs_gradW) * rinv;
			#else
			const real abs_gradW     = kernel.gradW(r, (ith.smth + jth.smth) * 0.5f) * rinv;
			#endif
			const real acc           = jth.mass * (ith_p_over_dens2 + jth.pres / (jth.dens * jth.dens) + AV) * abs_gradW;
			force[i].ax += acc * drx;
			force[i].ay += acc * dry;
			force[i].az += acc * drz;
			force[i].eng_dot += jth.mass * (ith_p_over_dens2 + 0.5f * AV) * drdv * abs_gradW;
			//force[i].dt = fmin(0.3f * 2.0f * ith.smth / v_sig, force[i].dt);
			const double dt_loc = 0.3f * 2.0f * ith.smth / v_sig;
			force[i].dt = (dt_loc < force[i].dt) ? dt_loc : force[i].dt;
		}
	}
	flush();
}
#else
void pzc_HydroKernel(const int* const j_disp, const Hydr::EpiDev* const epi, const Hydr::EpjDev* const epj, Hydr::ForceDev* force, const int n_total){
	const int tid = get_tid();
	const int pid = get_pid();
	const int index_offset = pid * get_maxtid() + tid;
	const int index_base   = get_maxtid() * get_maxpid();
	const kernel_t_device kernel;

	for(int i = index_offset ; i < n_total ; i += index_base){
		force[i].ax = 0.f;
		force[i].ay = 0.f;
		force[i].az = 0.f;
		force[i].eng_dot = 0.f;
		force[i].dt = 1.0e+30f;

		const Hydr::EpiDev& ith = epi[i];
		const int id_walk = ith.id_walk;
		const int j_head = j_disp[id_walk];
		const int j_tail = j_disp[id_walk + 1];
		for(int j = j_head ; j < j_tail ; ++ j){
			const Hydr::EpjDev& jth = epj[j];
			const real drx   = jth.rx - ith.rx;
			const real dry   = jth.ry - ith.ry;
			const real drz   = jth.rz - ith.rz;
			const real dvx   = jth.vx - ith.vx;
			const real dvy   = jth.vy - ith.vy;
			const real dvz   = jth.vz - ith.vz;
			const real r     = sqrtf(drx * drx + dry * dry + drz * drz);
			if(r <= 0.0f) continue;
			const real drdv  = drx * dvx + dry * dvy + drz * dvz;
			const real w_ij  = (drdv < 0.0f) ? drdv / r : 0.0f;
			const real v_sig = ith.snds + jth.snds - 3.0f * w_ij;
			const real AV    = - 0.5f * v_sig * w_ij / (0.5f * (ith.dens + jth.dens)) * 0.5f * (ith.Bal + jth.Bal);
			const real ith_abs_gradW = kernel.gradW(r, ith.smth);
			const real jth_abs_gradW = kernel.gradW(r, jth.smth);
			const real abs_gradW     = 0.5f * (ith_abs_gradW + jth_abs_gradW);
			const real acc           = jth.mass * (ith.pres / (ith.dens * ith.dens) + jth.pres / (jth.dens * jth.dens) + AV);
			force[i].ax += acc * abs_gradW * drx / r;
			force[i].ay += acc * abs_gradW * dry / r;
			force[i].az += acc * abs_gradW * drz / r;
			force[i].eng_dot += jth.mass * (ith.pres / (ith.dens * ith.dens) + 0.5f * AV) * drdv * abs_gradW / r;
			const real dt_loc = 0.3f * 2.0f * ith.smth / v_sig;
			force[i].dt = (dt_loc < force[i].dt) ? dt_loc : force[i].dt;
		}
	}
	flush();
}
#endif
#if 1
void pzc_GravityKernel(const int* const j_disp, const Grav::EpiDev* const epi, const Grav::EpjDev* const epj, Grav::ForceDev* force, const int n_total){
	const int tid = get_tid();
	const int pid = get_pid();
	const int index_offset = pid * get_maxtid() + tid;
	const int index_base   = get_maxtid() * get_maxpid();
	for(int i = index_offset ; i < n_total ; i += index_base){
		real ax, ay, az, pot;
		ax = ay = az = pot = 0.0f;
		const Grav::EpiDev& ith = epi[i];
		const int id_walk = ith.id_walk;
		const int j_head = j_disp[id_walk];
		const int j_tail = j_disp[id_walk + 1];
		for(int j = j_head ; j < j_tail ; ++ j){
			const Grav::EpjDev& jth = epj[j];
			const real drx = jth.rx - ith.rx;
			const real dry = jth.ry - ith.ry;
			const real drz = jth.rz - ith.rz;
			const real r2       = drx * drx + dry * dry + drz * drz + ith.eps2;
			#if 0
			const real r_inv    = rsqrt(r2);
			#else
			const real r_inv    = fast_rsqrt(r2);
			#endif
			const real m_r_inv  = jth.mass * r_inv;
			const real r2_inv   = r_inv * r_inv; 
			const real m_r3_inv = m_r_inv * r2_inv; 
			pot -= m_r_inv;
			ax  += m_r3_inv * drx;
			ay  += m_r3_inv * dry; 
			az  += m_r3_inv * drz;
		}
		force[i].pot = pot;
		force[i].ax  = ax;
		force[i].ay  = ay;
		force[i].az  = az;
	}
	flush();
}
#else
void pzc_GravityKernel(const int* const j_disp, const Grav::EpiDev* const epi, const Grav::EpjDev* const epj, Grav::ForceDev* force, const int n_total){
	const int tid = get_tid();
	const int pid = get_pid();
	const int index_offset = pid * get_maxtid() + tid;
	const int index_base   = get_maxtid() * get_maxpid();
	typedef real vec4 __attribute__((ext_vector_type(4)));
	for(int i = index_offset ; i < n_total ; i += index_base){
		vec4 acc = 0.0f;
		const Grav::EpiDev& ith = epi[i];
		const int id_walk = ith.id_walk;
		const int j_head = j_disp[id_walk];
		const int j_tail = j_disp[id_walk + 1];
		const real eps2  = ith.eps2;
		for(int j = j_head ; j < j_tail ; ++ j){
			const Grav::EpjDev& jth = epj[j];
			vec4 dr;
			dr.x = jth.rx - ith.rx;
			dr.y = jth.ry - ith.ry;
			dr.z = jth.rz - ith.rz;
			const real r2       = dr.x * dr.x + dr.y * dr.y + dr.z * dr.z + eps2;
			const real r_inv    = rsqrt(r2);
			const real m_r_inv  = jth.mass * r_inv;
			const real r2_inv   = r_inv * r_inv;
			const real m_r3_inv = m_r_inv * r2_inv;
			dr *= m_r3_inv;
			dr.w = m_r_inv;
			acc += dr;
		}
		force[i].ax  = acc.x;
		force[i].ay  = acc.y;
		force[i].az  = acc.z;
		force[i].pot = acc.w;
	}
	flush();
}
#endif

