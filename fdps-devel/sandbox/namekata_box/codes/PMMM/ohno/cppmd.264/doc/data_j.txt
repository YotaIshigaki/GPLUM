粒子データ構造

SpaceVector.h

Common.h

ParticleInfo.h

３次元ベクトル型テンプレート
template<typename T>
class SpaceVector {
  T x,y,z;
};

座標
typedef SpaceVector<double> Position;
速度
typedef SpaceVector<double> Velocity;
力
typedef SpaceVector<double> Force;

原子種
typedef int Atomtype;
通し番号（系全体で一意）
typedef int AtomID;

当初の粒子データ構造
粒子
struct Particle{
  Position position;  // 座標
  Velocity velocity;  // 速度
  Force force;        // 力
  double charge;      // 電荷
  double mass;        // 質量
  double inv_mass;    // 1.0/質量
  Atomtype atomtype;  // 原子種
  AtomID atomid;      // 通し番号
};
粒子列挙
typedef std::vector<Particle> ParticleArray;
Array of Structure になっている。

最適化のため変更した現在の粒子データ
カーネルで使うデータは Structure of Array にした。

座標・電荷
struct ParticlePosCharge{
  Position position;
  double charge;
};
座標・電荷列挙
typedef std::vector<ParticlePosChargeAT> PosChargeATArray;
クーロン力計算に必要なデータをかためた。
座標と電荷で4要素となって、アラインメントがよい。
座標と電荷でキャッシュのway競合が発生しない（特に一次）。

ゴースト粒子列挙
struct GhostParticleArray{
  PosChargeArray poscharge;  // 座標・電荷列挙
  AtomtypeArray atomtype;    // 原子種列挙
  ForceArray force;          // 力列挙
  AtomIDArray atomid;        // 通し番号列挙
};
ゴースト粒子の必要なデータだけをかためた。プロセス間で毎ステップ通信するもの。
原子種はLJに必要、通し番号は結合力に必要。
力は反作用を返す場合に必要（HalfShell,SmallBall,長距離、結合力）。
*ゴースト そのプロセスには属さず別プロセスから通信で受け取るもの

その他
struct ParticleParameter2{
  Velocity velocity; 
  double mass;
  double inv_mass;
};
その他列挙
typedef std::vector<ParticleParameter2> ParticleParameter2Array;
積分等ローカルで使うデータをかためた。

粒子列挙
struct CombinedParticleArray{
  PosChargeArray poscharge;
  AtomtypeArray atomtype;
  ForceArray force;
  AtomIDArray atomid;
  ParticleParameter2Array parameters;
};
完全な粒子列挙。ローカルで持つ。




粒子列挙のセルパッキング
CombinedParticleArray(ローカル粒子)とGhostParticleArray(ゴースト粒子)はプロセスが１個づつ持つ。
それぞれ複数のセルが含まれる場合がある。
ParticleArray中のセルの範囲は TypeRange で指定する。

粒子の範囲
struct ParticleRange{
  int begin;
  int end;
}
begin<=インデックス<end 

  CombinedParticleArray pa;
  ParticleRange pr;
  for(i=pr.begin;i<pr.end;i++){
    Position pos = getpos(pa,i);
    ...
  }
のように使う。pa[pr.end]は含まない（指定範囲の直後、あるいは、追加する場所を示す）。
stl::vectorのbegin,endと類似


struct TypeRange : public ParticleRange {
  ParticleRange lj;
  ParticleRange ljcoulomb;
  ParticleRange coulomb;
}

TypeRange::begin,end           セルに属する粒子のインデックスの範囲
TypeRange::lj.begin,end        LJ相互作用のみの粒子のインデックスの範囲
TypeRange::ljcoulomb.begin,end LJとCoulomb相互作用する粒子のインデックスの範囲
TypeRange::coulomb.begin,end   Coulomb相互作用のみの粒子のインデックスの範囲

TypeRange::begin = TypeRange::lj.begin
TypeRange::ljcoulomb.begin = TypeRange::lj.end
TypeRange::coulomb.begin = TypeRange::ljcoulomb.end
TypeRange::end = TypeRange::coulomb.end
を仮定している。
一個のセルに属する粒子は、
LJのみ、LJとCoulomb、Coulombのみ
の順に詰まっている。
 begin                                               end
 lj.begin    lj.end
             ljcoulomb.begin    ljcoulomb.end
                                coulomb.begin        coulomb.end
|   LJ      |    LJ+Coulomb    | Coulomb            |



複数セルを持つ場合は
std::vector<TypeRange> typerangearray;
のように使う。
粒子数の変動に対応するためセル間にはギャップを持たせている。
typerangearray[i].end << typerange[i+1].begin


LJのみ、LJ+Coulomb、Coulombのみを別関数で計算するなら次の様に使う。
  CombinedParticleArray pai, paj;
  TypeRange tri, trj;

  for(i=tri.lj.begin;i<tri.lj.end;i++){
    Position posi = getpos(pai,i);
    AtomType ati = getatomtype(pai,i);
    for(j=trj.lj.begin;j<trj.ljcoulomb.end;j++){
      Position posj = getpos(paj.j);
      AtomType atj = getatomtype(paj.j);
      force += calc_lj_force(posi,ati,posj,atj);
    }
  }
  for(i=tri.ljcoulomb.begin;i<tri.ljcoulomb.end;i++){
    Position posi = getpos(pai,i);
    double chargei = getcharge(pai,i);
    AtomType ati = getatomtype(pai,i);
    for(j=trj.lj.begin;j<trj.lj.end;j++){
      Position posj = getpos(paj.j);
      AtomType atj = getatomtype(paj.j);
      force += calc_lj_force(posi,ati,posj,atj);
    }
    for(j=trj.ljcoulomb.begin;j<trj.ljcoulomb.end;j++){
      Position posj = getpos(paj.j);
      double chargej = getcharge(paj,j);
      AtomType atj = getatomtype(paj.j);
      force += calc_ljcoulomb_force(posi,chargei,ati,posj,chargej,atj);
    }
    for(j=trj.coulomb.begin;j<trj.coulomb.end;j++){
      Position posj = getpos(paj.j);
      double chargej = getcharge(paj,j);
      force += calc_coulomb_force(posi,chargei,posj,chargej);
    }
  }
  for(i=tri.coulomb.begin;i<tri.coulomb.end;i++){
    Position posi = getpos(pai,i);
    double chargei = getcharge(pai,i);
    for(j=trj.ljcoulomb.begin;j<trj.coulomb.end;j++){
      Position posj = getpos(paj.j);
      double chargej = getcharge(paj,j);
      force += calc_coulomb_force(posi,chargei,posj,chargej);
    }
  }

