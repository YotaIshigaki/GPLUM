以下では、相互作用計算や通信を効率的に行う為にユーザーが定義出来る粒子
クラスおよび、結果を格納するためのForceクラスについて説明する。これらの
クラスは名前空間{\tt PS}の下にある必要はない。

\subsection{{\tt FullParticle}型}

シミュレーションを行う上で必要な粒子が持つべき情報が入っているクラスで
絶対に必要。ParticleSystemがこのクラスの配列を持つ。ノード間での粒子交
換はこのクラスが交換される。メンバ変数はprivateでもpublicでもよい。
{\tt TreeParticle}はこのクラスから生成される。{\tt TreeParticle}は{\tt
FullParticle}から必要な情報をもらう為、{\tt FullParticle}は決まった名前
のアクセサを持つ必要がある（メンバ変数名は自由）。

\begin{itemize} 
\item {\tt getPos()}　相互作用の形によらず絶対必要。
\item {\tt getCharge()}　長距離力の計算をする場合。
\item {\tt getRSearch()}　cutoff付長距離力、短距離力の計算をする場合。
\item {\tt getEps()}　対称化ソフトニングを用いる場合。
\end{itemize}

また、{\tt TreeForForce}が直接{\tt Force}の値を{\tt FullParticle}に書き
込めるように{\tt copyFromForce()}というメソッドも必要。

\subsection{{\tt EssentialParticleI}型}

粒子-粒子間相互作用を計算するのに必要なI粒子が持っている情報を持つクラ
ス。TreeForForceがこのクラスの配列を持つ。相互作用に必要な{\tt
FullParticle}のメンバをコピーするので、{\tt copyFromFP}という名前のメン
バ関数が必要。

\subsection{{\tt EssentialParticleJ}型}

粒子-粒子間相互作用を計算するのに必要なJ粒子が持っている情報を持つクラ
ス。TreeForForceがこのクラスの配列を持つ。LET交換で通信される。相互作
用に必要な{\tt FullParticle}のメンバをコピーするので、{\tt copyFromFP}
という名前のメンバ関数が必要。

\subsection{{\tt SuperParticleJ}型}

セル-粒子間相互作用を計算するのに必要なセルの情報を持ったクラス。
TreeForForce型がこのクラスの配列を持つ。短距離力の場合は{\tt size}この
クラスは必要ない。長距離力の場合は、{\tt charge}と{\tt pos}が必要である。
さらに双極子、四重極子を計算する場合はそれぞれ{\tt di}と{\tt quad}を加
えることができる。対称化されたソフトニングを用いる場合は{\tt eps}を加え
ることもできるが、その場合は{\tt FullParticle}型のメンバ変数に{\tt
eps}が必要となる。あらかじめ、以下の場合については最初から用意されてい
る。

\begin{itemize}
\item 重心周りで展開した単極子からの力の計算。
\item 重心周りで展開した四重極子までの力の計算。
\item ソフトニングが対称化された重心周りで展開した単極子からの力の計算
\item 幾何中心周りで展開した単極子からの力の計算。
\item 幾何中心周りで展開した双極子までの力の計算。
\item 幾何中心周りで展開した四重極子までの力の計算。
\end{itemize}

\subsection{{\tt Force}型}

相互作用の結果を格納するクラス。TreeForForceがこのクラスの配列を持つ。
TreeForForceが値の初期化等をしなければならないので、初期化をするメンバ
関数{\tt clear()}が必要。

\section{Treeを構築しているサブクラス。}
\label{sec:tree_subclass}

\subsection{TreeParticle}

{\tt TreeForForce}が持つクラスで、ユーザーからは見えない。{\tt
FullParticle}から粒子情報をもらいツリーの構築、モーメントの計算等に用い
る。これらのクラスは{\tt FullParticle}にアクセスする必要があり、{\tt
FullParticle}のユーザ定義メソッド({\tt FullParticle::getPos()}等)を用い
てアクセスする。

\begin{lstlisting}[caption=TreeParticle]
namespace ParticleSimulator{
    template<class Tprop>
    class TreeParticle{
    public:
        U64 key_;
        S32 next_adr_tp_;
        Tprop prop_;
        template<class Trp>
        void setFromFP(const Trp & rp){
            key_ = MortonKey<DIMENSION>::getKey( rp.getPos() );
            prop_.setFromFP(rp);
        }
    };
}
\end{lstlisting}

メンバ{\tt prop\_}はツリーセルのモーメントや情報等を作る為に使われる。こ
れはユーザーがツリークラスのオブジェクトを作るときに、自動的に適したク
ラスが採用される。

以下は重力用のクラスである。

\begin{lstlisting}[caption=PropertyLong]
namespace ParticleSimulator{
    class PropertyLong{
    public:
        F32 charge_;
        F32vec pos_;
    };
}
\end{lstlisting}



\subsection{TreeCell}

{\tt TreeForForce}が持つセルクラスで、ユーザーからは見えない。{\tt
Tree Particle}から粒子情報をもらいセルのモーメントの計算を行い値を格納
する。

以下に短距離力用の{\tt TreeCell}を記述する。
\begin{lstlisting}[caption=TreeCell]
namespace ParticleSimulator{
    template<class Tmom>
    class TreeCell{
    public:
        S32 n_ptcl_;
        S32 adr_tc_;
        S32 adr_tp_;
        S32 lev_ni_;
        Tmom mom_;
    };
}
\end{lstlisting}


メンバ{\tt mom\_}はツリーセルのモーメント等の情報を保持するモーメントク
ラス。ユーザーがツリークラスのオブジェクトを作るときに、自動的に適した
モーメントクラスが採用される。以下は短距離力用のモーメントクラスである。

\begin{lstlisting}[caption=MomentSearch]
namespace ParticleSimulator{
    class MomentSearch{
    public:
        F32ort vertex_in_;
        F32ort vertex_out_;
        template<class Tprop> void accumulateAtLeaf(const Tprop & _prop);
        void accumulate(const MomentSearch & _mom);
    };
}
\end{lstlisting}

ここで、{\tt PS::F32ort}が出てくるが、これは{\tt PS::Orthotope}クラスと
いわれるもので、内部に二つの{\tt PS::F32vec}型を持ち、それぞれが位置座
標の小さい頂点と大きい頂点の位置座標を持つ。