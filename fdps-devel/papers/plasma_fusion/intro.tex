我々が FDPS を開発した動機は、
現在、大規模な粒子シミュレーションを
する、特に、そのためのプログラムを開発することが非常に大変になってい
る、ということです。FDPS はこの開発を容易にすることを目指すものです。

30年前であれば、研究に使える粒子シミュレーションのプログラムを研究者、
あるいは学生が自分で書くことはそれほど大変ではありませんでした。普通に
書いた上で、ベクトル化等をすればよかったからです。

しかし、現在では、そう簡単ではありません。
まず、1CPUの計算機でも、
CPU コアが複数あり、コアの中にはSIMDユニットがあるため、これらを有効に
使えるかどうかで数十から数百倍性能が変わります。また、キャッシュメモリ
も有効に使わない逆に性能が桁で落ちることもあります。さらにスパコンを、
と思うとMPIを使った並列化が必要です。これらをあわせるとそもそも個人で
は困難、というレベルの大変な作業になります。

大変になっている要因を整理してみると、次のようにまとめられます。

\begin{itemize}

\item 並列化の階層の増加

\item メモリボトルネックの発生とそれには対応したメモリ階層の増加・複雑化

  
\end{itemize}  

以下、それぞれについて簡単に述べます。

現代の典型的な大規模並列計算機は、

\begin{itemize}

\item 複数の演算を並列に行う SIMD 演算ユニットを (コア内SIMD)
\item 複数もつ演算コアを (スーパースカラー)
\item 複数もつプロセッサチップを (マルチコア)
\item 複数ネットワークで接続した (分散メモリ並列)

\end{itemize}  
構成を持っています。つまり、4つの違うレベルで並列動作する複数のユニッ
トを持っています。しかも、それぞれのレベルで、どういうふうにすれば上手
く並列化できるか、が違います。この中で、「スーパースカラー」というのは、
CPU が、機械語プログラムの中から、並行して実行できそうなものを同時に
実行する機能です。なので、これは
ある程度ハードウェアがやってくれます。しかし、他の3つのレベルのために固有の
最適化が必要で、しかも分散メモリ並列では MPI を使ってプログラム全体を
書換え、例えば空間分割をして粒子を移動させるといった処理も書く必要がで
てきます。

並列化の複数のレベルの扱いをさらに困難なものにしているのが、メモリ階層
の存在です。現代の計算機では、演算器のほうがメモリより速く、演算器の性能を生
かすためには容量は小さいけれど高速なキャッシュメモリを使っています。

しかし、この、キャッシュメモリは、並列計算機とは決して相性のいいもので
はありません。マルチコアプロセッサでは、それぞれのコアが独立にキャッシュ
をもちたいわけですが、そうすると、あるコアがメモリのどこかに書いても、
その同じアドレスのデータを別のコアが自分のキャッシュにもっているとか、
あるいはまだ誰かのキャッシュの中でしか更新されていなくて主記憶には古い
データがあるものを主記憶から読んだ時に新しいデータにならないといけないといった
問題があります。こういったややこしい状況でもちゃんと整合性がある結果を
保証するのが「コヒーレントキャッシュ」というもので、そのためにコア間で
複雑なやりとりをする大規模なハードウェアが必要です。

このようなシステムで性能を出すためにはいかにしてキャッシュを制
御するかが重要になり、キャッシュの特性を考慮したプログラムを書く必要
がでてきます。最近のプロセッサでは3レベルから4レベルのキャッシュを持つ
ようになっています。しかし、密行列乗算ならともかく、それ以外の計算アル
ゴリズムではこのような複数レベルのキャッシュを有効に使えるとは限らないで
すし、できたとしてもプログラムは極めて複雑なものにならざるを得ません。

このため、単純なアルゴリズムでも、最新の高性能プロ
セッサで性能を出すのは容易なことではなくなっています。

実際、今この文章を読んでおられる読者の皆様の中でも、俺はMPIで並列化し
てキャッシュも有効利用しSIMD演算器も使ってプラズマシミュレーションプロ
グラムを書いた、あるいは書ける、あるいは書く気がある、という人はあまり
多くないのでは、と思います。


では、どうすればいいのか？というのがここでの問題です。多くの場合にとら
れているアプローチは、大規模なソフトウェアを開発チームを作ることでなん
とか開発しよう、というもので、実際、様々な応用分野で、粒子法の並列化さ
れたプログラムが公開され、利用可能になっています。

しかし、そういったプログラムは、あらかじめ開発グループが実装した機能を、
開発グループがターゲットにしたマシン・OSで使うことしかできないのが普通
です。もちろん、オープンソースで公開されているものでは、原理的には
ソースコードを修正していろいろな機能を実装できるわけですが、巨大で複雑
なプログラムで、さらに特定のアーキテクチャ向けの最適化されたコードがで
るものを修正して動くようにするのは容易なことではないのは、やってみよう
と思ったことがある人は良くご存じのことかと思います。

なので、自分でプログラムを開発できるようにしたいわけですが、それにはど
うすればいいのか、というのが我々の問題意識です。我々が提案する方法は、
特にMPIにかかわるような複雑な並列化とそのために必要なプログラムと、実
際に扱う系の記述や時間積分の方法の記述とを明確に分離することです。

明確に分離、と書くのは簡単ですが、実際にどのように実現するか、
十分に色々なことを表現するにはどうするか、計算速度がでるようにするには
どうするのか、と、いろいろな問題があります。本解説では、まず
基本的な考え方を2節で、またいくつかのFDPSをつかったサンプルを3節で紹
介します。4節はまとめです。


