%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 分子シミュレーション研究会会誌「アンサンブル」用テンプレートファイル%% Ver.3.0  2016/07/08%%% 1) イントロダクション+説明%%     概要 考え方%%     こんなコードはこう動く的サンプル紹介%%     LJ のコード？%%     内部構造，ツリーとかの話をちょっとする？%%     手法を開発する人に使って欲しいみたいな話を．%% 2)  使い方の詳しい話%%     C++ の紹介+%%     F2003 もある!%%     ユーザーコードの書き方%%     内部構造，ツリーとかの話を詳しく？%% 3)  MD スペシフィックな%%     ボンド%%     周期境界%% 4)  チューニング%%     大規模実行%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\documentclass[twocolumn,10pt]{jarticle}\usepackage[reviewb]{ensemble}\usepackage{enumitem}\usepackage{url}%% === 使用方法 ===%% \usepackage[option]{ensemble}%% option のところを，記事の種類に合わせて変更してください．% % review : 論文・研究紹介（著者一人）% reviewb : 論文・研究紹介（著者二人）% intro : 特集の前書き，研究室紹介，海外紹介（著者一人）% introb : 特集の前書き，研究室紹介（著者二人）% report : 夏の学校報告等（著者有り，著者紹介無し）% noauther : 報告（著者無し）%% amsmath， amssymb， cite， color， graphicx， here， % は，ensemble．sty の中で読み込まれています．%\setcounter{page}{101}  % 開始ページ (編集委員用)\title{% タイトル[]連載 FDPS入門 (2) }\author{% 著者名岩澤全規}\email{% e-mail addressmasaki.iwasawa@riken.jp}\affiliation{% 所属理化学研究所\quad 計算科学研究機構}\career{% 著者紹介岩澤全規(博士(学術))：〔経歴〕2009年東京大学大学院総合文化研究科博士課程修了，2012年から現所属．〔専門〕天体物理，計算科学．\\}% 第2著者\authorb{行方大輔}\emailb{daisuke.namekata@riken.jp}\affiliationb{% 所属理化学研究所\quad 計算科学研究機構}\careerb{% 著者紹介行方大輔(博士(理学))：〔経歴〕2010年北海道大学大学院理学院博士課程修了．2016年から現所属．〔専門〕天体物理，計算科学．\\}\abst{% 概要本連載では，私達が開発・公開している多体シミュレーションプログラム開発フレームワーク「FDPS (Framework for Developing Particle  Simulators)」を紹介します．連載第二回の今回は，具体的なサンプルコードを例にとり，FDPS を使ってどのように粒子系シミュレーションプログラムを開発するのかを詳しく説明していきます．開発に必要となるC++言語の文法，FDPSの内部実装についても合わせて解説します．本稿の後半では，Fortranからの使い方を紹介します．\\\mbox{}}\keyword{% キーワード粒子シミュレーション，分子動力学，HPC，並列化，MPI\\}% 顔写真のファイル名．デフォルトはphoto．eps， photob．eps% 第1著者\photofile{iwasawa.eps} % 第2著者\photofileb{namekata.eps} %------------------------------------------------------------------------% ユーザー定義のマクロはここに書く．%------------------------------------------------------------------------%\renewcommand{\v}[1]{{\bf #1}}%\newcommand{\ave}[1]{\left< #1 \right>}%------------------------------------------------------------------------\begin{document}\maketitle%------------------------------------------------------------------------% 原稿ここから%------------------------------------------------------------------------\section{はじめに}連載第二回目となる本稿では，粒子間相互作用がレナードジョーンズポテンシャルで表される場合のサンプルコードを用い，FDPSの使い方を説明していきます．FDPSの実装はC++で行われています．これは，任意の粒子データや相互作用関数を扱うためにC++のテンプレート機能\footnote{C++では関数や構造体，クラ  ス等を定義する際にその引数やメンバ変数に具体的な型を指定すること無く，  抽象的に定義することができる．この機能の事をテンプレートと呼ぶ．FDPS  内の関数やクラスはこのテンプレートを用いて抽象的に定義されているため，  開発者は任意の粒子データや相互作用関数を用いてプログラムの開発が可能  となっている．}が適しているからです．そのため，FDPSはC++によりプログラム開発を行うことを想定して作られています．しかし，FortranユーザーからのFDPSを使用したいという要望にこたえるため，Fortranインターフェースの開発を行いました．本稿の前半ではFDPS付属のC++のサンプルコード\footnote{\$(FDPS)/sample/c++/vdw\_test}を例にプログラムの開発方法を説明します．後半ではFortranからの使い方を説明します．\section{FDPSを用いた粒子シミュレーションプログラムの開発方法}FDPSを用いてプログラムを開発するために，開発者が行うことは大きく次の3つになります．\begin{itemize}\item 粒子情報を定義する\item 粒子間の相互作用関数を定義する\item FDPSのAPIを用いてプログラム本体の開発を行う\end{itemize}以下，それぞれについて詳しく説明します．\subsection{粒子情報の定義}まず，開発者は粒子の持つべき情報をクラスを用いて定義します．C++におけるクラスとはC言語における構造体を拡張したものであり，メンバ変数以外に関数(メンバ関数)を持つことができます．実際に例をみてみましょう．{\scriptsize\begin{verbatim}class FPLJ{public:    PS::S64 id;    PS::F64 mass, pot;    PS::F64vec pos, vel, acc;    PS::F64 search_radius;    void clear(){        acc = 0.0;        pot = 0.0;    }    PS::F64 getRSearch() const{        return this->search_radius;    }    PS::F64vec getPos() const { return pos; }    void setPos(const PS::F64vec & p) { pos = p; }    void copyFromForce(const FPLJ & force){        acc = force.acc;        pot = force.pot;    }    //(I/O用の関数省略)    void copyFromFP(const FPLJ & fp){         mass = fp.mass;        pos = fp.pos;        id = fp.id;        search_radius = fp.search_radius;    }};\end{verbatim}}この粒子クラスは変数としてid，mass，pot，pos，vel，acc，search\_radiusを持っています．これらはそれぞれ粒子のインデックス，質量，ポテンシャルエネルギー，位置，速度，加速度，近傍探査半径を表しています．ここで，PS::S64，PS::F64，PS::F64vec等はFDPSで定義されている型であり，それぞれ64bitの整数型，浮動小数点型，3次元ベクトル型をあらわしています．ここでPSはFDPSが使う名前空間です．FDPSで定義した関数や型はこのPSという名前空間の中で定義されているため，これらを使用する時には常にPS::を付けます．これにより開発者がFDPSで使っているAPIやFDPSで定義した型と同名の関数や型を使っていた場合でも名前の衝突を防ぐことができます．今回の計算では粒子の位置座標と近傍探査半径はFDPSがツリー構造を作る際や近傍粒子探査を行うために必要となります．しかし，FDPSはどのメンバ変数が位置座標や近傍探査半径を表すかは知りません．そこで，位置座標と近傍探査半径を返すためのメンバ関数getPos()とgetRSearch()を定義する必要があります．これらの関数の名前はFDPS側で決めており，この名前でなければなりません．メンバ関数は他にclear()，setPos()，copyFromForce()，copyFromFP()があります．これらはそれぞれ相互作用計算の結果の消去，粒子の位置座標の設定，相互作用の結果を適当な変数にコピー，粒子間の情報をコピーするための関数です．これらもやはりこの名前でなければなりません．サンプルコードでは，粒子クラスは一つしか定義していませんが，FDPSは4種類の異なる粒子クラスを扱います．その4種類とは粒子が持つ必要のある全物理量をメンバとして持つFP型．相互作用計算を行うために必要な最小限の情報をもちi粒子\footnote{力を受ける粒子}を表すEPI型とj粒子\footnote{力を及  ぼす粒子}を表すEPJ型．相互作用計算の結果のみを保持するFORCE型です．FDPSでは相互作用計算時にFPに比べてサイズの小さいEPI，EPJ，FORCEを用いることでメモリキャッシュの利用効率をあげる事ができます．ただし，本サンプルコードでは簡単のため，FP，EPI，EPJ，FORCEの定義を全て同じにしています．そのため，粒子クラスを上記の一つしか定義していません．\subsection{相互作用計算の定義}FDPSでは開発者が計算したい対象に合わせて相互作用関数を定義する必要があります．以下にレナードジョーンズポテンシャルの場合の例を示します．{\scriptsize\begin{verbatim}void CalcForceFpFp(const FPLJ * ep_i,                   const PS::S32 n_ip,                   const FPLJ * ep_j,                   const PS::S32 n_jp,                   FPLJ * force){    const PS::F64 r0 = 3;    const PS::F64 r0sq = r0*r0;    const PS::F64 r0inv = 1/r0;    const PS::F64 r0invp6 = 1/(r0sq*r0sq*r0sq);    const PS::F64 r0invp7 = r0invp6*r0inv;    const PS::F64 foffset = -12.0*r0invp6*r0invp7+6*r0invp7;    const PS::F64 poffset = -13.0*r0invp6*r0invp6+7*r0invp6;    for(PS::S32 i=0; i<n_ip; i++){        PS::F64vec xi = ep_i[i].pos;        PS::F64vec ai = 0.0;        PS::F64 poti = 0.0;        PS::S64 idi = ep_i[i].id;        for(PS::S32 j=0; j<n_jp; j++){            if( idi == ep_j[j].id ) continue;            PS::F64vec rij = xi - ep_j[j].pos;            PS::F64 r2 = rij * rij;            if (r2 < r0sq){                PS::F64 r_inv = 1.0/sqrt(r2);                PS::F64 r = r2*r_inv;                PS::F64 r2_inv = r_inv * r_inv;                PS::F64 r6_inv = r2_inv * r2_inv * r2_inv;                PS::F64 r12_inv = r6_inv * r6_inv;                poti += r12_inv - r6_inv-foffset*r+poffset;                ai += (12*r12_inv*r2_inv - 6*r6_inv*r2_inv                        + foffset*r_inv) * rij;            }        }        force[i].acc += ai;        force[i].pot += poti;    }}\end{verbatim}}この関数名は開発者が任意に与えることができます．引数は第一引数から順にEPIの配列，EPIの個数，EPJの配列，EPJの個数，FORCEの配列となる必要があります．しかし，先程述べたように本サンプルではEPI，EPJ，FORCEは全て同じ型として定義しているので，引数の型が全て先程定義した粒子型(FPLJ)になっている事に注意してください．相互作用関数内にはi粒子に対するforループとj粒子に対するforループの2つのループ構造があることが分かります．FDPSの大きな特徴は，この相互作用関数を最適化するだけで高い性能がえられる，ということです．2重ループ構造のため，キャッシュ利用効率がよく，またCPUコア内で複数の演算を並列に行うSIMD化も比較的容易に行うことができます．\subsection{メイン関数}いよいよ，次はメイン関数本体の開発です．FDPSを用いた粒子シミュレーションは以下の手順にそって行われます．\begin{enumerate}\item 初期条件を生成\item 計算領域を空間的に分割\item 領域内に収まるように粒子を交換\item 相互作用を計算\item 粒子情報を更新\end{enumerate}FDPSは手順2-4を担当します．そのために，FDPSは手順2-4を実行するためのクラスを持ちます．プログラムはこれらのクラスの変数\footnote{この変数をオ  ブジェクトと呼ぶ}を宣言し，それらに必要なデータを設定し，メンバ関数を呼ぶことで，これらの手順を実行できます．以下，例を見ていきましょう．ここでは簡単のため，実際のFDPS付属のサンプルプログラムから少し改変していますが，行っていることはほとんど同じです．{\scriptsize\begin{verbatim}int main(int argc, char *argv[]){    PS::Initialize(argc, argv);    // 初期パラメータ設定(省略)    PS::ParticleSystem<FPLJ> system;    system.initialize();    system.setNumberOfParticleLocal(n_loc);    for(PS::S32 i=0; i<n_loc; i++){        system[i].mass = m; // 粒子の質量を設定        // 同様に他の物理量も設定(省略)    }    PS::DomainInfo dinfo;    dinfo.initialize();    dinfo.setBoundaryCondition          (PS::BOUNDARY_CONDITION_PERIODIC_XYZ);    dinfo.setPosRootDomain(PS::F64vec(-boxdh,-boxdh,-boxdh),                           PS::F64vec(boxdh,boxdh,boxdh));    dinfo.decomposeDomainAll(system);    system.exchangeParticle(dinfo);    PS::TreeForForceShort<FPLJ, FPLJ, FPLJ>::Scatter tree;    tree.initialize(n_glb, theta, n_leaf_limit,                     n_group_limit);    tree.calcForceAllAndWriteBack(CalcForceFpFp,                                   system, dinfo);    // メインループ(省略)    PS::Finalize();    return 0;}\end{verbatim}}プログラムはまずPS::Initialize()を呼ぶ必要があります．これ以降，FDPSの提供するAPIや型を利用することが可能になります．またプログラムは最後にPS::Finalize()を呼んでいます．この関数はFDPSの終了処理をするためのものです．PS::Initialize()の後にプログラムはPS::ParticleSystemクラスのオブジェクトsystemの生成を行っています．このクラスは内部に$<>$を通して与えられた型(FPLJ)の配列を持ちます．これが先程説明したC++のテンプレート機能です．PS::ParticleSystemというクラスがFDPS内でテンプレート機能を用いて定義されているため，この様に開発者が定義した粒子データ型を扱う事ができるようになっています．プログラムはオブジェクト生成後，関数initialize()によりオブジェクトの初期化を行っています．% 岩澤オリジナル@2017/6/28%次に，systemが持つ粒子配列に粒子の初期条件を設定する必要があります．プ%ログラムはメンバ関数setNumberOfParticleLocal()を用いて各プロセスが担当%する粒子の個数(ここではn\_loc)を設定しています．その後，プログラムは%system[i].mass=mとしてi番目の粒子に質量mを設定しています．ここで演算子%[]は PS::ParticleSystemクラス内で定義されている演算子です．プログラム%はこの演算子を用いることで通常の配列と同じようにsystemの内側の粒子配列%にアクセスする事ができます．次に，systemが持つ粒子配列に粒子の初期条件を設定する必要があります(手順1)．大規模並列計算では，初期条件の設定は全粒子をプロセスの数に分割して行うことが一般的です．FDPSでは空間を領域分割し，その分割した領域とそこにある粒子を各プロセ
スが担当する形で並列化を行いますが，これは後述する手順2，3を実行することで自動的に行われるので
この初期条件生成の段階ではプログラムをそのことを意識して書く必要はあり
ません．したがって，適当な方法で分割して頂いて構いません．分割に際し，各々のプロセスは自分が担当する粒子数を決める必要があります．この設定はsystemのメンバ関数setNumberOfParticleLocal()を用いて行います．プログラムでは値としてn\_locが指定されています(一般にn\_locの値はプロセスごとに異なります)．このメンバ関数の実行により、systemが持つ粒子配列には、n\_loc個の粒子を格納するのに十分なメモリが割り当てられます．したがって、初期条件の設定はこのメンバ関数の呼び出し後に行う必要があります．プログラムはsystem[i].mass=mとしてi番目の粒子に質量mを設定しています．ここで演算子[]は PS::ParticleSystemクラス内で定義されている演算子です．プログラムはこの演算子を用いることで通常の配列と同じようにsystemの内側の粒子配列にアクセスする事ができます．FDPSは外部のファイルからの粒子データの読み込みをサポートする関数も持っています．詳しくはFDPS付属のチュートリアル\footnote{https://github.com/FDPS/FDPS/blob/master/  doc/doc\_tutorial\_cpp\_ja.pdf}をご覧ください．% 岩澤オリジナル@2017/6/28 %次にプログラムは計算領域の分割を行うために計算領域に関するクラス%PS::DomainInfoクラスのオブジェクトdinfoの生成を行っています．FDPS では，%大規模並列化環境で高い効率を実現するため、空間分割による並列化を採用し%ています．プログラムは先程と同様にinitialize()によりオブジェクトの初期%化を行っています．その後プログラムはメンバ関数setBoundaryCondition()を%用いて境界条件の設定を行っています．ここでは引数に%PS::BOUNDARY\_CONDITION\_PERIODIC\_XYZが与えられていますのでx，y，z軸%全ての方向に周期境界条件が適用されます．さらに周期境界条件ではボックス%の大きさが必要となるため，プログラムはメンバ関数setPosRootDomain()を用%いてボックスの大きさを与えています．ここでは，-boxdh $\leq$ x，y，z%$<$ boxdhのボックスを考えています． その後プログラムはメンバ関数%decomposeDomainAll()を用い計算領域の分割を行います．%decomposeDomainAll()では各プロセスの持つ粒子をランダムにサンプルし，各%プロセスの持つ粒子数が同じになるように領域を決定し\footnote{各プロセス%  からサンプルする粒子数には重みをつける事ができるため，各プロセスで実%  行時間が大体同じになるように領域を決める事などもできる．}，その領域%の座標をPS::DomainInfo内部に格納します．領域分割にはMulti Section法%\cite{MS}というアルゴリズムを採用しています．詳しくは参考文献を御覧く%ださい．次に計算領域の分割を行います(手順2)．分割によって得られる小領域の各々は．異なるプロセスが担当します．このように，FDPSでは大規模並列化環境で高い効率を実現するため，空間分割による並列化を採用しています．計算領域の分割を行うため，まずプログラムは計算領域に関するクラスPS::DomainInfoクラスのオブジェクトdinfoの生成を行っています．生成後，先程と同様にinitialize()によりオブジェクトの初期化を行っています．その後プログラムはメンバ関数setBoundaryCondition()を用いて境界条件の設定を行っています．ここでは引数にPS::BOUNDARY\_CONDITION\_PERIODIC\_XYZが与えられていますのでx，y，z軸全ての方向に周期境界条件が適用されます．さらに周期境界条件ではボックスの大きさが必要となるため，プログラムはメンバ関数setPosRootDomain()を用いてボックスの大きさを与えています．ここでは，-boxdh $\leq$ x，y，z $<$ boxdhのボックスを考えています． その後プログラムはメンバ関数decomposeDomainAll()を用い計算領域の分割を行います．decomposeDomainAll()では各プロセスの持つ粒子をランダムにサンプルし，各プロセスの持つ粒子数が同じになるように領域を決定し\footnote{各プロセス  からサンプルする粒子数には重みをつける事ができるため，各プロセスで実  行時間が大体同じになるように領域を決める事などもできる．}，その領域の座標をPS::DomainInfo内部に格納します．領域分割にはMulti Section法\cite{MS}というアルゴリズムを採用しています．詳しくは参考文献を御覧ください．領域分割の後，プログラムはPS::ParticleSystemクラスのメンバ関数exchangeParticle()を呼ぶ事でプロセス間での粒子の交換を行います(手順3)．この関数は各プロセスが自分の担当する全ての粒子についてどのプロセスに所属するべきかを計算し，適切なプロセスとの間で粒子の交換を行います．次はいよいよ相互作用計算です(手順4)．プログラムは相互作用計算に関するクラスPS::TreeForForceShortのオブジェクトtreeの生成を行っています．このクラスは$<>$を通して開発者が定義したFORCE，EPI，EPJのクラスにアクセスできます．先程述べた通り，本プログラムでは粒子クラスを一つしか定義していないため，$<>$内には全て同じ粒子型(FPLJ)が与えられています．プログラムは，オブジェクト生成後，initialize()によりオブジェクトの初期化を行います．引数のn\_glbは扱う全粒子数です．これはクラス内部の粒子配列の初期の大きさを推定するために用いられています． 最後にプログラムはcalcForceAllAndWriteBack()を用い相互作用の計算を行い計算結果を再びFPに書き戻しています．ここで第一引数に先程定義した相互作用関数を渡しています．FDPSはこの関数を使って相互作用計算を行います．メンバ関数calcForceAllAndWriteBack()では各プロセスが以下の手順に従って計算を実行しています．\begin{enumerate}\item 自分が担当する粒子のみによってツリー構造を作成する\item ツリー構造を使って他のプロセスが相互作用を計算するのに必要な粒子を探査する\item 他のプロセスと通信を行い、相互作用計算に必要な粒子を集める\item 担当する粒子と受信した粒子を使ってツリー構造を再構築する\item ツリー構造を使って自分が担当する粒子に対する相互作用リストを作成する\item 相互作用リストを用いて相互作用を計算する\end{enumerate}ここまでで相互作用計算は完了しているので，その後，この結果を用いて粒子情報の更新を行います．さらにこれら一連の手順をシミュレーション終了まで繰り返し，プログラムは終了します．\section{FDPSのFortranからの使い方}\label{sec:usage_of_fdps_from_ftn}本節では，どのようにしてFortranからFDPSを使うのか，について解説します．FortranからFDPSを利用する場合，プログラムの開発は大まかには次の手順に沿って行うことになります．\begin{enumerate}\item 粒子構造体の定義 \label{enum:def_ptcl_obj}\item FDPSのFortran用インターフェースプログラムの生成 \label{enum:gen_if_step}\item 相互作用関数の定義 \label{enum:def_interact_func}\item プログラム本体の開発\end{enumerate}C++から利用する場合の手順との最も大きな違いは，ステップ\ref{enum:gen_if_step}の存在です．FortranにはC++言語のテンプレートに相当する機能がありませんので，FDPSが各種ライブラリ関数を提供するためには，事前に粒子のデータ構造を知っている必要があります．そのため，最初に開発者に粒子構造体を定義してもらい(ステップ\ref{enum:def_ptcl_obj})，その後，その粒子構造体用のライブラリ関数を生成する(ステップ\ref{enum:gen_if_step})，という手順を踏む必要があります．このステップ\ref{enum:gen_if_step}は，実際には，単に我々が提供するPythonスクリプトを実行するだけの作業で，特に難しいことはありません．開発者はステップ\ref{enum:gen_if_step}で生成されたFortranインターフェース(FDPSを操作するためのFortranサブルーチン/関数の集まり)を使って，プログラム本体を開発することとなります．Fortranインターフェースが提供する関数群は，C++のものとほぼ同じになっており，コード開発は，C++からFDPSを利用する場合とほぼ同じ要領で行えます．ただし，Fortranインターフェースは，Fortran 2003から導入されたC言語との相互運用を可能にする文法を使用していますので，粒子構造体や相互作用関数の定義等は，いくつかの要請に従って実装する必要があります．以下では，各手順について，より詳しく説明していきます．\subsection{粒子構造体の記述方法}\label{subsec:how_to_implement_ptcl}粒子は，Fortranの構造体(別名，派生データ型)と特別なコメント文を用いて定義します．といっても，わかりにくいと思いますので，まずは例を見て頂きましょう．以下は，第2.1節で紹介したC++の粒子クラスをFortranで記述したものです．{\scriptsize\begin{verbatim}type, public, bind(c) :: fplj !$fdps FP,EPI,EPJ,Force    !$fdps copyFromForce fplj (pot,pot) (acc,acc)    !$fdps copyFromFP fplj (id,id) (mass,mass) (pos,pos) \       (search_radius,search_radius)    !$fdps clear id=keep, mass=keep, pos=keep, vel=keep, \       search_radius=keep    integer(kind=c_long_long) :: id    real(kind=c_double) :: mass !$fdps charge    type(fdps_f64vec) :: pos !$fdps position    type(fdps_f64vec) :: vel !$fdps velocity    type(fdps_f64vec) :: acc    real(kind=c_double) :: pot    real(kind=c_double) :: search_radius !$fdps rsearchend type fplj  \end{verbatim}}\noindent同じものがディレクトリ \texttt{sample/fortran/vdw-test} の \texttt{user\_defined.F90} に記述されています(これより後で示すプログラムのソースファイルも，すべてこのディレクトリにあります)．この例で，\texttt{type} 〜 \texttt{end type}が1つの構造体を表しており，この間に定義されている変数(id, mass 等)がメンバ変数となります．構造体の名称は，\texttt{type}文の右側で指定でき，今の場合，\texttt{fplj} となっています．この構造体で表されるデータを，FortranプログラムからC++で記述されたFDPS本体に渡したり，或いは逆に，FDPS本体から受け取ったりするため，Fortran インターフェースプログラムでは，Fortran 2003から言語仕様として導入されたC言語との相互運用を可能にする機能を利用しています\footnote{本来必要とされるのはC++と相互運用を可能にする機能ですが，近代的な Fortran においてもそのような機能は用意されていません．そこで私達は，C言語で記述された関数やデータ構造がC++から使用可能な点と，Fortran 2003で導入されたC言語との相互運用を可能にする機能を組み合わせて，FortranからFDPSを利用可能にしています．}．この機能を利用するためには，構造体がC言語と相互運用可能である必要があります．C言語と相互運用可能であるための条件の詳細は省きますが，主な条件は，\begin{itemize}\item 構造体が \texttt{bind(c)} 属性を持つこと\item すべてのメンバ変数がC言語と相互運用可能なデータ型であること\end{itemize}です．最初の条件は，\texttt{type}文に\texttt{bind(c)}キーワードをつけるだけでクリアできます．2番目の条件についてですが，Fortran 2003 以降には C言語の基本データ型に対応するデータ型がFortran側に用意されており，それらを用いてメンバ変数を定義すれば満たすことができます．今回の例の\texttt{integer(kind=c\_int)}などは，そのようなデータ型の1例です．C言語と相互運用可能なデータ型の一覧は，例えば，GNU gfortran のオンラインドキュメント\footnote{\url{https://gcc.gnu.org/onlinedocs/gfortran/ISO_005fC_005fBINDING.html#ISO_005fC_005fBINDING}}等で紹介されています．なお，これらのデータ型は組込モジュール \texttt{iso\_c\_binding} 内に定義されていますので，\texttt{use}文で，このモジュールを参照可能にしておく必要があります．構造体には，C言語と相互運用可能な構造体をメンバ変数として含めることも可能です．\texttt{fdps\_f64vec}はFDPSから提供されるそのようなデータ型の1つです．プログラムを見ると，\texttt{!\$fdps}で始まるコメント文が多数あることに気づかれるかと思います．これらが本節冒頭で「特別なコメント文」と述べたものです．第2.1節で述べたように，FDPSは，粒子構造体のどのメンバ変数が何を表すのか，といったことを知っている必要があります．\texttt{!\$fdps}から始まるコメント文は，このような情報をFDPSに教えるための指示文です．以降，単にFDPS指示文と呼ぶことにします．FDPS指示文には大きく分けて以下の3種類があります．\begin{enumerate}[label=(\alph*)]\item 構造体の種別を表す指示文\label{enum:dir_for_str}\item メンバ変数が何の物理量を表すかを指定する指示文\label{enum:dir_for_mbr}\item FDPS 内部で行われるデータ操作の仕方を指示する指示文\label{enum:dir_for_meth}\end{enumerate}以下，これらについて簡単に説明します．指示文\ref{enum:dir_for_str}は，構造体が4つのユーザ定義型(FP型，EPI型，EPJ型，FORCE型)のどれに対応するかをFDPSに指示するためのもので，今回の例では，{\footnotesize\begin{verbatim}!$fdps FP,EPI,EPJ,Force\end{verbatim}}\noindentとなっています．この例では，この粒子構造体がすべてのユーザ定義型を兼ねることをFDPSに指示しています．指示文\ref{enum:dir_for_mbr}は，粒子の質量(電荷)や位置等，FDPSが知っておかなければならない物理量が，どのメンバ変数に対応するかを指定します．今回の例では，{\footnotesize\begin{verbatim}real(kind=c_double) :: mass !$fdps chargetype(fdps_f64vec) :: pos !$fdps positiontype(fdps_f64vec) :: vel !$fdps velocityreal(kind=c_double) :: search_radius !$fdps rsearch  \end{verbatim}}\noindentとなっています．これによって，FDPSは，massが粒子の質量(電荷)，posが粒子の位置，velが粒子の速度，search\_radiusが探索半径であると解釈します．指示文\ref{enum:dir_for_meth}は，今回の例では，\texttt{type}文のすぐ下の{\footnotesize\begin{verbatim}!$fdps copyFromForce fplj (pot,pot) (acc,acc)!$fdps copyFromFP fplj (id,id) (mass,mass) (pos,pos) \   (search_radius,search_radius)!$fdps clear id=keep, mass=keep, pos=keep, vel=keep, \   search_radius=keep\end{verbatim}}\noindentの部分に対応します．ここで，$\backslash$ は行が下の行に継続していることを示す記号で，実際には指示文は1行で記述しなければなりません．キーワード\texttt{copyFromForce}を含む指示文はFORCE型からFP型へのデータコピーの仕方を，\texttt{copyFromFP}を含む指示文はFP型からEPI型およびEPJ型へのデータコピーの仕方を指定しています．キーワード\texttt{clear}を含む指示文は相互作用計算時にFORCE型を初期化する方法を指定しています．以上，Fortranにおける粒子構造体の定義方法を簡単に説明しました．紙面の都合上，指示文の文法に関する詳細な説明は省きましたが，詳しい情報は仕様書\footnote{\url{https://github.com/FDPS/FDPS/blob/master/doc/doc_specs_ftn_ja.pdf}}でご覧頂けます．\subsection{Fortran インターフェースの生成方法}\label{subsec:how_to_gen_if}Fortran インターフェースは，以下のコマンドを実行するだけで自動的に生成されます．{\footnotesize\begin{verbatim}./$(FDPS_LOC)/scripts/gen_ftn_if.py user_defined.F90\end{verbatim}}\noindentここで，\texttt{\$(FDPS\_LOC)}はFDPSのトップディレクトリのパスを表します．また，粒子構造体は，ファイル \texttt{user\_defined.F90}に定義されているとしています．インターフェースの生成が成功した場合，カレントディレクトリに，\texttt{FDPS\_Manipulators.cpp}，\texttt{FDPS\_ftn\_if.cpp}，\texttt{FDPS\_module.F90}，\texttt{main.cpp}という4つのファイルが作成されているはずです．Fortran インターフェースは，ファイル\texttt{FDPS\_module.F90}内に定義されるモジュール\texttt{fdps\_module}内に実装されています．\subsection{相互作用関数の記述方法}\label{subsec:how_to_def_interact_func}相互作用関数はFortranのサブルーチンとして定義します．以下に，第2.2節で紹介したC++の相互作用関数をFortranで記述したもの(インターフェース部分のみ)を示します．{\scriptsize\begin{verbatim}subroutine calc_force_fpfp(ep_i,n_ip,ep_j,n_jp,f) bind(c)   integer(c_int), intent(in), value :: n_ip,n_jp   type(fplj), dimension(n_ip), intent(in) :: ep_i   type(fplj), dimension(n_jp), intent(in) :: ep_j   type(fplj), dimension(n_ip), intent(inout) :: f      ! 中身は省略   end subroutine calc_force_fpfp\end{verbatim}}\noindent相互作用関数もまたC言語と相互運用可能でなければなりません．そのためには，次の条件\begin{itemize}\item サブルーチンが\texttt{bind(c)}属性を持つこと\item 関数内で使用される変数のデータ型がC言語と相互運用可能なデータ型であること\end{itemize}を満たす必要があります．最初の条件は，サブルーチン名の右側に\texttt{bind(c)}キーワードを付けることでクリアできます．これらの条件に加え，FDPS側からの要請として，EPI型 配列とEPJ型 配列の個数を示す\texttt{n\_ip}と\texttt{n\_jp}は値渡しでなければなりません．このため，\texttt{value}属性を指定しています．\subsection{プログラム本体の記述方法}\label{subsec:how_to_implement_main}最後にプログラム本体がFortranでどのように記述されるのかを解説します．以下に，第2.3節で紹介したC++のサンプルコードをFortranで書いたものを示します．{\scriptsize\begin{verbatim}subroutine f_main()   use fdps_module   use user_defined_types   implicit none   !* 局所変数宣言(重要な変数のみ示す)   type(fdps_controller) :: fdps_ctrl   type(c_funptr) :: pfunc_ep_ep   !* FDPSを初期化   call fdps_ctrl%PS_Initialize()   !* 粒子群オブジェクトを生成   call fdps_ctrl%create_psys(psys_num,'fplj')   call fdps_ctrl%init_psys(psys_num)   !* 初期粒子分布を設定   call setup_IC(fdps_ctrl,psys_num,ntot,boxdh)   !* 領域情報オブジェクトを生成   call fdps_ctrl%create_dinfo(dinfo_num)   call fdps_ctrl%init_dinfo(dinfo_num,coef_ema)   call fdps_ctrl%set_boundary_condition(dinfo_num, &                                         fdps_bc_periodic_xyz)   call fdps_ctrl%set_pos_root_domain(dinfo_num,pos_ll,pos_ul)   !* 領域分割と粒子交換   call fdps_ctrl%decompose_domain_all(dinfo_num,psys_num)   call fdps_ctrl%exchange_particle(psys_num,dinfo_num)   !* ツリーオブジェクトを生成   call fdps_ctrl%create_tree(tree_num, &                              "Short,fplj,fplj,fplj,Scatter")   call fdps_ctrl%init_tree(tree_num,3*ntot,theta, &                            n_leaf_limit,n_group_limit)   !* 相互作用計算   pfunc_ep_ep = c_funloc(calc_force_fpfp)   call fdps_ctrl%calc_force_all_and_write_back(tree_num,    &                                                pfunc_ep_ep, &                                                psys_num,    &                                                dinfo_num)                                                   !(時間積分ループはここに記述)   !* FDPSの終了処理を実行   call fdps_ctrl%PS_Finalize()end subroutine f_main                          \end{verbatim}}\noindentプログラム中のコメント文は，各場所で何をしているかを説明しています．コメント文を追うと，プログラム全体の構造がわかります．すなわち，FDPSの初期化から始まって，各種のオブジェクトを作成し，それらを使って相互作用計算を行う，というものになっています．このように，FDPSの使い方はC++の場合とほぼ同じことがわかります．しかし，いくつかFortranに特有な部分がありますので，以下にそれらをまとめます．\begin{itemize}\item プログラム本体はサブルーチン\texttt{f\_main()}の中に記述しなければなりません．これは，プログラムのメイン関数はC++側にあって，そこから\texttt{f\_main()}が呼び出されているためです．\item FDPSのFortran インターフェースは，モジュール\texttt{fdps\_module}内で定義されるクラス\texttt{fdps\_controller}のメンバ関数として提供されます．FortranのクラスはC++のクラスと同じようにメンバ変数とメンバ関数を持つデータ構造です．サブルーチン\texttt{f\_main()}内で，このクラスのメンバ関数を呼び出すため，\texttt{use}文でモジュール\texttt{fdps\_module}にアクセス可能にし(プログラム 2行目)，局所変数として，\texttt{fdps\_controller}クラスのオブジェクト\texttt{fdps\_ctrl}を宣言しています(6行目)．メンバ関数の呼出は，\begin{verbatim}call fdps_ctrl%member_func()  \end{verbatim}のように行います．\item 粒子群オブジェクト等のFDPS固有のオブジェクトはすべて整数変数で管理します．\item 相互作用関数をFDPSに渡すためには関数のC言語アドレスが必要となりますが，それはFortran 2003 で追加された組込関数\texttt{c\_funloc}で取得できます．関数の返り値は，\texttt{c\_funptr}型です．\end{itemize}各APIの機能に関しては，APIの名称がC++のものと類似していることから予想がつくと思いますが，詳しくは仕様書をご参照して頂ければと思います．最後に，Fortranで記述されたサンプルコードの実行例をお見せしたいと思います．サンプルコードはディレクトリ \texttt{sample/fortran/vdw-test} にありますので，そこに移動して，\texttt{make; ./vdwtest.out} を実行すれば，以下のような出力が得られるはずです．{\scriptsize\begin{verbatim}******** FDPS has successfully begun. ********==================================== Paralleization infomation:   # of processes is 1   # of thread is    1==================================== nptcl_1d =            8np_ave=1536time:    7.8125000000E-003, energy error:    1.5220343903E-010time:    6.2500000000E-002, energy error:    2.5923769738E-009(途中省略)time:    9.9375000000E+000, energy error:    4.0086395482E-005time:    1.0000000000E+001, energy error:    6.2026013003E-005******** FDPS has successfully finished. ********\end{verbatim}}\noindent以上，簡単ではありますが，FortranでFDPSを利用する方法について解説を行いました．次回は，より現実的な分子動力学のシミュレーションプログラムの実装例について解説します．原子結合等の取扱もそこで扱う予定です．% 謝辞%\acknowledgement{○○氏に感謝しま% 参考文献\begin{thebibliography}{9}\bibitem{FDPS}M. {Iwasawa},  A.  {Tanikawa}, N.  {Hosono}, K. {Nitadori},T. {Muranushi}, and J. {Makino},\textit{Publ. Astron. Soc. J.}, {\bf 68}, 54 (2016).\bibitem{MS}J. {Makino},\textit{Publ. Astron. Soc. J.}, {\bf 56}, 521 (2004).\end{thebibliography}%------------------------------------------------------------------------% 原稿ここまで%------------------------------------------------------------------------% 著者紹介出力\profile\end{document}