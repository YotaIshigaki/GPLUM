\documentclass[10pt,onecolumn,a4paper,fleqn]{article}
%\documentclass[10pt,twocolumn,a4paper,fleqn]{article}

%%%%% AUTHORS - PLACE YOUR OWN PACKAGES HERE %%%%%
\usepackage[x11names,table]{xcolor}
\usepackage{moresize}
\usepackage{minted}
\usepackage{mdframed}
\usepackage{caption}

%%% minted setting %%%
\setminted{fontsize=\ssmall,baselinestretch=1}
%\setminted{fontsize=\fontsize{6.25}{7.25}\selectfont,baselinestretch=1}

%%% Page size setting %%%
\topmargin=0mm
\oddsidemargin=-5mm
\evensidemargin=-5mm
\textheight=222mm
\textwidth=130mm
%\textwidth=165mm



% Beginning of document
\begin{document}
\pagenumbering{gobble}

%TODO: コードが1ページ以内に収まるように最低限の部分だけを残す。
\definecolor{bg}{rgb}{0.95,0.95,0.95}
\begin{mdframed}[
    backgroundcolor=bg,
    topline=false,
    bottomline=false,
    leftline=false,
    rightline=false]
  \begin{minted}[fontfamily=courier,linenos=true, breaklines]{cpp}
PS::S32 RetrieveKernel(const PS::S32 tag,
                       const PS::S32 n_walk,
                       const PS::S32 ni[],
                       FORCE *force[]){
  static int n_offset[N_WALK_LIMIT+1];
  const int n_walk_ave = n_walk/N_STREAM;
  for(int id_stream=0; id_stream<N_STREAM; id_stream++){
    const int n_walk_in_stream   = n_walk_ave   + ((id_stream < n_walk%N_STREAM) ? 1 : 0);
    const int id_walk_head = n_walk_ave*(id_stream) + std::min(id_stream, n_walk%N_STREAM);
    const int id_walk_end  = id_walk_head + n_walk_in_stream;    
    const int ni_tot = ij_disp[id_stream][n_walk_in_stream].x;
    cudaMemcpyAsync(force_h[id_stream], force_d[id_stream], ni_tot*sizeof(FORCE_GPU), cudaMemcpyDeviceToHost, stream[id_stream]);
    cudaStreamSynchronize(stream[id_stream]);
    n_offset[0] = 0;
    for(int i=0; i<n_walk_in_stream; i++){
      const int iw = id_walk_head + i;
      n_offset[i+1] = n_offset[i] + ni[iw];
    }
    for(int iw=id_walk_head; iw<id_walk_end; iw++){
      const int ni_tmp = ni[iw];
      const int n_offset_tmp = n_offset[iw-id_walk_head];
      for(int i=0; i<ni_tmp; i++){
        const int i_src = i + n_offset_tmp;
        force[iw][i].acc.x = force_h[id_stream][i_src].accp.x;
        force[iw][i].acc.y = force_h[id_stream][i_src].accp.y;
        force[iw][i].acc.z = force_h[id_stream][i_src].accp.z;
        force[iw][i].pot   = force_h[id_stream][i_src].accp.w;
      }
    }
  }
  return 0;
}
  \end{minted}
\end{mdframed}

% End of Document

\end{document}
