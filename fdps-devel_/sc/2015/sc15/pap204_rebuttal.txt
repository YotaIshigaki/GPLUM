Reviewer #1 wrote "the presentation of the programming interface is
weak". We will add code fragments of our SPH code.

The reviewer wrote "the paper is lacking a solid comparison of
existing frameworks". We add the comparison of FDPS and petaPar (Li,
Wang, Ma, & Tian 2014, "petaPar A Scalable Petascale Framework for
Meshfree/Particle simulation"). We believe FDPS is superior to petaPar
in the following two points. One is generality. petaPar is actually a
single application program which can be used for SPH/MPM simulations
with fixed interaction radius and several models. FDPS is a framework
using which users can develop their own particle-based simulation
codes, not limited to SPH or MPM. The other is performance. petaPar
divides the computational domain to a number of cells of the same
size, and achieve the load balance by assiging different number of
cells to processors. When the particle density of a small region
becomes very high, the calculation cost and memory requirement of this
part can be very large, or load balance can degrade. In our method,
computational domain is devided to orthotopes of variable sizes. There
is no performance degradation for highly inhomogenius distribution of
particles.

For readability, we will add comments to steps 1, 2, and 3 in section
2.1 as follows:
1. The entire ... between nodes. "The algorithm is described in detail
in section 3.1."

The function object lines from 37 to 61 is used for calculating both
forces exerted by j-particle and superparticle. This argument will be
add to section 2.2.

We will introduce FDPS APIs in advance in section 2.1 and 2.2. For
example, in section 2.1, we add the following explanation. FDPS users
can do step 1 only by calling one of FDPS APIs "decomposeDomainAll". 

We will add the comparison of our N-body code with GreeM code
(Ishiyama, Nitadori & Makino 2012) to provide "apples to apples"
comparison. Since BONSAI runs only on GPU, we choose to compare with
GreeM, which is very highly optimized code runs on K computer. Since
GreeM uses TreePM algorithm, we plan to compare the FDPS
implementation of TreePM and GreeM.

Reviewer #2 wrote "What is needed in this paper is a simple apples to
apples comparison". We will compare our N-body code with GreeM code as
described above.

Reviewer #3 said we need to compare FDPS with several agent-based
frameworks (e.g. FLAME, PANDORA). We will refer to these frameworks as
examples. However, it is not simple to compare these frameworks with
FDPS. These frameworks aim at social science, while FDPS aims at
elementary science. Rather, we should compare FDPS with petaPar as
described above.

The reviewer said "the performance analysis is too simple". We will
compare our N-body code with GreeM as described above.

Reviewer #4 wrote "it is unclear what the conceptual contributions of
this work are". The "conceptual" contribution of our work that we
demonstrated that a problem-independent framework with which a user
can easily develop highly-parallel and efficient particle-based
simulations. To our knowledge, such a framework does not exist, and
researchers have been very skeptical about the performance of such
framework. We demonstrated that the performance of applications
developed using FDPS is on par with that of best existing
applications.

The reviewer said that our work is "incremental". As the reviewer
pointed out, we utilized parallel algorithms in previous
studies. However, the previous studies deal with only specific
problems, such as gravitational N-body simulation, and SPH
simulation. FDPS can support particle simulations with user-supplied
particle-particle interaction function. Thus, FDPS can support much
wider range of numerical schemes and applications. We emphasize our
work is not incremental at all.

The reviewer said that FDPS is "limited applicability to the K
computer only". Actually, FDPS does work on other systems, for example
Cray XC30 (with Haswell processors) of National Astronomical
Observatory of Japan. We will add the description on this point in the
revised version.

For weak point 2 and points 2 - 5 of detail comments, we will shorten
section 2.1.2, 2.2, 3.1, and 3.2, and add the description of
experimental setup and evaluation in more detail in section 4.

For point 1 of detail comments, we do not think C++ is "too low
level", since its capability of metaprogramming through the use of
templates provided us enough flexibility to implement general
framework.

In point 6 of detail comments, the reviewer wonders why we care about
performance. We need to care about performance, since the important
point of FDPS is balancing between programmability and performance.

For point 7 of detail comments, our N-body code in section 4.1
utilized built-in functions in the function object for an efficient
use of SIMD units. This made the number of lines of our code
larger. We will remark this in section 4.1.

For point 8 of detail comments, we will change point types in Figures
6 and 8 in order to read in B/W.
