\subsection{1CG (Core Group)でのTemporal Blocking実験}
\subsubsection{Introduction}

Sunway での研究開発の方針として、まずは簡単な差分ステンシルを用い、1CGで
temporal blocking で性能を出すことがそもそも可能かどうかを確認してみることにする。

ここでの「性能を出す」とは、ローカルメモリサイズ、主記憶バンド幅から理論的に可能な性能に比べて
何\%の演算性能が実現可能かを確認するということである。


この実験は1プロセスで行うので並列化とか通信は考えないでやることができて、実際、少し
規模が大きい問題を考えるとノード間通信の時間はほぼ無視できるので通信と
計算を無理にオーバーラップさせる必要はなくなる。もっとも
定量的、実験的にちゃんと見積もっておく必要はある。



この実験で駄目なら何やっても駄目だし、これでできるなら基本には同じやり方で
コード生成できれば色々他のことができることになる。


\subsubsection{理論的に実現可能な演算性能の見積もり}

理論的に実現可能な演算性能は以下のように見積もられる。

演算器の演算性能および主記憶の帯域幅を
$F$ Flop/s および
$B$ Byte/s とする。またステンシル計算の1メッシュあたりの演算量および、独立変数の情報量を
$C$ Flop, $H$ Byte とする。

すると、Spatial Blockingをもちいる場合、1秒間に更新可能なメッシュ数
$n_{up}$は、

\begin{align}
n_{up} &= \min \left( \frac{B}{2H}, \frac{F}{C} \right)
\end{align}

で見積もられる。そして、実効性能は

\begin{align}
  F_{up} &= C \cdot n_{up} \\
  &= \min \left( \frac{BC}{2H}, F \right)
\end{align}

で見積もられる。


Temporal Blockingをもちいる場合、1秒間に更新可能なメッシュ数
$n_{up}$は、キャッシュに当てたタイルサイズを$N_T$、
空間の次元を$d$、
ステンシルの袖領域のサイズを$N_s$として

\begin{align}
n_{up} &= \min \left( \frac{N_T B}{4dN_s H}, \frac{F}{C} \right)
\end{align}

で見積もられる。そして、実効性能は

\begin{align}
  F_{up} &= C \cdot n_{up} \\
  &= \min \left( \frac{N_T B C}{4 d N_s H}, F \right)
\end{align}

で見積もられる。




\subsubsection{Source code}
 We have compiled and executed the following source codes:

\verb`param.h`
\begin{code}
#define NX 50
#define NY 50
#define NZ 50

#define SX 34
#define SY 34
#define SZ 34

#define T_MAX 3000

typedef double Real;


const Real Fu = 1.0/86400, Fv = 6.0/86400, Fe = 1.0/900, Du = 0.1*2.3e-9, Dv = 12.2e-11;
const Real dt = 0*200, dx = 0.001;

\end{code}

\verb`master.c`
\begin{code}
#include <stdio.h>
#include <athread.h>
#include <fcntl.h>
#define N 4096


//extern SLAVE_FUN(func)();

double a[N];
double b[N];
double c[N];

int main() {
  int i;
  printf("hello Sunway TaihuLight\n");

  for (i=0; i<N;++i){
    a[i] = i;
    b[i] = i;
  }

  for (i=0; i<N;++i){
    c[i] = a[i] * b[i];
  }

  for (i=1; i<N; i=2*i+1){
    printf("%d^2 == %lf\n", i, c[i]);
  }

  return 0;
}

\end{code}

\verb`master.cpp`
\begin{code}
#include <cmath>
#include <unistd.h>
#include <fstream>
#include <iostream>
#include <sstream>
#include <sys/time.h>

#include "param.h"



Real U[NX][NY][NZ], V[NX][NY][NZ];
Real U_other[NX][NY][NZ], V_other[NX][NY][NZ];
int global_clock;


Real Uwx[T_MAX][2][SY][SZ], Uwy[T_MAX][SX][2][SZ], Uwz[T_MAX][SX][SY][2];
Real Vwx[T_MAX][2][SY][SZ], Vwy[T_MAX][SX][2][SZ], Vwz[T_MAX][SX][SY][2];

Real sU0[SX][SY][SZ], sV0[SX][SY][SZ];


extern "C" {
  void run_benchmark();
}

double wctime() {
  struct timeval tv;
  gettimeofday(&tv,NULL);
  return (double)tv.tv_sec + (double)tv.tv_usec*1e-6;
}



void fill_initial_condition() {
  global_clock=0;
  for (int x=0;x<NX;++x) {
    for (int y=0;y<NY;++y) {
      for (int z=0;z<NZ;++z) {
        U[x][y][z] = 1;
        V[x][y][z] = 0;
      }
    }
  }
  int bx = std::max(NX/4,NX/2-8),  ex = std::min(3*NX/4+1,NX/2+8);
  int by = std::max(NY/4,NY/2-8),  ey = std::min(3*NY/4+1,NY/2+8);
  int bz = std::max(NZ/4,NZ/2-8),  ez = std::min(3*NZ/4+1,NZ/2+8);
  for (int x=bx;x<ex;++x){
    for (int y=by;y<ey;++y){
      for (int z=bz;z<ez;++z){
        U[x][y][z] = 0.5;
        V[x][y][z] = 0.25+0.1*sin(x+sqrt(y)+cos(z));
      }
    }
  }
}


inline Real periodic(Real ar[NX][NY][NZ],int x, int y, int z) {
  x = ((x+100*NX)%NX+NX)%NX;
  y = ((y+100*NY)%NY+NY)%NY;
  z = ((z+100*NZ)%NZ+NZ)%NZ;
  //x = (x+NX)%NX;
  //y = (y+NY)%NY;
  //z = (z+NZ)%NZ;
  return ar[x][y][z];
}


void naive_proceed() {
  ++global_clock;

  auto lap = [](Real ar[NX][NY][NZ],int x, int y, int z) {
    auto ret = periodic(ar, x-1, y, z) + periodic(ar, x+1, y, z)
    + periodic(ar, x, y-1, z) + periodic(ar, x, y+1, z)
    + periodic(ar, x, y, z-1) + periodic(ar, x, y, z+1)
    - 6*ar[x][y][z];
    return ret / dx / dx;
  };

  for (int x=0;x<NX;++x) {
    for (int y=0;y<NY;++y) {
      for (int z=0;z<NZ;++z) {
        auto u = U[x][y][z],  v = V[x][y][z];
        auto du_dt = -Fe * u*v*v + Fu*(1-u) + Du * lap(U,x,y,z);
        auto dv_dt =  Fe * u*v*v - Fv*v     + Dv * lap(V,x,y,z);
        U_other[x][y][z] = U[x][y][z] + dt*du_dt;
        V_other[x][y][z] = V[x][y][z] + dt*dv_dt;
      }
    }
  }

  for (int x=0;x<NX;++x) {
    for (int y=0;y<NY;++y) {
      for (int z=0;z<NZ;++z) {
        U[x][y][z]=U_other[x][y][z];
      }
    }
  }
  for (int x=0;x<NX;++x) {
    for (int y=0;y<NY;++y) {
      for (int z=0;z<NZ;++z) {
        V[x][y][z]=V_other[x][y][z];
      }
    }
  }
}

void get_solution_at(int t, int x, int y, int z, Real &u, Real &v) {
  if(global_clock > t) fill_initial_condition();
  while(global_clock < t) naive_proceed();
  u = periodic(U,x,y,z);
  v = periodic(V,x,y,z);
}

int main () {

  fill_initial_condition();
  for(int x=0;x<SX;++x) {
    for(int y=0;y<SY;++y) {
      for(int z=0;z<SZ;++z) {
        double u,v; get_solution_at(0,x,y,z, u,v);
        sU0[x][y][z]=u;
        sV0[x][y][z]=v;
      }
    }
  }

  std::cerr << "Setting up wall values..." << std::endl;
  for(int t = 0;t<T_MAX;++t){
    for(int x=SX-2;x<SX;++x) {
      for(int y=0;y<SY;++y) {
        for(int z=0;z<SZ;++z) {
          double u,v; get_solution_at(t,x+t,y+t,z+t, u,v);
          Uwx[t][x-(SX-2)][y][z] = u;
          Vwx[t][x-(SX-2)][y][z] = v;
        }
      }
    }

    for(int x=0;x<SX;++x) {
      for(int y=SY-2;y<SY;++y) {
        for(int z=0;z<SZ;++z) {
          double u,v; get_solution_at(t,x+t,y+t,z+t, u,v);
          Uwy[t][x][y-(SY-2)][z] = u;
          Vwy[t][x][y-(SY-2)][z] = v;
        }
      }
    }

    for(int x=0;x<SX;++x) {
      for(int y=0;y<SY;++y) {
        for(int z=SZ-2;z<SZ;++z) {
          double u,v; get_solution_at(t,x+t,y+t,z+t, u,v);
          Uwz[t][x][y][z-(SZ-2)] = u;
          Vwz[t][x][y][z-(SZ-2)] = v;
        }
      }
    }
  }


  for(int trial=0;trial<10;++trial) {

    double time_begin = wctime();

    run_benchmark();

    double time_end = wctime();

    double flop = 29.0 * (SX-2)*(SY-2)*(SZ-2) *T_MAX;
    double time_elapse = time_end-time_begin;

    {
      const int t = T_MAX;
      double num=0,den=0;
      for(int x=0;x<SX-2;++x) {
        for(int y=0;y<SY-2;++y) {
          for(int z=0;z<SZ-2;++z) {
            double u,v; get_solution_at(t,x+t,y+t,z+t, u,v);
            num += std::abs(u-sU0[x][y][z]);
            den += 1;
          }
        }
      }
      std::ostringstream msg;
      msg << SX << " " << SY << " " << SZ << " " << T_MAX << " "
          << " t: " << time_elapse << " GFlops: " << flop/time_elapse/1e9<< " error: " << (num/den);
      std::ofstream log_file("benchmark.txt", std::ios::app);
      std::cout << msg.str() << std::endl;
      log_file << msg.str() << std::endl;
    }
  }
}

\end{code}

\verb`slave.c`
\begin{code}
#include <stdio.h>
#include "param.h"

extern Real sU0[SX][SY][SZ], sV0[SX][SY][SZ];
extern Real Uwx[T_MAX][2][SY][SZ], Uwy[T_MAX][SX][2][SZ], Uwz[T_MAX][SX][SY][2];
extern Real Vwx[T_MAX][2][SY][SZ], Vwy[T_MAX][SX][2][SZ], Vwz[T_MAX][SX][SY][2];


// double-buffered simulation state
Real sU[SX][SY][SZ], sV[SX][SY][SZ];
Real sU_1[SX][SY][SZ], sV_1[SX][SY][SZ];


void run_benchmark(){

  printf("Carrying out simulation...\n");

  // set initial condition
  for(int x=0;x<SX;++x) {
    for(int y=0;y<SY;++y) {
      for(int z=0;z<SZ;++z) {
        sU[x][y][z]=sU0[x][y][z];
        sV[x][y][z]=sV0[x][y][z];
      }
    }
  }

  for(int t = 0; t < T_MAX; ++t){
    // load communication values
    for(int x=SX-2;x<SX;++x) {
      for(int y=0;y<SY;++y) {
        for(int z=0;z<SZ;++z) {
          sU[x][y][z] = Uwx[t][x-(SX-2)][y][z];
          sV[x][y][z] = Vwx[t][x-(SX-2)][y][z];
        }
      }
    }

    for(int x=0;x<SX-2;++x) {
      for(int y=SY-2;y<SY;++y) {
        for(int z=0;z<SZ;++z) {
          sU[x][y][z] = Uwy[t][x][y-(SY-2)][z];
          sV[x][y][z] = Vwy[t][x][y-(SY-2)][z];
        }
      }
    }

    for(int x=0;x<SX-2;++x) {
      for(int y=0;y<SY-2;++y) {
        for(int z=SZ-2;z<SZ;++z) {
          sU[x][y][z] = Uwz[t][x][y][z-(SZ-2)];
          sV[x][y][z] = Vwz[t][x][y][z-(SZ-2)];
        }
      }
    }



    // destructively update the state
#define lap(ar, x, y, z)                        \
    ( ar[x][y+1][z+1] + ar[x+2][y+1][z+1]       \
      + ar[x+1][y][z+1] + ar[x+1][y+2][z+1]     \
      + ar[x+1][y+1][z] + ar[x+1][y+1][z+2]     \
        - 6*ar[x+1][y+1][z+1]) / dx / dx

    for(int x=0;x<SX-2;++x) {
      for(int y=0;y<SY-2;++y) {
        for(int z=0;z<SZ-2;++z) {
          Real u=sU[x+1][y+1][z+1] ;
          Real v=sV[x+1][y+1][z+1] ;

          Real du_dt = -Fe * u*v*v + Fu*(1-u) + Du * lap(sU,x,y,z);
          Real dv_dt =  Fe * u*v*v - Fv*v     + Dv * lap(sV,x,y,z);
          sU_1[x][y][z] = u+dt*du_dt;
          sV_1[x][y][z] = v+dt*dv_dt;
        }
      }
    }


    for(int x=0;x<SX-2;++x) {
      for(int y=0;y<SY-2;++y) {
        for(int z=0;z<SZ-2;++z) {
          sU[x][y][z] = sU_1[x][y][z];
          sV[x][y][z] = sV_1[x][y][z];
        }
      }
    }
  }

  // return the final condition
  for(int x=0;x<SX;++x) {
    for(int y=0;y<SY;++y) {
      for(int z=0;z<SZ;++z) {
        sU0[x][y][z]=sU[x][y][z];
        sV0[x][y][z]=sV[x][y][z];
      }
    }
  }

}

\end{code}

\verb`run.sh`
\begin{code}

cd /home/export/base/nsccwuxi_riken/riken/online1/sandbox/nushio_box/sunway-test/01-master/src/
make && make run
    
\end{code}

\subsubsection{Results}

Got the following results:

\begin{code}
TODO

\end{code}

\subsubsection{Discussion}


理論的に実現可能な性能の性能のTODO\%の性能を得た。


