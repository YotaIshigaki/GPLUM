\documentclass[10pt]{jsarticle}

\usepackage{amsmath}
\usepackage[cmintegrals]{newtxmath}
\usepackage{newtxtext}

\title{Gatherモード並列化の送信粒子リスト生成について}
\author{似鳥啓吾}

\begin{document}
\maketitle

\section{はじめに}
FDPSでは（主にSPH用として）並列近傍粒子探索の機能として、
Gatherモード、Scatterモード、あるいはその両方のSymmetricモードを
サポートしているが、送信粒子リストを作る部分の計算負荷が
GatherモードではScaterモードに対して桁で重いという問題が
顕在化している。

やるべきことは
\begin{itemize}
\item ある体積$V$に含まれる粒子セットを見つけなさい
\end{itemize}
というだけのことで、$V$が単純な直方体だとか、あるいは
重複のない直方体数個の和集合ならどうということはない。
実際問題としてGatherモード探索で用いる$V$は、
\begin{itemize}
\item 半径も中心もバラバラの沢山の球体からなる和集合で、
\item しかも球体同士のの体積重複も多い
\end{itemize}
というとても厄介な不定形状となっている。

\subsection{単純な実装と問題点}
確実に答えを得るには、
\begin{enumerate}
\item 個々の球体に対して近傍粒子探索を行い含まれる粒子リストを作る
\item 全ての球体の近傍粒子リストを「重複を排除しながら」結合する
\end{enumerate}
特に2.が面倒なのだけれど、「とりあえず動くもの」なら、
{\tt std::vector, std::sort, std::unique}の組み合わせか、
もしくは{\tt std::set}でも使うことで作ることができる。
STLが速ければこれでもいい、という気になるかもしれないが、
大きな問題は、「重複を排除する前の結合リスト」が「重複を排除した後の
結合リスト」に比べて100倍とかに大きくなってしまうことで、
これでは近傍粒子探索のコストが送信すべき粒子数の100倍になって
しまっている（とりあえず動くものができてから発覚した似鳥の設計ミスです）。

\subsection{可能な枝切り}
Scatter$\to$Gatherの二段階通信になるのは避けられないのだが、
\begin{itemize}
\item 一段回目の通信で送信済みの粒子は探索の対象外とする
\item 二段階目の送信粒子リストの作成途中であっても、
既に送信リストに登録済みの粒子は探索の対象外とする
\end{itemize}
といった工夫が可能であるように思われる。
しかし、一度ツリーに登録された粒子を「削除」する手続きは
不可能ではなくても煩雑になる（どのタイミングでセルの持つ
境界をアップデートするか？）のでできればやりたくない。

\section{記号の定義}
プロセス$A$とプロセス$B$の(直方体の領域$A$と領域 $B$の)
間の通信を考える。それぞれ$N_A$個と$N_B$個の粒子を持っている。
一段目のScatterモードの通信で領域$A$から領域$B$へ$N_{A\to B}$個の粒子が、
二段目のGatherモードの通信で領域$B$から領域$A$へ$N_{B\to A}$個の粒子が
送られるものとする。
正反対の通信も実際には発生するが、記号を簡略化するためにここでは
考えないことにする。
こうすることで、考えるべきは、領域$B$において（プロセス$B$が）、
受け取った$N_{A\to B}$個の粒子情報（座標と半径）から送信すべき
$N_{B\to A}$個の粒子を決定する方法になる。

受け取った$N_{A\to B}$個の粒子から（外側境界を持った）ツリーを
作ることになると思うが、こちらは「ツリー$A$」と呼んでしまうことにする。
また、領域$B$にいる$N_B$個の粒子からは既に内側外側両方の境界を
持ったツリーが構築済みのはずで、こちらは普通に「ツリー$B$」と呼ぶ。

球体を沢山重ねた複雑な形状の領域は$V_{A\to B}$とでも呼んでおき、
プロセス$B$の持つ粒子のうち未送信でかつこの領域の内側に入るものを
列挙したい。

\section{探索アルゴリズム}

\subsection{オリジナルのもの}
オーダーは$\mathcal O (N_{A\to B} \log N_B)$となる。
なぜなら、$N_{A\to B}$個の粒子に対してツリー$B$を辿って
近傍粒子探索を行うから。
実際には$\log N_B$というよりは近傍粒子数程度のファクターが
かかっていてScatterモードに比べて桁で遅い。

\subsection{重複の排除が不要なもの}
これ自体はとても効率の良いアルゴリズムとはいえないのだけど、
こらをベースに最適化を考えて行こうと思う。
プロセス$B$の全ての$N_B$粒子、ないしこれから一段回目で送信済み
なものをスキップしたうえで、ツリー$A$を辿ることで$V_{A\to B}$に
含まれるものを抽出する。
この場合は$\mathcal O (N_B \log N_{A\to B})$になる。
明らかに$V_{A\to B}$に含まれない粒子に対してもループが回るので
効率は悪いが、殆どの粒子は再帰に入ることもなくスキップされる。

ツリー$A$側に次のようなメソッドがあればいい（擬似コード）：
\begin{verbatim}
bool TreeA.does_include(const Vec3 pos);
\end{verbatim}
自身の外側境界の外に粒子があれば単に{\tt false}を返し、
内側にあった場合は子ノードを再帰呼び出しし、ひとつでも
{\tt true}があれば{\tt true}を、そうでなければ{\tt false}
を返す。
\begin{verbatim}
for(int ic=0; ic<8; ic++){
    if(child[ic].does_include(pos)) return true;
}
return false;
\end{verbatim}
直方体バージョンも後で使うかも。
\begin{verbatim}
bool TreeA.has_overlap_with(const Orthotope ot);
\end{verbatim}

\subsection{領域$B$側のツリーも使う}
領域$B$側のツリーも使えば、セル単位で$V_{A\to B}$と
オーバーラップの無いものをスキップできて効率が改善できる。
いわゆるFMMで用いるようなdouble traverseになるが、次のような
場合は注意が必要：\\
ツリー$B$のひとつのセルが、
ツリー$A$の複数のセルと相互作用する場合、
同じ粒子が重複して送信リストに登録されるおそれがある。

ダブルトラバースそのものは、再帰を使えば簡単に書ける。
\begin{enumerate}
\item ツリー$A$は外側境界を、ツリー$B$は内側境界を使う
\item 最初は双方のツリーのルートセル同士を「相互作用」させる
\item 直方体同士に重なりが無ければそれ以上の探索は不要
\item 重なりがある場合は、どちらかのツリーを下に降り、
8つの子セルを相手と「相互作用」させる
\end{enumerate}
実際問題としてどちらのツリーを下に降りるべきかにある程度の
任意性があって、階層の浅い方、または体積の大きい方を優先して
下るのがいいだろう。

これだとやっぱりリスト重複が避けられないので、ツリー$A$を辿る
ときは常にルートからということにして、3.2から辿る粒子数を$N_B$から
減らしてみる。
\begin{enumerate}
\item ツリー$B$をルートから下へ降りて行く
  \begin{enumerate}
  \item if セルの外側境界が領域$A$とオーバーラップしていたら下へ降りる（セル内に送信済み粒子が混ざっているから）
  \item else セルの内側境界が$V_{A\to B}$とオーバーラップしていたら下へ降りる（送るべき粒子が混ざっているから）、
  この判定のためには内側境界でツリー$A$を辿る
  \item else どちらのオーバーラップも無ければ探索終了、return
  \end{enumerate}
\item リーフまで来たら、粒子でもやることは同じ。先ずは送信済みでないことを領域$A$との
距離計算で確認し、未送信だったらツリー$A$を辿ることで$V_{A\to B}$に含まれるかを確認、
含まれていれば送信リストにpush back
\end{enumerate}
これでオーダーは$\mathcal O( (N_{B\to A} + \log N_B) \log N_{A\to B} )$ぐらいになる。
速いかはわからないけど、実装するのは簡単そう。

\end{document}

