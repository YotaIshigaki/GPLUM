%================================
%   この節の概要/内容について
%================================
本節では、前節(第\ref{sec:getting_started}節)で動かしたサンプルコードについての解説を行う。特に、ユーザが定義しなければならない\structure (以後、\textbf{ユーザ定義型}と呼ぶ)やFDPSの各種APIの使い方について詳しく述べる。\ul{説明の重複を避けるため、いくつかの事項に関しては、その詳細な説明が{$N$}体シミュレーションコードの節でのみ行われている}。そのため、SPHシミュレーションだけに興味があるユーザも、$N$体シミュレーションコードの節に目を通して頂きたい。

%======================
%   N体コード
%======================
\subsection{$N$体シミュレーションコード}
\label{subsec:how_to_use:nbody}

\subsubsection{ソースファイルの場所と構成}
ソースファイルは\dirNameNbodySample 以下にある。
\describeForEach{%C++用
サンプルコードは、次節で説明するユーザ定義型が記述されたソースコード \path{user-defined.hpp} と、$N$体シミュレーションのメインループ等が記述されたソースコード\path{main.cpp}から構成される。この他に、GCC用の\path{Makefile}がある。

}{%Fortran用
サンプルコードは、次節で説明するユーザ定義型が記述されたソースコード \path{user_defined.F90} と、$N$体シミュレーションのメインループ等が記述されたソースコード\path{f_main.F90}から構成される。この他に、GCCとIntelコンパイラ用のMakefileである\path{Makefile}と\path{Makefile.intel}がある。
}{%C用
サンプルコードは、次節で説明するユーザ定義型が記述されたソースコード \path{user_defined.h} と、相互作用関数が定義された\path{user_defined.c}、$N$体シミュレーションのメインループ等が記述されたソースコード\path{c_main.c}から構成される。この他に、GCC用の\path{Makefile}がある。
}

\subsubsection{ユーザー定義型・ユーザ定義関数}
本節では、FDPSの機能を用いて$N$体計算を行う際、ユーザーが記述しなければならない\structure と \procedure について記述する。

%-----------------------
%   FullParticle type
%-----------------------
\subsubsubsection{FullParticle型}
ユーザーはユーザ定義型の1つFullParticle型を記述しなければならない。FullParticle型には、シミュレーションを行うにあたって、$N$体粒子が持っているべき全ての物理量が含まれている。Listing~\ref{nbody_FP}に本サンプルコードのFullParticle型の実装例を示す(\describeForEach{user-defined.hpp}{\texttt{user\_defined.F90}}{\texttt{user\_defined.h}}を参照)。

\ifCpp%C++用
\lstinputlisting[linerange={17-65},caption=FullParticle型,label=nbody_FP]{../../../../sample/c++/nbody/user-defined.hpp}
\endifCpp
\ifFtn%Fortran用
\lstinputlisting[linerange={14-24},caption=FullParticle型,label=nbody_FP]{../../../../sample/fortran/nbody/user_defined.F90}
\endifFtn
\ifC%C言語
\lstinputlisting[linerange={7-18},caption=FullParticle型,label=nbody_FP]{../../../../sample/c/nbody/user_defined.h}
\endifC

\describeForCpp{%C++用
\ul{本サンプルコードでは、FullParticle型がEssentialParticleI型、EssentialParticleJ型、そして、Force型を兼ねている}。また、FullParticle型には、データのコピーするのに必要なメンバ関数\texttt{copyFromFP}と\texttt{copyFromForce}を持たせている。その他、粒子質量を返す関数である\texttt{getCharge}、粒子座標を返す関数である\texttt{getPos}が必要になる。また、積算対象のメンバ変数である加速度とポテンシャルを0クリアするための関数\texttt{clear}が必要になる。本サンプルコードでは、FDPSに備わっているファイル入出力関数を使用するため、それに必要な関数である\texttt{writeAscii()}と\texttt{readAscii()}を書いてある。
}

\describeForIF{% Fortran,C用
FDPS \progLangName インターフェースを使ってユーザコードを開発する場合、ユーザは\structure がどのユーザ定義型(FullParticle型, EssentialParticleI型, EssentialParticleJ型, Force型)に対応するかをFDPSに教えなければならない。本インターフェースにおいて、この指示は、\structure に決まった書式のコメント文を加えることによって行う(以後、この種のコメント文を\textbf{FDPS指示文}と呼ぶ)。本サンプルコードでは、FullParticle型がEssentialParticleI型、EssentialParticleJ型、そして、Force型を兼ねている。そのため、\structure がすべてのユーザ定義型に対応すること指示する以下のコメント文を記述している:
}
\ifFtn %Fortran用
\begin{screen}
\begin{spverbatim}
type, public, bind(c) :: full_particle !$fdps FP,EPI,EPJ,Force
\end{spverbatim}
\end{screen}
\endifFtn
\ifC %C言語用
\begin{screen}
\begin{spverbatim}
typedef struct full_particle { //$fdps FP,EPI,EPJ,Force
\end{spverbatim}
\end{screen}
\endifC

\describeForIF{%Fortran,C用
また、FDPSはFullParticle型のどのメンバ変数が質量や位置等の\textbf{必須物理量}(どの粒子計算でも必ず必要となる物理量、或いは、特定の粒子計算において必要とされる物理量と定義する)に対応するのかを知っていなければならない。この指示も決まった書式のコメント文をメンバ変数に対して記述することで行う。今回の例では、メンバ変数\texttt{mass}, \texttt{pos}, \texttt{vel}が、それぞれ、質量、位置、速度に対応することをFDPSに指示するため、以下の指示文が記述されている:
}
\ifFtn %Fortran用
\begin{screen}
\begin{spverbatim}
real(kind=c_double) :: mass !$fdps charge
type(fdps_f64vec) :: pos !$fdps position
type(fdps_f64vec) :: vel !$fdps velocity
\end{spverbatim}  
\end{screen}
\endifFtn
\ifC %C言語用
\begin{screen}
\begin{spverbatim}
double mass; //$fdps charge
fdps_f64vec pos; //$fdps position
fdps_f64vec vel; //$fdps velocity
\end{spverbatim}  
\end{screen}
\endifC
\describeForIF{%Fortran,C用
ただし、メンバ変数が速度であることを指示する\describeForEach{}{\texttt{!\$fdps velocity}}{\texttt{//\$fdps velocity}}は予約語であり、指示は任意である(現時点でFDPSの振舞に一切影響しない)。

FullParticle型はEssentialParticleI型、EssentialParticleJ型、Force型との間でデータの移動(データコピー)を行う。ユーザはこのコピーの仕方を指示するFDPS指示文も記述しなければならない。本サンプルコードでは、以下のように記述している:
}
\ifFtn %Fortran用
\begin{screen}
\begin{spverbatim}
!$fdps copyFromForce full_particle (pot,pot) (acc,acc)
!$fdps copyFromFP full_particle (id,id) (mass,mass) (pos,pos)
\end{spverbatim}  
\end{screen}
\endifFtn
\ifC %C言語
\begin{screen}
\begin{spverbatim}
//$fdps copyFromForce full_particle (pot,pot) (acc,acc)
//$fdps copyFromFP full_particle (id,id) (mass,mass) (pos,pos)
\end{spverbatim}  
\end{screen}
\endifC
\describeForIF{%Fortran,C用
ここで、キーワード\texttt{copyFromForce}を含む指示文は、Force型のどのメンバ変数をFullParticle型のどのメンバ変数にコピーするのかを指示するもので、FullParticle型に\ulBold{常に}記述しなければならない指示文である。一方、キーワード\texttt{copyFromFP}はFullParticle型からEssentialParticleI型およびEssentialParticleJ型へのデータコピーの仕方を指示するもので、EssentialParticleI型とEssentialParticleJ型には\ulBold{必ず}記述しなければならない指示文である。今、FullParticle型はこれら2つを兼ねているため、ここに記述している。

今、FullParticle型はForce型を兼ねている。Force型にも必ず記述しなければならない指示文がある。それは、相互作用計算において、積算対象のメンバ変数をどのように0クリアするかを指示する指示文である。本サンプルコードでは、積算対象である加速度とポテンシャルのみを0クリアすることを指示するため、次の指示文を記述している:
}
\ifFtn %Fortran用
\begin{screen}
\begin{spverbatim}
!$fdps clear id=keep, mass=keep, pos=keep, vel=keep
\end{spverbatim}
\end{screen}
\endifFtn
\ifC%C言語用
\begin{screen}
\begin{spverbatim}
//$fdps clear id=keep, mass=keep, pos=keep, vel=keep
\end{spverbatim}
\end{screen}
\endifC
\describeForIF{%Fortran,C用
ここで、キーワード\texttt{clear}の右に記述された構文 \texttt{\textit{mbr}=keep} は、メンバ変数\textit{\texttt{mbr}}の値を変更しないことを指示する構文である。

FDPS指示文の書式の詳細については、仕様書\path{doc_specs_ftn_ja.pdf}をご覧頂きたい。
}

%-----------------------
%   calcForceEpEp
%-----------------------
\subsubsubsection{相互作用関数 calcForceEpEp}
ユーザーは粒子間相互作用の仕方を記述した相互作用関数 calcForceEpEpを記述しなければならない。\procedure calcForceEpEpには、粒子-粒子相互作用計算の具体的な内容を書く必要がある。Listing~\ref{nbody_calcForceEpEp}に、本サンプルコードでの実装を示す(\describeForEach{\texttt{user-defined.hpp}}{\texttt{user\_defined.F90}}{\texttt{user\_defined.c}}を参照)。

\ifCpp%C++用
\lstinputlisting[linerange={162-186},caption=関数 calcForceEpEp,label=nbody_calcForceEpEp]{../../../../sample/c++/nbody/user-defined.hpp}
\endifCpp
\ifFtn%Fortran用
\lstinputlisting[linerange={245-292},caption=関数 calcForceEpEp,label=nbody_calcForceEpEp]{../../../../sample/fortran/nbody/user_defined.F90}
\endifFtn
\ifC%C言語用
\lstinputlisting[linerange={85-120},caption=関数 calcForceEpEp,label=nbody_calcForceEpEp]{../../../../sample/c/nbody/user_defined.c}
\endifC

\ifCpp%C++用
ここに示したのは、Phantom-GRAPEライブラリを使用せずにCPUで実行する場合の実装である。

本サンプルコードではテンプレート関数\footnote{テンプレート関数とはC++言語のテンプレート機能を関数に適用することで汎用的な関数としたものである。通常の関数では、関数の型および関数の引数の型をその場ですべて指定して記述/定義するが、テンプレート関数では、\texttt{templete <...>}内に指定された一般的なデータ型・クラスを関数定義に使用することができる(``一般的なクラス"の情報は、関数呼び出しの際にテンプレート引数として渡す。このため、コンパイル時にテンプレート関数のすべての型は問題なく決定される)。これによって、一般的な関数を定義することが可能となる。}を用いて実装している。また、テンプレート関数の引数は、EssentialParticleIの配列、EssentialParticleIの個数、EssentialParticleJの配列、EssentialParticleJの個数、Force型の配列である。
\endifCpp
\ifIF%Fortran,C用
本サンプルコードでは、\procedure \texttt{calc\_gravity\_ep\_ep}として実装されている。\procedure の仮引数は、EssentialParticleIの配列、EssentialParticleIの個数、EssentialParticleJの配列、EssentialParticleJの個数、Force型の配列である。本サンプルコードでは、FullParticle型がすべてのユーザ定義型を兼ねているため、引数のデータ型はすべて\texttt{full\_particle}型となっていることに注意して頂きたい。
\endifIF

%-----------------------
%   calcForceEpSp
%-----------------------
\describeForIF{%Fortran,C用
\subsubsubsection{相互作用関数 calcForceEpSp}
ユーザーは粒子-超粒子間相互作用の仕方を記述した相互作用関数 calcForceEpSpを記述しなければならない。calcForceEpSpには、粒子-超粒子相互作用計算の具体的な内容を書く必要があり、\procedure として実装しなければならない。Listing~\ref{nbody_calcForceEpSp}に、本サンプルコードでの実装を示す(\describeForEach{}{\texttt{user\_defined.F90}}{\texttt{user\_defined.c}}を参照)。
}
\ifFtn%Fortran用
\lstinputlisting[linerange={295-332},caption=関数 calcForceEpSp,label=nbody_calcForceEpSp]{../../../../sample/fortran/nbody/user_defined.F90}
\endifFtn
\ifC%C言語用
\lstinputlisting[linerange={122-157},caption=関数 calcForceEpSp,label=nbody_calcForceEpSp]{../../../../sample/c/nbody/user_defined.c}
\endifC
\describeForIF{%Fortran,C用
本サンプルコードでは、\procedure \texttt{calc\_gravity\_ep\_sp}として実装されている。\procedure の仮引数は、EssentialParticleIの配列、EssentialParticleIの個数、超粒子の配列、超粒子の個数、Force型の配列である。本サンプルコードでは、FullParticle型がすべてのユーザ定義型を兼ねているため、引数のForce型は\texttt{full\_particle}型となっていることに注意して頂きたい。ここで指定する超粒子型はこの相互作用計算を実施するのに使用するツリーオブジェクトの種別と適合していなければならない。
}

\subsubsection{プログラム本体}
\label{subsubsec:nbody_sample_main_part}
\describeForCpp{%C++用
本節では、FDPSを用いて$N$体計算を行うにあたり、メイン関数に書かれるべき関数に関して解説する。メイン関数はサンプルコード\texttt{nbody.cpp}内に記述されている。
}
\describeForIF{%Fortran,C用
本節では、FDPS \progLangName インターフェースを用いて$N$体計算を行うにあたり、``\mainFunc" \mainFuncName に書かれるべき\procedure や\function に関して解説する。ここで、\mainFunc とはっきり書かないのは、次の理由による: FDPS \progLangName インターフェースを使用する場合、ユーザコードは必ず\usaw{\procedure} \mainFuncName の下に記述されなければならず、ユーザコードは正しい意味での\mainFunc を持たない(\mainFunc はインターフェースプログラムのC++ソースコード内にある)。しかし、実質的には\procedure \mainFuncName が\mainFunc の役割を果たす。そのため、敢えて``\mainFunc"という言葉を使った。\mainFunc という言葉は、それがユーザコードの入り口であることを示すのに適しているので、以後、\mainFuncName を\mainFunc と呼ぶことにする。本サンプルコードの\mainFunc は\fileNameOfMainFunc に記述されている。
}

\ifCpp%C++用
\subsubsubsection{ヘッダーファイルのインクルード}
FDPSの標準機能を利用できるようにするため、\texttt{particle\_simulator.hpp}をインクルードする。
\begin{lstlisting}[caption=ヘッダーファイル\texttt{particle\_simulator.hpp}のインクルード]
#include <particle_simulator.hpp>
\end{lstlisting}
\endifCpp
\ifFtn%Fortran用
\subsubsubsection{\texttt{fdps\_controller}型オブジェクトの生成}
FDPS Fortran インターフェースにおいて、FDPSのAPIはすべてFortran 2003のクラス\texttt{FDPS\_controller}のメンバ関数として提供される。このクラスは、インターフェースプログラムの1つである\texttt{FDPS\_module.F90}の中の、モジュール\texttt{fdps\_module}内で定義されている。したがって、ユーザはFDPSのAPIを使用するために、\texttt{FDPS\_controller}型オブジェクトを生成しなければならない。本サンプルコードでは、\texttt{FDPS\_controller}型オブジェクト\texttt{fdps\_ctrl}をメインルーチンで生成している:
\begin{lstlisting}[caption=\texttt{fdps\_controller}型オブジェクトの生成]
subroutine f_main()
   use fdps_module
   implicit none
   !* Local variables
   type(fdps_controller) :: fdps_ctrl
    
   ! Do something
   
end subroutine f_main    
\end{lstlisting}
ここに示したコードは実際にサンプルコードから必要な部分だけを取り出したものであることに注意して頂きたい。

上記の理由から、以下の説明において、FDPSのAPIはこのオブジェクトのメンバ関数として呼び出されていることに注意されたい。
\endifFtn
\ifC %C言語用
\subsubsubsection{ヘッダーファイルのインクルード}
FDPSの標準機能を利用できるようにするため、\texttt{FDPS\_c\_if.h}をインクルードする。
\begin{lstlisting}[caption=ヘッダーファイル\texttt{FDPS\_c\_if.h}のインクルード]
#include "FDPS_c_if.h"
\end{lstlisting}
\endifC

\subsubsubsection{開始、終了}
まずは、FDPSの初期化/開始を行う必要がある。次のように、\mainFunc に記述する。
\ifCpp%C++用
\begin{lstlisting}[caption=FDPSの開始]
PS::Initialize(argc, argv);
\end{lstlisting}
\endifCpp
\ifFtn%Fortran用
\begin{lstlisting}[caption=FDPSの開始]
call fdps_ctrl%ps_initialize()
\end{lstlisting}
\endifFtn
\ifC%C言語用
\begin{lstlisting}[caption=FDPSの開始]
fdps_initialize();
\end{lstlisting}
\endifC


FDPSは、開始したら明示的に終了させる必要がある。今回は、プログラムの終了と同時にFDPSも終了させるため、\mainFunc の最後に次のように記述する。
\ifCpp%C++用
\begin{lstlisting}[caption=FDPSの終了]
PS::Finalize();
\end{lstlisting}
\endifCpp
\ifFtn%Fortran用
\begin{lstlisting}[caption=FDPSの終了]
call fdps_ctrl%ps_finalize()
\end{lstlisting}
\endifFtn
\ifC%C言語用
\begin{lstlisting}[caption=FDPSの終了]
fdps_finalize();
\end{lstlisting}
\endifC

\subsubsubsection{オブジェクトの生成・初期化}
FDPSの初期化に成功した場合、ユーザーはコード中で用いるオブジェクトを作成する必要がある。本節では、オブジェクトの生成/初期化の仕方について解説する。

\subsubsubsubsection{オブジェクトの生成}
\ifCpp%C++用
今回の計算では、粒子群クラス、領域クラスに加え、重力計算用の相互作用ツリーを一本生成する必要がある。以下にそのコードを記す。これらはサンプルコード\texttt{nbody.cpp}の\texttt{main}関数内に記述されている。
\begin{lstlisting}[caption=オブジェクトの生成]
PS::DomainInfo dinfo;
PS::ParticleSystem<FPGrav> system_grav;
PS::TreeForForceLong<FPGrav, FPGrav, FPGrav>::Monopole tree_grav;
\end{lstlisting}
\endifCpp
\describeForIF{%Fortran,C用
今回の計算では、粒子群オブジェクト、領域情報オブジェクトに加え、重力計算用のツリーオブジェクトを1個生成する必要がある。\progLangName インターフェースでは、これらオブジェクトはすべて整数変数に格納された識別番号を使って操作する。したがって、まず識別番号を格納する整数変数を用意したあとに、オブジェクトを生成するAPIを呼び出す必要がある。以下にそのコードを記す。これらはサンプルコード\fileNameOfMainFunc の\mainFunc 内に記述されている。
}
\ifFtn%Fortran用
\begin{lstlisting}[caption=オブジェクトの生成]
subroutine f_main()
   use fdps_module
   use user_defined_types
   implicit none
   !* Local variables
   integer :: psys_num,dinfo_num,tree_num
   
   !* Create FDPS objects
   call fdps_ctrl%create_dinfo(dinfo_num)
   call fdps_ctrl%create_psys(psys_num,'full_particle')
   call fdps_ctrl%create_tree(tree_num, &
                              "Long,full_particle,full_particle,full_particle,Monopole")

end subroutine f_main
\end{lstlisting}
\endifFtn
\ifC%C言語用
\begin{lstlisting}[caption=オブジェクトの生成]
void c_main() {
   
    // Create and initialize dinfo object
    int dinfo_num;
    fdps_create_dinfo(&dinfo_num);
    // Create and initialize psys object
    int psys_num;
    fdps_create_psys(&psys_num,"full_particle");
    // Create and initialize tree object
    int tree_num;
    fdps_create_tree(&tree_num,
                     "Long,full_particle,full_particle,full_particle,Monopole");

}
\end{lstlisting}
\endifC
\describeForIF{%Fortran,C用
ここでも、実際のサンプルコードから該当部分だけを抜き出していることに注意して頂きたい。

上に示すように、粒子群オブジェクトを生成する際にはFullParticle型に対応する\structure 名を文字列としてAPIの引数に渡す必要がある。同様に、ツリーオブジェクト生成の際には、ツリーの種別を示す文字列をAPIの引数に渡す必要がある。両APIにおいて、\textbf{\ul{{\structure} 名は小文字で入力されなければならない}}。
}

\subsubsubsubsection{領域情報オブジェクトの初期化}
ユーザーはオブジェクトを作成したら、そのオブジェクトの初期化を行う必要がある。本サンプルコードでは周期境界等は用いていないため、領域情報オブジェクトの初期化はAPI \initDinfo を実行するだけでよい:
\ifCpp%C++用
\begin{lstlisting}[caption=領域クラスの初期化]
const PS::F32 coef_ema = 0.3;
dinfo.initialize(coef_ema);
\end{lstlisting}
\endifCpp
\ifFtn%Fortran用
\begin{lstlisting}[caption=領域オブジェクトの初期化]
call fdps_ctrl%init_dinfo(dinfo_num,coef_ema)
\end{lstlisting}
\endifFtn
\ifC%C言語用
\begin{lstlisting}[caption=領域オブジェクトの初期化]
fdps_init_dinfo(dinfo_num,coef_ema);
\end{lstlisting}
\endifC
ここで、API \initDinfo の第\describeForEach{1}{2}{2}引数は領域分割に使用される指数移動平均の平滑化係数を表す。この係数の意味については仕様書に詳しい解説があるので、そちらを参照されたい。

\subsubsubsubsection{粒子群オブジェクトの初期化}
次に、粒子群オブジェクトの初期化を行う必要がある。粒子群オブジェクトの初期化は、API \initPsys で行う:
\ifCpp%C++用
\begin{lstlisting}[caption=粒子群クラスの初期化]
system_grav.initialize();
\end{lstlisting}
\endifCpp
\ifFtn%Fortran用
\begin{lstlisting}[caption=粒子群オブジェクトの初期化]
call fdps_ctrl%init_psys(psys_num)
\end{lstlisting}
\endifFtn
\ifC%C言語
\begin{lstlisting}[caption=粒子群オブジェクトの初期化]
fdps_init_psys(psys_num);
\end{lstlisting}
\endifC

\subsubsubsubsection{ツリーオブジェクトの初期化}
次に、ツリーオブジェクトの初期化を行う必要がある。ツリーオブジェクトの初期化はAPI \initTree で行う。このAPIには、引数としてツリーオブジェクト内部で使用する配列の大きさの初期値を渡す必要がある。これはローカル粒子数(\texttt{n\_loc})程度で十分であるため、そのようにセットする:
\ifCpp%C++用
\begin{lstlisting}[caption=相互作用ツリークラスの初期化]
tree_grav.initialize(n_loc, theta, n_leaf_limit, n_group_limit);
\end{lstlisting}
\endifCpp
\ifFtn%Fortran用
\begin{lstlisting}[caption=ツリーオブジェクトの初期化]
call fdps_ctrl%init_tree(tree_num,n_loc,theta, &
                         n_leaf_limit,n_group_limit)
\end{lstlisting}
\endifFtn
\ifC%C言語
\begin{lstlisting}[caption=ツリーオブジェクトの初期化]
fdps_init_tree(tree_num,n_loc,theta,
               n_leaf_limit,n_group_limit);
\end{lstlisting}
\endifC

\describeForEach{%C++用
このAPIには3つの省略可能引数が存在し、サンプルコードではこれらを省略せずに指定している:
}{%Fortran用
このAPIには3つの省略可能引数が存在し、サンプルコードではこれらを省略せずに指定している:
}{%C言語
このAPIの第3引数以降の引数の意味は次の通りである:
}
\begin{itemize}[leftmargin=*,itemsep=-1ex,topsep=0.2ex]
\item \texttt{theta} --- ツリー法で力の計算をする場合の見込み角についての基準
\item \texttt{n\_leaf\_limit} --- ツリーを切るのをやめる粒子数の上限
\item \texttt{n\_group\_limit} --- 相互作用リストを共有する粒子数の上限
\end{itemize}

\describeForIF{%Fortran,C用
\subsubsubsection{粒子データの初期化}
\label{s3sec:nbody_initialize_ptcl_data}
初期条件の設定を行うためには、粒子群オブジェクトに粒子データを入力する必要がある。(既にAPI \initPsys で初期化済みの)粒子群オブジェクトに、FullParticle型粒子のデータを格納するには、粒子群オブジェクトのAPI \setNptclLoc と \getPsysPtr を用いて、次のように行う:
}
\ifFtn%Fortran用
\begin{lstlisting}[caption=粒子データの初期化]
subroutine foo(fdps_ctrl,psys_num)
   use fdps_vector
   use fdps_module
   use user_defined_types
   implicit none
   type(fdps_controller), intent(IN) :: fdps_ctrl
   integer, intent(IN) :: psys_num
   !* Local variables
   integer :: i,nptcl_loc
   type(full_particle), dimension(:), pointer :: ptcl

   !* Set # of local particles
   call fdps_ctrl%set_nptcl_loc(psys_num,nptcl_loc)

   !* Get the pointer to full particle data
   call fdps_ctrl%get_psys_fptr(psys_num,ptcl)
   
   !* Initialize particle data
   do i=1,nptcl_loc
      ptcl(i)%pos = ! Do something
   end do
   
   !* Release the pointer
   nullify(ptcl)

end subroutine foo
\end{lstlisting}
\endifFtn
\ifC%C言語用
\begin{lstlisting}[caption=粒子データの初期化]
void foo(psys_num) {
   // Set # of local particles
   nptcl_loc = 1024; 
   fdps_set_nptcl_loc(psys_num,nptcl_loc);

   // Get the pointer to full particle data
   Full_particle *ptcl = (Full_particle *)  fdps_get_psys_cptr(psys_num);
   
   // Initialize particle data
   int i;
   for (i = 0; i < nptcl_loc; i++) {
      ptcl[i].pos.x = /* Do something */ ;
   }
   
}
\end{lstlisting}
\endifC
\describeForIF{%Fortran,C用
まず、粒子群オブジェクトに粒子データを保存するのに必要なメモリを確保しなければならない。これを行うには API \setNptclLoc を実行すればよい。このAPIは指定された粒子群オブジェクトのローカル粒子数(自プロセスが管理する粒子数)の値を設定し、かつ、その粒子数を格納するのに必要なメモリを確保する。粒子データを初期化するためには、確保されたメモリのアドレスを取得しなければならない。これにはAPI \getPsysPtr を使用する。
}
\ifFtn%Fortran用
アドレスはFortranポインタで受け取る必要がある。そのため、上記の例では、ポインタを以下のように用意している:
\begin{screen}
\begin{spverbatim}
type(full_particle), dimension(:), pointer :: ptcl
\end{spverbatim}  
\end{screen}
API \texttt{get\_psys\_fptr}によってポインタを設定した後は、ポインタを粒子配列のように使用することが可能である。上の例では、粒子データの設定が完了した後、ポインタを組込関数\texttt{nullify}によって解放している。
\endifFtn
\ifC%C言語用
アドレスは\texttt{void *}ポインタとして返ってくるため、\texttt{Full\_particle *}型にキャストしていること注意されたい。API \getPsysPtr によってポインタを設定した後は、ポインタを粒子配列のように使用することが可能である。
\endifC

\subsubsubsection{ループ}
本節では、時間積分ループの中で行わなければならないことについて、解説する。

\subsubsubsubsection{領域分割の実行}
まずは、粒子分布に基いて、領域分割を実行する。本サンプルコードでは、これを領域情報オブジェクトのAPI \decomposeDomainAll を用いて行っている:
\ifCpp%C++用
\begin{lstlisting}[caption=領域分割の実行]
if(n_loop % 4 == 0){
   dinfo.decomposeDomainAll(system_grav);
}
\end{lstlisting}
\endifCpp
\ifFtn%Fortran用
\begin{lstlisting}[caption=領域分割の実行]
if (mod(num_loop,4) == 0) then
   call fdps_ctrl%decompose_domain_all(dinfo_num,psys_num)
end if
\end{lstlisting}
\endifFtn
\ifC%C言語用
\begin{lstlisting}[caption=領域分割の実行]
if (num_loop % 4 == 0) {
   fdps_decompose_domain_all(dinfo_num,psys_num,-1.0);
}
\end{lstlisting}
\endifC
ここで、計算時間の節約のため、領域分割は4ループ毎に1回だけ行うようにしている。
\describeForC{第3引数は、領域分割する際に、自プロセスからどれだけ粒子をサンプリングするかを表す``重み"を表す変数である。この変数は$>0$である必要があるが、負値が指定された場合、FDPSのデフォルト値が採用される。詳細は仕様書を参照されたい。}

\subsubsubsubsection{粒子交換の実行}
次に、領域情報に基いて、プロセス間の粒子の情報を交換する。これには、粒子群オブジェクトのAPI \exchangeParticle を用いる:
\ifCpp%C++用
\begin{lstlisting}[caption=粒子交換の実行]
system_grav.exchangeParticle(dinfo);
\end{lstlisting}
\endifCpp
\ifFtn%Fortran用
\begin{lstlisting}[caption=粒子交換の実行]
call fdps_ctrl%exchange_particle(psys_num,dinfo_num)
\end{lstlisting}
\endifFtn
\ifC%C言語用
\begin{lstlisting}[caption=粒子交換の実行]
fdps_exchange_particle(psys_num,dinfo_num);
\end{lstlisting}
\endifC


\subsubsubsubsection{相互作用計算の実行}
領域分割・粒子交換が終了したら、相互作用の計算を行う。これには、ツリーオブジェクトのAPI \calcForceAllAndWriteBack を用いる:
\ifCpp%C++用
\begin{lstlisting}[caption=相互作用計算の実行]
tree_grav.calcForceAllAndWriteBack(CalcGravity<FPGrav>,
                                   CalcGravity<PS::SPJMonopole>,
                                   system_grav,
                                   dinfo);
\end{lstlisting}
ここで、メソッドの引数に\texttt{CalcGravity<....>}のような記述があるが、この\texttt{<...>}内に書かれているものがテンプレート引数である。
\endifCpp
\ifFtn%Fortran用
\begin{lstlisting}[caption=相互作用計算の実行]
subroutien f_main()
   use, intrinsic :: iso_c_binding
   use user_defined_types
   implicit none
   !* Local variables
   type(c_funptr) :: pfunc_ep_ep,pfunc_ep_sp
   
   ! Do somehting
   
   pfunc_ep_ep = c_funloc(calc_gravity_ep_ep)
   pfunc_ep_sp = c_funloc(calc_gravity_ep_sp)
   call fdps_ctrl%calc_force_all_and_write_back(tree_num,    &
                                                pfunc_ep_ep, &
                                                pfunc_ep_sp, &
                                                psys_num,    &
                                                dinfo_num)

   ! Do something

end subroutine f_main
\end{lstlisting}
ここで、APIの第2,3引数には関数calcForceEpEp, calcForceEpSpの(C言語アドレス\footnote{C言語方式で記述されたアドレス情報のこと。}としての)関数ポインタを指定する。関数のC言語アドレスは、Fortran 2003で導入された組込関数\texttt{c\_funloc}を使って取得する(この組込み関数はモジュール\texttt{iso\_c\_binding}で提供されるため、\texttt{use}文を使い、このモジュールを利用可能にしている)。C言語アドレスを格納するためには、同じくFortran 2003で導入された派生データ型 \texttt{c\_funptr}の変数が必要である。そのため、本サンプルコードでは、\texttt{c\_funptr}型変数として、\texttt{pfunc\_ep\_ep}と\texttt{pfunc\_ep\_sp}を用意している。ここに、\texttt{calc\_gravity\_ep\_ep}と\texttt{calc\_gravity\_ep\_sp}のC言語アドレスを格納した上で、APIに渡している。
\endifFtn
\ifC%C言語用
\begin{lstlisting}[caption=相互作用計算の実行]
void c_main() {
   
   // Do somehting
   
   fdps_calc_force_all_and_write_back(tree_num,
                                      calc_gravity_ep_ep,
                                      calc_gravity_ep_sp,
                                      psys_num,
                                      dinfo_num,
                                      true,
                                      FDPS_MAKE_LIST);

   // Do something

}
\end{lstlisting}
ここで、APIの第2,3引数には関数calcForceEpEp, calcForceEpSpの関数ポインタを指定する。第6引数には、前回の相互作用計算の結果をクリアするかどうかを\texttt{\_Bool}値で指定する。第7引数は、相互作用リストの再利用を行うかどうかを指示するフラグで、ここでは新規に相互作用リストを作成して相互作用計算を行うモードを選択している。
\endifC


\subsubsubsubsection{時間積分} \label{s4sec:nbody_time_integration}
本サンプルコードでは、時間積分をLeapfrog時間積分法によって行う。時間積分は形式的に、$K(\frac{\Delta t}{2})D(\Delta t)K(\frac{\Delta t}{2})$と表される。ここで、$\Delta t$は時間刻み、$K(\cdot)$は速度を指定された時間だけ時間推進するオペレータ、$D(\cdot)$は位置を指定された時間だけ時間推進するオペレータである。本サンプルコードにおいて、これらのオペレータは、\procedure \texttt{kick}と\procedure \texttt{drift}として実装している。

時間積分ループの最初で、最初の$D(\Delta t)K(\frac{\Delta t}{2})$の計算を行い、粒子の座標と速度の情報を更新している:
\ifCpp%C++用
\begin{lstlisting}[caption=$D(\Delta t)K(\frac{\Delta t}{2})$オペレータの計算]
kick(system_grav, dt * 0.5);
drift(system_grav, dt);
\end{lstlisting}
\endifCpp
\ifFtn%Fortran用
\begin{lstlisting}[caption=$D(\Delta t)K(\frac{\Delta t}{2})$オペレータの計算]
!* Leapfrog: Kick-Drift
call kick(fdps_ctrl,psys_num,0.5d0*dt)
time_sys = time_sys + dt
call drift(fdps_ctrl,psys_num,dt)
\end{lstlisting}
\endifFtn
\ifC%C言語用
\begin{lstlisting}[caption=$D(\Delta t)K(\frac{\Delta t}{2})$オペレータの計算]
// Leapfrog: Kick-Drift
kick(psys_num,0.5*dt);
time_sys +=  dt;
drift(psys_num,dt);
\end{lstlisting}
\endifFtn


時間積分ループの次の部分では、力の計算を行い、その後、最後の$K(\frac{\Delta t}{2})$の計算を行っている:
\ifCpp%C++用
\begin{lstlisting}[caption=$K(\frac{\Delta t}{2})$オペレータの計算]
kick(system_grav, dt * 0.5);
\end{lstlisting}
\endifCpp
\ifFtn%Fortran用
\begin{lstlisting}[caption=$K(\frac{\Delta t}{2})$オペレータの計算]
!* Leapfrog: Kick
call kick(fdps_ctrl,psys_num,0.5d0*dt)
\end{lstlisting}
\endifFtn
\ifC%C言語用
\begin{lstlisting}[caption=$K(\frac{\Delta t}{2})$オペレータの計算]
// Leapfrog: Kick
kick(psys_num,0.5d0*dt);
\end{lstlisting}
\endifC

\describeForIF{%Fortran,C用
\subsubsubsection{粒子データの更新}
上記で説明した\texttt{kick}や\texttt{drift}等の\procedure で、粒子データを更新するためには、粒子群オブジェクトに格納されている粒子データにアクセスする必要がある。これは、第\ref{s3sec:nbody_initialize_ptcl_data}節で説明した方法とほぼ同様に行う:
}
\ifFtn%Fortran用
\begin{lstlisting}[caption=粒子データの更新]
subroutine foo(fdps_ctrl,psys_num)
   use fdps_vector
   use fdps_module
   use user_defined_types
   implicit none
   type(fdps_controller), intent(IN) :: fdps_ctrl
   integer, intent(IN) :: psys_num
   !* Local variables
   integer :: i,nptcl_loc
   type(full_particle), dimension(:), pointer :: ptcl

   !* Get # of local particles
   nptcl_loc = fdps_ctrl%get_nptcl_loc(psys_num)

   !* Get the pointer to full particle data
   call fdps_ctrl%get_psys_fptr(psys_num,ptcl)
   
   !* Initialize or update particle data
   do i=1,nptcl_loc
      ptcl(i)%pos = ! Do something
   end do
   
   !* Release the pointer
   nullify(ptcl)

end subroutine foo
\end{lstlisting}
API \getPsysPtr を使い、粒子群オブジェクトに格納された粒子データのアドレスをポインタとして受け取る。受け取ったポインタは要素数 \texttt{nptcl\_loc}の粒子配列として振る舞うので、一般的な配列同様に値を更新すればよい。
\endifFtn
\ifC%C言語用
\begin{lstlisting}[caption=粒子データの更新]
void foo(psys_num) {
   // Get # of local particles
   int nptcl_loc = fdps_get_nptcl_loc(psys_num);
   
   // Get the pointer to full particle data
   Full_particle *ptcl = (Full_particle *) fdps_get_psys_cptr(psys_num);
   
   // Initialize or update particle data
   int i;
   for (i = 0; i < nptcl_loc; i++) {
      ptcl[i].pos.x = /* Do something */ ;
   }  
}
\end{lstlisting}
API \getPsysPtr を使い、粒子群オブジェクトに格納された粒子データのアドレスをポインタとして受け取る。受け取ったポインタは要素数 \texttt{nptcl\_loc}の粒子配列として振る舞うので、一般的な配列同様に値を更新すればよい。
\endifC

\subsubsection{ログファイル}
計算が正しく開始すると、標準出力に、時間・エネルギー誤差の2つが出力される。以下はその出力の最も最初のステップでの例である。
\begin{lstlisting}[caption=標準出力の例]
time:    0.0000000000E+000, energy error:   -0.0000000000E+000
\end{lstlisting}

%======================
%   固定長SPHコード
%======================
\subsection{固定長SPHシミュレーションコード}
\label{subsec:how_to_use:sph}
本節では、前節(第\ref{sec:getting_started}節)で使用した、固定smoothing lengthでの標準SPH法のサンプルコードの詳細について解説する。

\subsubsection{ソースファイルの場所と構成}
ソースファイルは\dirNameSPHSample 以下にある。
\describeForEach{%C++用
サンプルコードは、次節で説明するユーザ定義型やSPHシミュレーションのメインループ等すべてが記述された\texttt{main.cpp}とGCC用\path{Makefile}から構成される。 
}{%Fortran用
サンプルコードは、次節で説明するユーザ定義型が記述されたソースコード \path{user_defined.F90} と、SPHシミュレーションのメインループ等が記述されたソースコード\path{f_main.F90}から構成される。この他に、GCCとIntelコンパイラ用のMakefileである\path{Makefile}と\path{Makefile.intel}がある。 
}{%C言語用
サンプルコードは、次節で説明するユーザ定義型が記述されたソースコード \path{user_defined.h}、相互作用関数が記述された\path{user_defined.c}、数学定数が定義された\path{mathematical_constants.*}、SPHシミュレーションのメインループ等が記述されたソースコード\path{c_main.c}から構成される。この他に、GCC用の\path{Makefile}がある。 
}

\subsubsection{ユーザー定義型・ユーザ定義関数}
本節では、FDPSの機能を用いてSPHの計算を行う際に、ユーザーが記述しなければならない\structure と\procedure について記述する。

%-----------------------
%   FullParticle type
%-----------------------
\subsubsubsection{FullParticle型}
ユーザーはユーザ定義型の1つFullParticle型を記述しなければならない。FullParticle型には、シミュレーションを行うにあたって、SPH粒子が持っているべき全ての物理量が含まれている。Listing~\ref{sph_FP}に本サンプルコード中で用いるFullParticle型の実装例を示す(\describeForEach{main.cpp}{\texttt{user\_defined.F90}}{\texttt{user\_defined.h}}を参照)。

\ifCpp%C++用
\lstinputlisting[linerange={64-122},caption=FullParticle型,label=sph_FP]{../../../../sample/c++/sph/main.cpp}
\endifCpp
\ifFtn%Fortran用
\lstinputlisting[linerange={28-46},caption=FullParticle型,label=sph_FP]{../../../../sample/fortran/sph/user_defined.F90}
\endifFtn
\ifC%C言語用
\lstinputlisting[linerange={24-41},caption=FullParticle型,label=sph_FP]{../../../../sample/c/sph/user_defined.h}
\endifC

\describeForCpp{%C++用
また、FullParticle型には後述するForce型から、結果をコピーするのに必要なメンバ関数を持つ必要がある。その他、粒子質量を返す関数である\texttt{getCharge()}、粒子座標を返す関数である\texttt{getPos()}、近傍粒子の探索半径を返す関数である\texttt{getRSearch()}、粒子の座標を書き込む関数である\texttt{setPos()}が必要になる。本サンプルコードでは、FDPSに備わっているファイル入出力関数を用いる。そのため、これに必要な関数である\texttt{writeAscii()}と\texttt{readAscii()}を書いてある。また、これらに加え、状態方程式から圧力を計算するメンバ関数である、\texttt{setPressure()}が記述されているが、この関数はFDPSが用いるものではないため、必須のものではないことに注意する。
}
\describeForIF{%Fortran,C用
SPHサンプルコードでは$N$体サンプルコードと異なり、FullPartice型が他のユーザ定義型を兼ねることはない。したがって、この\structure がFullParticle型であることを示すため、次の指示文を記述している:
}
\ifFtn%Fortran用
\begin{screen}
\begin{spverbatim}
type, public, bind(c) :: full_particle !$fdps FP
\end{spverbatim}
\end{screen}
\endifFtn
\ifC%C言語用
\begin{screen}
\begin{spverbatim}
typedef struct full_particle { //$fdps FP
\end{spverbatim}
\end{screen}
\endifC
\describeForIF{%Fortran,C用
SPHシミュレーションにおける相互作用は短距離力である。そのため、必須物理量として探索半径が加わる。粒子位置等の指定も含め、どのメンバ変数がどの必須物理量に対応しているかの指定を次の指示文で行っている:
}
\ifFtn%Fortran用
\begin{screen}
\begin{spverbatim}
real(kind=c_double) :: mass !$fdps charge
type(fdps_f64vec) :: pos !$fdps position
real(kind=c_double) :: smth !$fdps rsearch
\end{spverbatim}
\end{screen}
\endifFtn
\ifC%C言語用
\begin{screen}
\begin{spverbatim}
double mass; //$fdps charge
fdps_f64vec pos; //$fdps position
double smth; //$fdps rsearch
\end{spverbatim}
\end{screen}
\endifC
\describeForIF{%Fortran,C用
$N$体シミュレーションコードの節で述べたように、メンバ変数が粒子速度であることを指定するキーワード\texttt{velocity}は予約語でしかないため、本サンプルコードでは指定してない。

FullParticle型はForce型との間でデータコピーを行う。ユーザは指示文を使い、FDPSにデータコピーの仕方を教えなければならない。後述するように本SPHサンプルコードには2つのForce型が存在する。したがって、ユーザはそれぞれのForce型に対して、指示文を記述する必要がある。本サンプルコードでは、以下のように記述している:
}
\ifFtn%Fortran
\begin{screen}
\begin{spverbatim}
!$fdps copyFromForce force_dens (dens,dens)
!$fdps copyFromForce force_hydro (acc,acc) (eng_dot,eng_dot) (dt,dt)
\end{spverbatim}
\end{screen}
\endifFtn
\ifC%C言語用
\begin{screen}
\begin{spverbatim}
//$fdps copyFromForce force_dens (dens,dens)
//$fdps copyFromForce force_hydro (acc,acc) (eng_dot,eng_dot) (dt,dt)
\end{spverbatim}
\end{screen}
\endifC

%-----------------------------
%   EssentialParticleI type
%-----------------------------
\subsubsubsection{EssentialParticleI型}
ユーザーはEssentialParticleI型を記述しなければならない。EssentialParticleI型には、Forceの計算を行う際、$i$粒子が持っているべき全ての物理量をメンバ変数として持っている必要がある。また、本サンプルコード中では、EssentialParticleJ型も兼ねているため、$j$粒子が持っているべき全ての物理量もメンバ変数として持っている必要がある。Listing~\ref{sph_EPI}に、本サンプルコードのEssentialParticleI型の実装例を示す(\describeForEach{\texttt{main.cpp}}{\texttt{user\_defined.F90}}{\texttt{user\_defined.h}}参照):

\ifCpp%C++用
\lstinputlisting[linerange={125-151},caption=EssentialParticleI型,label=sph_EPI]{../../../../sample/c++/sph/main.cpp}
\endifCpp
\ifFtn%Fortran用
\lstinputlisting[linerange={48-59},caption=EssentialParticleI型,label=sph_EPI]{../../../../sample/fortran/sph/user_defined.F90}
\endifFtn
\ifC%C用
\lstinputlisting[linerange={44-54},caption=EssentialParticleI型,label=sph_EPI]{../../../../sample/c/sph/user_defined.h}
\endifC

\describeForCpp{%C++用
EssentialParticleI型には前述したFullParticle型から、値をコピーするのに必要なメンバ関数を持つ必要がある。その他、粒子座標を返す関数である\texttt{getPos()}、近傍粒子の探索半径を返す関数である\texttt{getRSearch()}、粒子の座標を書き込む関数である\texttt{setPos()}が必要になる。
}
\describeForIF{%Fortran,C用
まず、ユーザは指示文を用いて、この\structure がEssentialParticleI型かつEssentialParticleJ型であることをFDPSに教えなければならない。本サンプルコードでは、以下のように記述している:
}
\ifFtn%Fortran用
\begin{screen}
\begin{spverbatim}
type, public, bind(c) :: essential_particle !$fdps EPI,EPJ
\end{spverbatim}
\end{screen}
\endifFtn
\ifC%C言語用
\begin{screen}
\begin{spverbatim}
typedef struct essential_particle { //$fdps EPI,EPJ
\end{spverbatim}
\end{screen}
\endifC
\describeForIF{%Fortran,C用
次に、ユーザはこの\structure のどのメンバ変数がどの必須物理量に対応するのかを指示文によって指定しなければならない。今回はSPHシミュレーションを行うので探索半径の指定も必要である。本サンプルコードでは、以下のように記述している:
}
\ifFtn %Fortran用
\begin{screen}
\begin{spverbatim}
type(fdps_f64vec) :: pos !$fdps position
real(kind=c_double) :: mass !$fdps charge
real(kind=c_double) :: smth !$fdps rsearch
\end{spverbatim}
\end{screen}
\endifFtn
\ifC %C言語用
\begin{screen}
\begin{spverbatim}
fdps_f64vec pos; //$fdps position
double mass; //$fdps charge
double smth; //$fdps rsearch
\end{spverbatim}
\end{screen}
\endifC
\describeForIF{%Fortran,C用
EssentialParticleI型とEssentialParticleJ型はFullParticle型からデータを受け取る。ユーザはFullParticle型のどのメンバ変数をEssentialParticle?型(?=I,J)のどのメンバ変数にコピーするのかを、指示文を用いて指定する必要がある。本サンプルコードでは、以下のように記述している:
}
\ifFtn %Fortran用
\begin{screen}
\begin{spverbatim}
!$fdps copyFromFP full_particle (id,id) (pos,pos) (vel,vel) (mass,mass) (smth,smth) (dens,dens) (pres,pres) (snds,snds)
\end{spverbatim}
\end{screen}
\endifFtn
\ifC %C言語用
\begin{screen}
\begin{spverbatim}
//$fdps copyFromFP full_particle (id,id) (pos,pos) (vel,vel) (mass,mass) (smth,smth) (dens,dens) (pres,pres) (snds,snds)
\end{spverbatim}
\end{screen}
\endifC

%----------------
%   Force type
%----------------
\subsubsubsection{Force型}
ユーザーはForce型を記述しなければならない。Force型には、Forceの計算を行った際にその結果として得られる全ての物理量をメンバ変数として持っている必要がある。また、本サンプルコード中では、Forceの計算は密度の計算と流体相互作用計算の2つが存在するため、Force型は2つ書く必要がある。Listing~\ref{sph_Force}に、本サンプルコード中で用いるForce型の実装例を示す。

\ifCpp %C++用
\lstinputlisting[linerange={44-61},caption=Force型,label=sph_Force]{../../../../sample/c++/sph/main.cpp}
\endifCpp
\ifFtn %Fortran用
\lstinputlisting[linerange={14-26},caption=Force型,label=sph_Force]{../../../../sample/fortran/sph/user_defined.F90}
\endifFtn
\ifC %C言語用
\lstinputlisting[linerange={10-21},caption=Force型,label=sph_Force]{../../../../sample/c/sph/user_defined.h}
\endifC

\describeForCpp{%C++用
この例の\texttt{Dens}クラスには、smoothing lengthを表すメンバ変数\texttt{smth}が用意されている。本来、固定長SPHでは、Force型にsmoothing lengthに対応するメンバを持たせる必要はない。しかし、ここでは、ユーザが将来的に可変長SPHに移行することを想定して用意してある。可変長SPHのformulationの1つであるSpringel [2005,MNRAS,364,1105]の方法では、密度計算と同時にsmoothing lengthを計算する必要がある。そのようなformulationを実装する場合には、この例のように、Force型にsmoothing lengthを持たせる必要が生じる。本サンプルコードでは固定長SPHを使うため、メンバ関数\texttt{clear}で\texttt{smth}を0クリアされないようにしている(0クリアされては密度計算が破綻するため)。

また、\texttt{Hydro}クラスには各粒子の時間刻みを表すメンバ変数\texttt{dt}が用意されている。本サンプルコードでは、\texttt{dt}を0クリアしていない。これは\texttt{dt}が積算対象でないため、0クリアが不要であるからである。
}
\describeForIF{%Fortran,C用
まず、ユーザはこれらの\structure がForce型であることを指示文によって指定する必要がある。この実装例では、それぞれの\structure に対して、以下のように記述している:
}
\ifFtn %Fortran用
\begin{screen}
\begin{spverbatim}
type, public, bind(c) :: force_dens !$fdps Force
type, public, bind(c) :: force_hydro !$fdps Force
\end{spverbatim}
\end{screen}
\endifFtn
\ifC %C言語用
\begin{screen}
\begin{spverbatim}
typedef struct force_dens { //$fdps Force
typedef struct force_hydro { //$fdps Force
\end{spverbatim}
\end{screen}
\endifC
\describeForIF{%Fortran,C用
これらの\structure はForce型であるから、ユーザは\ulBold{必ず}、相互作用計算における積算対象のメンバ変数の初期化方法を指定する必要がある。本サンプルコードでは、積算対象である密度、(圧力勾配による)加速度、エネルギー密度の変化率、時間刻みのみを0クリアする指示を出している:
}
\ifFtn %Fortran用
\begin{screen}
\begin{spverbatim}
!$fdps clear smth=keep
!$fdps clear
\end{spverbatim}
\end{screen}
\endifFtn
\ifC %C言語用
\begin{screen}
\begin{spverbatim}
//$fdps clear smth=keep
//$fdps clear
\end{spverbatim}
\end{screen}
\endifC
\describeForIF{%Fortran,C用
この例において、Force型 \texttt{force\_dens}には、smoothing lengthを表すメンバ変数\texttt{smth}が用意されている。本来、固定長SPHでは、Force型にsmoothing lengthに対応するメンバを持たせる必要はない。しかし、ここでは、ユーザが将来的に可変長SPHに移行することを想定して用意してある。可変長SPHのformulationの1つであるSpringel [2005,MNRAS,364,1105]の方法では、密度計算と同時にsmoothing lengthを計算する必要がある。そのようなformulationを実装する場合には、この例のように、Force型にsmoothing lengthを持たせる必要が生じる。本サンプルコードでは固定長SPHを使うため、\texttt{smth}を0クリアされないようにしている(0クリアされては2回目以降の密度計算が破綻するため)。
}

%-------------------
%   calcForceEpEp
%-------------------
\subsubsubsection{相互作用関数 calcForceEpEp}
ユーザーは粒子間相互作用の仕方を記述した相互作用関数 calcForceEpEpを記述しなければならない。相互作用関数 calcForceEpEpには、各Force型に対応する粒子-粒子相互作用計算の具体的な内容を書く必要がある。Listing~\ref{sph_calcForceEpEp}に、本サンプルコードでの実装を示す (\describeForEach{\texttt{main.cpp}}{\texttt{user\_defined.F90}}{\texttt{user\_defined.c}}を参照)。

\ifCpp %C++用
\lstinputlisting[linerange={174-211},caption=関数calcForceEpEp,label=sph_calcForceEpEp]{../../../../sample/c++/sph/main.cpp}
\endifCpp
\ifFtn %Fortran用
\lstinputlisting[linerange={116-225},caption=関数 calcForceEpEp,label=sph_calcForceEpEp]{../../../../sample/fortran/sph/user_defined.F90}
\endifFtn
\ifC %C言語用
\lstinputlisting[linerange={42-142},caption=関数 calcForceEpEp,label=sph_calcForceEpEp]{../../../../sample/c/sph/user_defined.c}
\endifC

本SPHシミュレーションコードでは、2種類の相互作用があるため、calcForceEpEp は2つ記述する必要がある。いずれの場合にも、\procedure の仮引数は、EssentialParticleIの配列、EssentialParticleIの個数、EssentialParticleJの配列、EssentialParticleJの個数、Force型の配列である。

\subsubsection{プログラム本体}
本節では、FDPSを用いてSPH計算を行う際に、\mainFunc に書かれるべき関数に関して解説する\describeForIF{(本文書における\mainFunc の定義については、第\ref{subsubsec:nbody_sample_main_part}節を参照のこと)}。

\ifCpp%C++用
\subsubsubsection{ヘッダーファイルのインクルード}
FDPSの標準機能を利用できるようにするため、\path{particle_simulator.hpp}をインクルードする。
\begin{lstlisting}[caption=ヘッダーファイル\texttt{particle\_simulator.hpp}のインクルード]
#include <particle_simulator.hpp>
\end{lstlisting}
\endifCpp
\ifFtn %Fortran用
\subsubsubsection{\texttt{fdps\_controller}型オブジェクトの生成}
ユーザはFDPSのAPIを使用するために、\texttt{FDPS\_controller}型オブジェクトを生成しなければならない。本サンプルコードでは、\texttt{FDPS\_controller}型オブジェクト\texttt{fdps\_ctrl}をメインルーチンで生成している:
\begin{lstlisting}[caption=\texttt{fdps\_controller}型オブジェクトの生成]
subroutine f_main()
   use fdps_module
   implicit none
   !* Local variables
   type(fdps_controller) :: fdps_ctrl
    
   ! Do something
   
end subroutine f_main    
\end{lstlisting}
ここに示したコードは実際にサンプルコードから必要な部分だけを取り出したものであることに注意して頂きたい。

上記の理由から、以下の説明において、FDPSのAPIはこのオブジェクトのメンバ関数として呼び出されていることに注意されたい。
\endifFtn
\ifC%C用
\subsubsubsection{ヘッダーファイルのインクルード}
FDPSの標準機能を利用できるようにするため、\path{FDPS_c_if.h}をインクルードする。
\begin{lstlisting}[caption=ヘッダーファイル\texttt{FDPS\_c\_if.h}のインクルード]
#include "FDPS_c_if.h"
\end{lstlisting}
\endifC


\subsubsubsection{開始、終了}
まずは、FDPSの初期化/開始を行う必要がある。次のように、\mainFunc に記述する。
\ifCpp%C++用
\begin{lstlisting}[caption=FDPSの開始]
PS::Initialize(argc, argv);
\end{lstlisting}
\endifCpp
\ifFtn%Fortran用
\begin{lstlisting}[caption=FDPSの開始]
call fdps_ctrl%ps_initialize()
\end{lstlisting}
\endifFtn
\ifC%C言語用
\begin{lstlisting}[caption=FDPSの開始]
fdps_initialize();
\end{lstlisting}
\endifC

FDPSは、開始したら明示的に終了させる必要がある。
今回は、プログラムの終了と同時にFDPSも終了させるため、\mainFunc の最後に次のように記述する。
\ifCpp%C++用
\begin{lstlisting}[caption=FDPSの終了]
PS::Finalize();
\end{lstlisting}
\endifCpp
\ifFtn %Fortran用
\begin{lstlisting}[caption=FDPSの終了]
call fdps_ctrl%PS_Finalize()
\end{lstlisting}
\endifFtn
\ifC %C言語用
\begin{lstlisting}[caption=FDPSの終了]
fdps_finalize();
\end{lstlisting}
\endifC

\subsubsubsection{オブジェクトの生成・初期化}
FDPSの初期化に成功した場合、ユーザーはコード中で用いるオブジェクトを作成する必要がある。本節では、オブジェクトの生成/初期化の仕方について、解説する。

\subsubsubsubsection{オブジェクトの生成}
SPHでは、粒子群オブジェクト、領域情報オブジェクトに加え、密度計算用にGather型の短距離力用ツリーを1本、流体相互作用計算用にSymmetry型の短距離力用ツリーを1本生成する必要がある。以下にそのコードを記す。
\ifCpp %C++用
\begin{lstlisting}[caption=オブジェクトの生成]
PS::ParticleSystem<FP> sph_system;
PS::DomainInfo dinfo;
PS::TreeForForceShort<Dens, EP, EP>::Gather dens_tree;
PS::TreeForForceShort<Hydro, EP, EP>::Symmetry hydr_tree;
\end{lstlisting}
\endifCpp
\ifFtn %Fortran用
\begin{lstlisting}[caption=オブジェクトの生成]
subroutine f_main()
   use fdps_vector
   use fdps_module
   use user_defined_types
   implicit none
   !* Local variables
   integer :: psys_num,dinfo_num
   integer :: dens_tree_num,hydro_tree_num
   
   !* Create FDPS objects
   call fdps_ctrl%create_psys(psys_num,'full_particle')
   call fdps_ctrl%create_dinfo(dinfo_num)
   call fdps_ctrl%create_tree(dens_tree_num, &
                              "Short,dens_force,essential_particle,essential_particle,Gather")
   call fdps_ctrl%create_tree(hydro_tree_num, &
                              "Short,hydro_force,essential_particle,essential_particle,Symmetry")

end subroutine f_main
\end{lstlisting}
ここでも、実際のサンプルコードから該当部分だけを抜き出していることに注意して頂きたい。API \createPsys と \createTree には、それぞれ、粒子種別とツリー種別を示す文字列を渡す。\textbf{\ul{これら文字列の中のすべての{\structure}名は小文字で記述されなければならないことに注意して頂きたい}}。
\endifFtn
\ifC %C言語用
\begin{lstlisting}[caption=オブジェクトの生成]
void c_main() {
    // Make an instance of ParticleSystem and initialize it
    int psys_num;
    fdps_create_psys(&psys_num,"full_particle");

    // Make an instance of DomainInfo and initialize it
    int dinfo_num;
    fdps_create_dinfo(&dinfo_num);
    
    // Make two tree structures
    int tree_num_dens;
    fdps_create_tree(&tree_num_dens,
                     "Short,force_dens,essential_particle,essential_particle,Gather");
    int tree_num_hydro;
    fdps_create_tree(&tree_num_hydro,
                     "Short,force_hydro,essential_particle,essential_particle,Symmetry");
}
\end{lstlisting}
ここでも、実際のサンプルコードから該当部分だけを抜き出していることに注意して頂きたい。API \createPsys と \createTree には、それぞれ、粒子種別とツリー種別を示す文字列を渡す。\textbf{\ul{これら文字列の中のすべての{\structure}名は小文字で記述されなければならないことに注意して頂きたい}}。
\endifC

\subsubsubsubsection{領域情報オブジェクトの初期化}
ユーザーはオブジェクトを作成したら、そのオブジェクトの初期化を行う必要がある。ここでは、まず領域情報オブジェクトの初期化について、解説する。領域情報オブジェクトの初期化が終わった後、領域情報オブジェクトに周期境界の情報と、境界の大きさをセットする必要がある。今回のサンプルコードでは、$x$, $y$, $z$方向に周期境界を用いる。
\ifCpp %C++用
\begin{lstlisting}[caption=領域クラスの初期化]
dinfo.initialize();
dinfo.setBoundaryCondition(PS::BOUNDARY_CONDITION_PERIODIC_XYZ);
dinfo.setPosRootDomain(PS::F64vec(0.0, 0.0, 0.0),
                       PS::F64vec(box.x, box.y, box.z));
\end{lstlisting}
\endifCpp
\ifFtn %Fortran用
\begin{lstlisting}[caption=領域情報オブジェクトの初期化]
call fdps_ctrl%init_dinfo(dinfo_num,coef_ema)
call fdps_ctrl%set_boundary_condition(dinfo_num,fdps_bc_periodic_xyz)
call fdps_ctrl%set_pos_root_domain(dinfo_num,pos_ll,pos_ul)
\end{lstlisting}
\endifFtn
\ifC %C言語用
\begin{lstlisting}[caption=領域情報オブジェクトの初期化]
fdps_init_dinfo(dinfo_num,coef_ema);
fdps_set_boundary_condition(dinfo_num,FDPS_BC_PERIODIC_XYZ);
fdps_set_pos_root_domain(dinfo_num,&pos_ll,&pos_ul);
\end{lstlisting}
\endifC


\subsubsubsubsection{粒子群オブジェクトの初期化}
次に、粒子群オブジェクトの初期化を行う必要がある。粒子群オブジェクトの初期化は、次の一文だけでよい。
\ifCpp %C++用
\begin{lstlisting}[caption=粒子群クラスの初期化]
sph_system.initialize();
\end{lstlisting}
\endifCpp
\ifFtn %Fortran用
\begin{lstlisting}[caption=粒子群オブジェクトの初期化]
call fdps_ctrl%init_psys(psys_num)
\end{lstlisting}
\endifFtn
\ifC %C言語用
\begin{lstlisting}[caption=粒子群オブジェクトの初期化]
fdps_init_psys(psys_num);
\end{lstlisting}
\endifC

\subsubsubsubsection{ツリーオブジェクトの初期化}
次に、ツリーオブジェクトの初期化を行う必要がある。ツリーオブジェクトの初期化を行う関数には、オブジェクト内部で使用する配列の大きさの初期値を渡す必要がある。初期値はローカル粒子数(\texttt{n\_loc})程度で十分であるため、そのようにセットする。
\ifCpp %C++用
\begin{lstlisting}[caption=相互作用ツリークラスの初期化]
dens_tree.initialize(n_loc);
hydr_tree.initialize(n_loc);
\end{lstlisting}
\endifCpp
\ifFtn %Fortran用
\begin{lstlisting}[caption=相互作用ツリークラスの初期化]
call fdps_ctrl%init_tree(dens_tree_num,n_loc,theta, &
                         n_leaf_limit,n_group_limit)
call fdps_ctrl%init_tree(hydro_tree_num,n_loc,theta, &
                         n_leaf_limit,n_group_limit)
\end{lstlisting}
\endifFtn
\ifC %C言語用
\begin{lstlisting}[caption=相互作用ツリークラスの初期化]
fdps_init_tree(tree_num_dens,n_loc,theta, &
               n_leaf_limit,n_group_limit);
fdps_init_tree(tree_num_hydro,n_loc,theta, &
               n_leaf_limit,n_group_limit);
\end{lstlisting}
\endifC

\subsubsubsection{ループ}
本節では、時間積分ループの中で行わなければならないことについて、解説する。

\subsubsubsubsection{領域分割の実行}
まずは、粒子分布に基いて、領域分割を実行する。これには、領域情報オブジェクトのAPI \decomposeDomainAll を用いる。
\ifCpp %C++用
\begin{lstlisting}[caption=領域分割の実行]
dinfo.decomposeDomainAll(sph_system);
\end{lstlisting}
\endifCpp
\ifFtn %Fortran用
\begin{lstlisting}[caption=領域分割の実行]
call fdps_ctrl%decompose_domain_all(dinfo_num,psys_num)
\end{lstlisting}
\endifFtn
\ifC %C言語用
\begin{lstlisting}[caption=領域分割の実行]
fdps_decompose_domain_all(dinfo_num,psys_num,-1.0);
\end{lstlisting}
\endifC

\subsubsubsubsection{粒子交換の実行}
次に、領域情報に基いて、プロセス間の粒子の情報を交換する。これには、粒子群オブジェクトのAPI \exchangeParticle を用いる。
\ifCpp %C++用
\begin{lstlisting}[caption=粒子交換の実行]
sph_system.exchangeParticle(dinfo);
\end{lstlisting}
\endifCpp
\ifFtn %Fortran用
\begin{lstlisting}[caption=粒子交換の実行]
call fdps_ctrl%exchange_particle(psys_num,dinfo_num)
\end{lstlisting}
\endifFtn
\ifC %C言語用
\begin{lstlisting}[caption=粒子交換の実行]
fdps_exchange_particle(psys_num,dinfo_num);
\end{lstlisting}
\endifC

\subsubsubsubsection{相互作用計算の実行}
領域分割・粒子交換が終了したら、相互作用の計算を行う。これには、ツリーオブジェクトのAPI \calcForceAllAndWriteBack を用いる。
\ifCpp %C++用
\begin{lstlisting}[caption=相互作用計算の実行]
dens_tree.calcForceAllAndWriteBack(CalcDensity(), sph_system, dinfo);
hydr_tree.calcForceAllAndWriteBack(CalcHydroForce(), sph_system, dinfo);
\end{lstlisting}
\endifCpp
\ifFtn %Fortran用
\begin{lstlisting}[caption=相互作用計算の実行]
subroutine f_main()
   use, intrinsic :: iso_c_binding
   use user_defined_types
   implicit none
   !* Local variables
   type(c_funptr) :: pfunc_ep_ep
   
   ! Do something
   
   pfunc_ep_ep = c_funloc(calc_density)
   call fdps_ctrl%calc_force_all_and_write_back(tree_num_dens, &
                                                pfunc_ep_ep,   &
                                                psys_num,      &
                                                dinfo_num)
   call set_pressure(fdps_ctrl,psys_num)
   pfunc_ep_ep = c_funloc(calc_hydro_force)
   call fdps_ctrl%calc_force_all_and_write_back(tree_num_hydro, &
                                                pfunc_ep_ep,   &
                                                psys_num,      &
                                                dinfo_num)

   ! Do something

end subroutine f_main
\end{lstlisting}
ここで、APIの第2引数には関数 calcForceEpEp の(C言語アドレスとしての)関数ポインタを指定する。
\endifFtn
\ifC %C言語用
\begin{lstlisting}[caption=相互作用計算の実行]
void c_main() {
   
   // Do something
   
   fdps_calc_force_all_and_write_back(tree_num_dens,
                                      calc_density,
                                      NULL,
                                      psys_num,
                                      dinfo_num,
                                      true,
                                      FDPS_MAKE_LIST);
   call set_pressure(psys_num);
   fdps_calc_force_all_and_write_back(tree_num_hydro,
                                      calc_hydro_force,
                                      NULL,
                                      psys_num,
                                      dinfo_num,
                                      true,
                                      FDPS_MAKE_LIST);

   // Do something

}
\end{lstlisting}
\endifC


\subsubsection{コンパイル}
作業ディレクトリで\texttt{make}コマンドを打てばよい。\texttt{Makefile}としては、サンプルコードに付属の\texttt{Makefile}をそのまま用いる事にする。
\begin{screen}
\begin{verbatim}
$ make
\end{verbatim}
\end{screen}

\subsubsection{実行}
MPIを使用しないで実行する場合、コマンドライン上で以下のコマンドを実行すればよい。
\begin{screen}
\begin{verbatim}
$ ./sph.out
\end{verbatim}
\end{screen}
もし、MPIを用いて実行する場合は、以下のコマンドを実行すればよい。
\begin{screen}
\begin{verbatim}
$ MPIRUN -np NPROC ./sph.out
\end{verbatim}
\end{screen}
ここで、\texttt{MPIRUN}には\texttt{mpirun}や\texttt{mpiexec}などのMPI実行プログラムが、\texttt{NPROC}にはプロセス数が入る。

\subsubsection{ログファイル}
計算が終了すると、\texttt{result}フォルダ下にログが出力される。

\subsubsection{可視化}
ここでは、\texttt{gnuplot}を用いた可視化の方法について解説する。\texttt{gnuplot}で対話モードに入るために、コマンドラインから\texttt{gnuplot}を起動する。
\begin{screen}
\begin{verbatim}
$ gnuplot
\end{verbatim}
\end{screen}

対話モードに入ったら、\texttt{gnuplot}を用いて可視化を行う。今回は、50番目のスナップショットファイルから、横軸を粒子のx座標、縦軸を密度に取ったグラフを生成する。
\ifCpp %C++用
\begin{screen}
\begin{verbatim}
gnuplot> plot "result/0040.txt" u 3:9
\end{verbatim}
\end{screen}
\endifCpp
\ifFtn %Fortran用
\begin{screen}
\begin{verbatim}
gnuplot> plot "result/snap00050-proc00000.dat" u 3:9
\end{verbatim}
\end{screen}
ここで、文字列\texttt{proc}の後の整数はMPIのプロセス番号を表す。
\endifFtn
\ifC %C言語用
\begin{screen}
\begin{verbatim}
gnuplot> plot "result/snap00050-proc00000.dat" u 3:9
\end{verbatim}
\end{screen}
ここで、文字列\texttt{proc}の後の整数はMPIのプロセス番号を表す。
\endifC

