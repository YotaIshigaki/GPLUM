本章では、ユーザーが定義しなければならない派生データ型(Fortran) 或いは 構造体(C言語) (\textbf{ユーザ定義型})と相互作用関数(\textbf{ユーザ定義関数})について記述する。ユーザー定義型には、FullParticle 型、EssentialParticleI 型、EssentialParticleJ 型、Force 型がある。また、ユーザー定義関数には、粒子-粒子相互作用を記述する calcForceEpEpと、粒子-超粒子間相互作用を記述する calcForceEpSp がある。本章で記述するのは、ユーザ定義型やユーザ定義関数を定義する際の規定である。FDPS は、ユーザ定義型が粒子の位置等、粒子計算に必須の物理量を持つことを仮定する。したがって、ユーザは FDPS に必須物理量がユーザ定義型のどのメンバ変数に対応するかを教える必要がある。また、FDPS 内部では、ユーザ定義型の間でデータのやりとりを行うが、それをユーザが指定した方法で行うことになる。したがって、ユーザはその方法をコードに書く必要がある。これらFDPSへの指示や方法の記述はすべてコード内に特別な指示文(\textbf{FDPS 指示文})を記述することによって行う。以下、まずはじめにユーザ定義型について記述し、その後ユーザ定義関数について記述する。%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\section{ユーザ定義型}\label{sec:user_defined_types}まず概要を述べる。FullParticle 型は、ある1粒子の情報すべてを持つ派生データ型(Fortran) 或いは 構造体(C言語) であり、粒子群クラスのオブジェクトの生成に使用されるものである (第\ref{chap:overview}章\ref{sec:overview_action}節の手順0)。EssentialParticleI 型、EssentialParticleJ 型、Force 型は粒子間の相互作用の定義を補助するものであり、それぞれ、相互作用を計算する際に$i$粒子に必要な情報、相互作用を計算する際に$j$粒子に必要な情報、相互作用の結果の情報を持つ派生データ型(Fortran) 或いは 構造体(C言語)である。これらは FullParticle 型のサブセットであるため、これらを FullParticle 型で代用することも可能である。しかし、FullParticle 型は相互作用の定義に必要のないデータを多く含む場合も考えられるため、計算コストを軽減したいならば、これらの型を使用することを検討するべきである。以下では、はじめにユーザ定義型を記述する上での共通の規則について記述する。その後、FullParticle型、EssentialParticleI型、EssentialParticleJ型、Force型の順で記述する。%%%%%%%%%%%%%%%%%%%%%%%%%%%\subsection{共通規則}\label{subsec:common_rules_for_user_defined_types}%%%%\subsubsection{Fortran 文法に関する要請}\label{s2sec:requirements_for_fortran_grammer}本節では、ユーザ定義型となるために派生データ型が満たすべき最低限のFortran文法について記述する。第\ref{chap:file_str_and_ftn_if_overview}章で述べた通り、本 FDPS Fortran インターフェースは、FDPSのC言語インターフェースを通して、FDPS 本体とデータをやり取りする。このため、すべてのユーザ定義型はC言語と(Fortran 2003 標準で)\textbf{interoperable}である必要がある。具体的には、ユーザ定義型となる派生データ型は次の条件を満たしている必要がある：\begin{enumerate}[leftmargin=*,itemsep=-1ex,label=(\arabic*)]\item 派生データ型は\path{bind(c)}属性を持たなければならない。\item すべてのメンバ変数がinteroperableなデータ型である。Fortran 2003 標準(ISO/IEC 1539-1:2004(E))で定義される「C言語とinteroperableな」データ型の一覧は本書表\ref{tbl:interoperable_data_types}や言語仕様書の第15節「Interoperability with C」で確認できる\footnote{Fortranの言語仕様書を販売している\href{http://www.iso.org/iso/home.htm}{ISO} (International Organization for Standardization)からはFortran 2008 Standard (ISO/IEC 1539-1:2010(E))のみ購入可能である。}ほか、\href{https://gcc.gnu.org/wiki/HomePage}{GCC Wiki}のページ\href{https://gcc.gnu.org/wiki/GFortranStandards}{GFortranStandards}で紹介されている各種非公式文書(ドラフト段階の言語仕様書)やGNU gfortranの\href{https://gcc.gnu.org/onlinedocs/gfortran/ISO_005fC\_005fBINDING.html#ISO\_005fC\_005fBINDING}{オンラインドキュメント}でも解説されている。「C言語とinteroperable」な派生データ型をメンバ変数として持つことは可能である。\item すべてのメンバ変数は\path{allocatable}属性を持たない。\item すべてのメンバ変数は\path{pointer}属性を持たない。\item メンバ関数を持たない。\end{enumerate}加えて、FDPS 側からの要請として、次の条件を満たす必要がある：\begin{enumerate}[leftmargin=*,itemsep=-1ex,label=(\arabic*),resume]\item 派生データ型はモジュール内で定義されている。\item 派生データ型は\path{public}属性を持つ。\item メンバ変数として持たせることが可能な派生データ型はベクトル型と対称行列型(第\ref{chap:data_types}章参照)のみである。\item 派生データ型は多次元配列をメンバ変数として持てない(これは将来のバージョンにおいて対応する予定である)。\item メンバ変数の(1次元)配列の形状を指定する場合、\texttt{dimension}文で指定するか、変数名に\texttt{(配列要素数)}を付けるかの、\underbold{どちらか片方の}方法でなければならない。\end{enumerate}以上の条件が、派生データ型がユーザ定義型となるために満たす必要があるFortran 文法である。これに加え、次節\ref{subsubsec:FDPS_directives}で説明するFDPS指示文によって、どのユーザ定義型(FullParticle型,EssentialParticleI型,EssentialParticleJ型,Force型)に対応するかや、必須物理量がどのメンバ変数に対応しているか等を指定してはじめてユーザ定義型となる。%%%%\subsubsection{C言語 文法に関する要請}\label{s2sec:requirements_for_c_grammer}本節では、ユーザ定義型となるために構造体が満たすべき最低限のC言語文法について記述する。第\ref{chap:file_str_and_ftn_if_overview}章で述べた通り、C言語インターフェースプログラムの1つ\path{FDPS_ftn_if.cpp}は、Fortranインターフェースでも共用される。このため、自由に構造体を定義できるわけではなく、前節\ref{s2sec:requirements_for_fortran_grammer}で述べたような制限を受ける。具体的には、ユーザ定義型となる構造体は次の条件を満たさなければならない：\begin{enumerate}[leftmargin=*,itemsep=-1ex,label=(\arabic*)]\item 構造体はタグ名を持つ必要がある。タグ名はすべて小文字でなければならない。\item メンバ変数のデータ型として利用できるのは、(i) Fortran 2003 標準(ISO/IEC 1539-1:2004(E))と相互運用可能なデータ型(詳細は第\ref{s2sec:requirements_for_fortran_grammer}節の(2)、及び本書表\ref{tbl:interoperable_data_types}を参照のこと)、(ii) ベクトル型、(iii) 対称行列型のみである。\textbf{特に、符号なし整数、及び、あらゆるポインタは持てないことに注意して頂きたい}。\item 構造体は多次元配列をメンバ変数として持てない(これは将来のバージョンにおいて対応する予定である)。\item メンバ変数名はすべて小文字でなければならない。\end{enumerate}Fortranの場合と同様、これに加え、次節\ref{subsubsec:FDPS_directives}で説明するFDPS指示文を付け加えて、はじめてユーザ定義型の資格を得る。\subsubsection{FDPS 指示文 (共通項目のみ)}\label{subsubsec:FDPS_directives}本節では、すべてのユーザ定義型に共通して使用可能なFDPS指示文の概要と記述方法について解説する。各ユーザ定義型に固有の指示文に関しては、第\ref{subsec:FullParticle}〜\ref{subsec:Force}節で解説する。FDPS指示文には以下の3つの種類がある：\begin{enumerate}[leftmargin=*,itemsep=-1ex,label=(\alph*)]\item 派生データ型/構造体がどのユーザ定義型に対応するかを指定する指示文。\label{enum:FDPS_str_dir}\item 派生データ型/構造体のメンバ変数がどの必須物理量に対応するかを指定する指示文。\label{enum:FDPS_mbr_dir}\item ユーザ定義型同士のデータ移動の方法を指定する指示文。\label{enum:FDPS_meth_dir}\end{enumerate}これらの指示文の内、以下で、最初の2つ\ref{enum:FDPS_str_dir},\ref{enum:FDPS_mbr_dir}について解説する。以降の解説では、まず、FortranにおけるFDPS指示文の書き方について説明し、その後、C言語の場合を説明する。\subsubsubsection{ユーザ定義型の種別を指定するFDPS 指示文}派生データ型\textit{\texttt{type\_name}}がどのユーザ定義型に対応するかを指定するには、次の書式の指示文を記述する：\begin{screen}\begin{Verbatim}[commandchars=\\\{\}]type, public, bind(c) :: \vrbit{type_name} !\$fdps \vrbit{keyword}end type [\vrbit{type_name}]\end{Verbatim}\end{screen}或いは、\begin{screen}\begin{Verbatim}[commandchars=\\\{\}]!\$fdps \vrbit{keyword}type, public, bind(c) :: \vrbit{type_name}end type [\vrbit{type_name}]\end{Verbatim}\end{screen}ここで[]は、その中身が省略可能であることを示す記号である。FDPS指示文は必ず文字列\verb|!$fdps|で開始される。英字はすべて小文字でなければならない。!で始まることからわかるように、FDPS指示文は単なるコメント文であり、Fortranプログラムの動作に影響を与えるものではない。インターフェース生成スクリプトだけが、このコメント文を指示文として解釈する。\verb|!$fdps|に半角スペースを置いて続く\textit{\texttt{keyword}}は、ユーザ定義型を指定するための文字列である。可能なキーワードは、\path{FP}, \path{EPI}, \path{EPJ}, \path{Force}であり、大文字・小文字を区別する。それぞれFullParticle型、EssentialParticleI型、EssentialParticleJ型、Force型に対応している。FDPS指示文は派生データ型名の右側か、1つ前の行に記述しなければならない。FDPS指示文の中で改行を行うことはできない。第\ref{sec:user_defined_types}節で述べた通り、EssentialParticleI型、EssentialParticleJ型、Force型はFullParticle型のサブセットでり、FullParticle型がこれら3つを兼ねることが可能である。その場合には、以下のリスト\ref{listing:FDPS_str_dir_example}に示されるように、キーワードをカンマで区切って並べればよい：\begin{lstlisting}[caption=FullParticle型が他を兼ねる場合の例,label=listing:FDPS_str_dir_example]type, public, bind(c) :: full_particle !$fdps FP,EPI,EPJ,Forceend type full_particle\end{lstlisting}FullParticle型がEssentialParticleI型だけを兼ねるといったことも可能である。構造体 \textit{\texttt{tag\_name}}がどのユーザ定義型に対応するかを指定するには、次の書式の指示文を記述する：\begin{screen}\begin{Verbatim}[commandchars=\\\{\}]struct \vrbit{tag_name} \{ //\$fdps \vrbit{keyword}\};\end{Verbatim}\end{screen}或いは、\begin{screen}\begin{Verbatim}[commandchars=\\\{\}]//\$fdps \vrbit{keyword}struct \vrbit{tag_name} \{\};\end{Verbatim}\end{screen}指示文の書き方はFortranの場合とほぼ同じである。違いのみ以下に示す。\begin{itemize}[leftmargin=*]\item コメント文からコメント記号と先頭の空白文字をすべて取り除いたときに得られる文字列が、文字列\verb|$fdps|で開始される場合(後続の文字列と空白文字で区切られている必要がある)、そのコメント文は指示文として解釈される。上の例では、コメント記号\texttt{//}を使っているが、別のコメント記号\texttt{/*},\texttt{*/}を使って、\texttt{/* \$fdps */}のように記述してもよい。\item 指示文\ref{enum:FDPS_str_dir}と解釈されるのは、\texttt{struct}の直前の指示文、或いは、\textit{\texttt{tag\_name}}の後の最初の指示文である。指示文はどちらか一方の位置に記述しなければならない。\end{itemize}\subsubsubsection{必須物理量を指定するFDPS指示文}次に、必須物理量に対応するメンバ変数を指定する指示文\ref{enum:FDPS_mbr_dir}について解説する。FDPSでは必須物理量として、粒子の電荷量(質量)、粒子の位置が必要である。また、ある種の粒子シミュレーションでは探索半径も必要となる。派生データ型\textit{\texttt{type\_name}}のメンバ変数\textit{\texttt{mbr\_name}}がどの必須物理量に対応するかを指定するには、次の書式の指示文を記述する：\begin{screen}\begin{Verbatim}[commandchars=\\\{\}]type, public, bind(c) :: \vrbit{type_name}   \vrbit{data_type} :: \vrbit{mbr_name} !\$fdps \vrbit{keyword}end type [\vrbit{type_name}]\end{Verbatim}\end{screen}或いは、\begin{screen}\begin{Verbatim}[commandchars=\\\{\}]type, public, bind(c) :: \vrbit{type_name}   !\$fdps \vrbit{keyword}   \vrbit{data_type} :: \vrbit{mbr_name} end type [\vrbit{type_name}]\end{Verbatim}\end{screen}ここでは、見やすさのため、ユーザ定義型の種別を指定する指示文は省略している。指示文は、指示文の開始を示す文字列\verb|!$fdps|で始まり、半角スペースを置いて\textit{\texttt{keyword}}が続く。可能なキーワードは、\path{id}、\path{charge}、\path{position}、\path{rsearch}、\path{velocity}である\footnote{但し、\path{velocity}は予約語であり、現時点で生成されるインターフェースプログラムの内容に影響しない}。それぞれ、粒子の識別番号、粒子の電荷量(質量)、粒子の位置、粒子の探索半径、粒子の速度に対応している。キーワードはすべて小文字でなければならない。また、1つのメンバ変数に対して1つの指示文を対応させなければならない。指示文は、変数名の右側か1つ前の行に記述しなければならない。メンバ変数のデータ型\textit{\texttt{data\_type}}は、対応する必須物理量が持つべきデータ型に一致していなければならない。以下に、各必須物理量が持つべきデータ型をまとめる:\begin{table}[H]\begin{tabularx}{\linewidth}{cX}\toprule\rowcolor{Snow2}物理量名 & 可能なデータ型 \\\midrule粒子の識別番号 & \texttt{integer(kind=c\_long\_long)} \\\midrule\multirow{2}{*}{電荷(質量)および探索半径} & \texttt{real(kind=c\_float)} \\ & \texttt{real(kind=c\_double)} \\\midrule\multirow{4}{*}{位置および速度} & \texttt{type(fdps\_f32vec)} \\& \texttt{real(kind=c\_float), dimension(space\_dim)}$^{\dagger}$ \\& \texttt{type(fdps\_f64vec)} \\& \texttt{real(kind=c\_double), dimension(space\_dim)}$^{\dagger}$ \\\bottomrule\end{tabularx}\begin{flushleft}$^{\dagger}$ \texttt{space\_dim}は空間次元を表す。コンパイル時にマクロ\path{PARTICLE_SIMULATOR_TWO_DIMENSION}が定義されている場合は2、それ以外は3である必要がある(第\ref{chap:compile_and_macro}章参照)。\end{flushleft}\caption{各必須物理量が持つべきデータ型。}\end{table}構造体\textit{\texttt{tag\_name}}のメンバ変数\textit{\texttt{mbr\_name}}がどの必須物理量に対応するかを指定するには、次の書式の指示文を記述する：\begin{screen}\begin{Verbatim}[commandchars=\\\{\}]struct \vrbit{tag_name} \{   \vrbit{data_type} \vrbit{mbr_name}; //\$fdps \vrbit{keyword}\};\end{Verbatim}\end{screen}或いは、\begin{screen}\begin{Verbatim}[commandchars=\\\{\}]struct \vrbit{tag_name} \{   //\$fdps \vrbit{keyword}   \vrbit{data_type} \vrbit{mbr_name};\};\end{Verbatim}\end{screen}指示文の書き方はFortranの場合と同じである。各必須物理量が持つべきデータ型は、上の表に記載されたFortranのデータ型をC言語のデータ型に適切に読み替えることで得られる(表\ref{tbl:interoperable_data_types}を参照のこと)。\subsubsubsection{FDPS指示文の記述例}最後に、FullParticle型の実装例を示す(リスト\ref{listing:FP_example}および\ref{listing:FP_example_in_C})。この例ではここで説明しなかったFDPS指示文\ref{enum:FDPS_meth_dir}が使用されているが、FDPS指示文\ref{enum:FDPS_str_dir},\ref{enum:FDPS_mbr_dir}がどのように使用されているかに注意してほしい。\begin{lstlisting}[caption=ユーザ定義型の例 (Fortran),label=listing:FP_example]module user_defined_types   use, intrinsic :: iso_c_binding   use :: fdps_vector   implicit none      !**** Full particle type   type, public, bind(c) :: full_particle !$fdps FP,EPI,EPJ,Force      !$fdps copyFromForce full_particle (pot,pot) (acc,acc)      !$fdps copyFromFP full_particle (id,id) (mass,mass) (eps,eps) (pos,pos)       integer(kind=c_long_long) :: id !$fdps id      real(kind=c_double) :: mass !$fdps charge      real(kind=c_double) :: eps      type(fdps_f64vec) :: pos !$fdps position      type(fdps_f64vec) :: vel !$fdps velocity      real(kind=c_double) :: pot      type(fdps_f64vec) :: acc   end type full_particleend module user_defined\end{lstlisting}\begin{lstlisting}[language=C,caption=ユーザ定義型の例 (C言語),label=listing:FP_example_in_C]#include "FDPS_c_if.h"   //**** Full particle typetypedef struct full_particle { //$fdps FP,EPI,EPJ,Force   //$fdps copyFromForce full_particle (pot,pot) (acc,acc)   //$fdps copyFromFP full_particle (id,id) (mass,mass) (eps,eps) (pos,pos)    long long int id; //$fdps id   double mass; //$fdps charge   double eps;   fdps_f64vec pos; //$fdps position   fdps_f64vec vel; //$fdps velocity   double pot;   fdps_f64vec acc;} Full_particle;\end{lstlisting}以下では、各ユーザ定義型に個別の指示文も含めて、記述の規則を解説していく。%%%%%%%%%%%%%%%%%%%%%%%%%%%\subsection{FullParticle 型}\label{subsec:FullParticle}FullParticle 型は粒子情報すべてを持つ派生データ型(Fortran) 或いは 構造体(C言語)であり、第\ref{chap:overview}章\ref{sec:overview_action}節の手順0に対応して、粒子群オブジェクトを生成するのに必要なユーザー定義型である。ユーザーはこの派生データ型/構造体に対して、どのようなメンバ変数を定義してもかまわない。ただし、ユーザーは、FDPS指示文を用いて、必須物理量に対応するメンバ変数と、FullParticle 型と他のユーザ定義型の間のデータ移動の方法を記述する必要がある。以下、常に必要なFDPS指示文と、場合によっては必要なFDPS指示文について記述する。%%%\subsubsection{常に必要なFDPS指示文とその記述法}\label{subsubsec:FP:FDPS_directives:always_required}常に必要なFDPS指示文は、以下である：\begin{itemize}[leftmargin=*,itemsep=-1ex]\item 粒子の電荷量(質量)に対応するメンバ変数を指定する指示文\item 粒子の位置に対応するメンバ変数を指定する指示文\item 計算された相互作用の結果をForce型からFullParticle型に書き戻す方法を指定する指示文\end{itemize}最初の2つに関しては、第\ref{subsubsec:FDPS_directives}節で説明した方法で記述すればよい。最後のものは、Fortranでは、次の書式で指示文を記述する必要がある：\begin{screen}\begin{Verbatim}[commandchars=\\\{\}]type, public, bind(c) :: FP   !\$fdps copyFromForce \vrbit{force} (\vrbit{src_mbr},\vrbit{dst_mbr}) (\vrbit{src_mbr},\vrbit{dst_mbr}) ...end type FP\end{Verbatim}\end{screen}FDPS 指示文は文字列\verb|!$fdps|で開始される。その後、1個以上の半角スペースを挟み、キーワード\texttt{copyFromForce}を記述する。このキーワードによって、このFDPS指示文がForce型からFullParticle型へのデータコピーの仕方を記述する指示文であるとみなされる。キーワード\texttt{copyFromForce}の後には、Force型に対応する派生データ型名\textit{\texttt{force}}を記述する。キーワードとの間には1個以上の半角スペースが必要である。続いて、1個以上の変数ペア(\textit{\texttt{src\_mbr}},\textit{\texttt{dst\_mbr}})が半角スペースを区切り文字として並ぶ。これはForce型のどのメンバ変数をFullParticle型のどのメンバ変数にコピーするかを示している。\textit{\texttt{src\_mbr}}がForce型のメンバ変数であり、\textit{\texttt{dst\_mbr}}がFullParticle型のメンバ変数である。FDPS指示文は途中で改行することはできない。C言語では、次の書式で指示文を記述する必要がある：\begin{screen}\begin{Verbatim}[commandchars=\\\{\}]struct fp \{   //\$fdps copyFromForce \vrbit{force} (\vrbit{src_mbr},\vrbit{dst_mbr}) (\vrbit{src_mbr},\vrbit{dst_mbr}) ...\}\end{Verbatim}\end{screen}記述方法はFortranの場合と同じである。粒子シミュレーションによっては、1つのFullParticle型に対し、複数種の相互作用を定義する必要がある場合が想定される。その場合には、各々のForce型に対して、このFDPS指示文を記述する必要がある。本指示文の記述例がリスト\ref{listing:FP_example}及び\ref{listing:FP_example_in_C}に示されているので、そちらも参照されたい。%%%\subsubsection{場合によっては必要なFDPS指示文とその記述法}本節では、以下に示す場合に必要となる指示文について記述する：\begin{enumerate}[leftmargin=*,itemsep=-1ex,label=(\roman*)]\item 次の種別の相互作用ツリーオブジェクトを使用する場合：\begin{itemize}\item Long-MonopoleWithScatterSearch 型\item Long-QuadrupoleWithScatterSearch 型
\item Long-MonopoleWithSymmetrySearch 型
\item Long-QuadrupoleWithSymmetrySearch 型\item Long-MonopoleWithCutoff 型\item Short 型に分類されるすべてのツリー\end{itemize}\item 拡張機能 Particle Mesh を用いる場合\item FullParticle型が他のユーザ定義型を兼ねる場合\end{enumerate}(i)の場合、ユーザは派生データ型 或いは 構造体のメンバ変数のどれが探索半径であるかを指定しなければならない(相互作用ツリーの種別に関しては、第\ref{chap:API_spec_list}章で解説する)。これは、第\ref{subsubsec:FDPS_directives}節で説明した方法で記述すればよい。(ii)の場合には、ユーザはFDPSのParticle Mesh モジュールで計算された力をFullParticle型に書き戻す方法を指示する必要がある。これは、Fortranの場合、次の書式のFDPS指示文を使って指定する：\begin{screen}\begin{Verbatim}[commandchars=\\\{\}]type, public, bind(c) :: FP   !\$fdps copyFromForcePM \vrbit{mbr_name}end type FP\end{Verbatim}\end{screen}FDPS指示文は文字列\verb|!$fdps|で開始される。その後、1個以上の半角スペースを挟み、キーワード\texttt{copyFromForcePM}が続く。これによって、この指示文がParticle Mesh モジュールからFullParticle型への力のコピーの仕方を指定する指示文であると解釈される。キーワードの次に1個以上の半角スペースをおいて、コピー先であるFullParticle型のメンバ変数名\textit{\texttt{mbr\_name}}が続く。コピー先のメンバ変数は第\ref{chap:data_types}章で説明したベクトル型でなければならない。FDPS指示文は途中で改行することはできない。% [TODO] コピー先が要素数2or3の配列で機能するかを確認。C言語の場合には、指示文は次の書式で記述する必要がある：\begin{screen}\begin{Verbatim}[commandchars=\\\{\}]struct FP \{   //\$fdps copyFromForcePM \vrbit{mbr_name}\};\end{Verbatim}\end{screen}Fortranと全く同じ書式なので説明は省略する。(iii)の場合には、他のユーザ定義型で常に必要となるFDPS指示文のすべてと、場合によっては必要となるFDPS指示文を必要なだけ記述する必要がある。これらに関しては、対応するユーザ定義型の節を参照して頂きたい。%%%%%%%%%%%%%%%%%%%%%%%%%%%\subsection{EssentialParticleI 型}\label{subsec:EssentialParticleI}EssentialParticleI 型は相互作用の計算に必要な$i$粒子の情報を持つ派生データ型(Fortran) 或いは 構造体(C言語)であり、相互作用関数(ユーザ定義関数)の定義に必要となるほか、相互作用ツリーオブジェクトの生成に必要となる。EssentialParticleI 型は FullParticle 型(第\ref{subsec:FullParticle}節)のサブセットである。ユーザはFDPS指示文を用いて、必須物理量に対応するメンバ変数と、FullParticle型との間のデータ移動の方法を記述する必要がある。以下、常に必要なFDPS指示文と、場合によっては必要なFDPS指示文について記述する。%%%\subsubsection{常に必要なFDPS指示文とその記述法}\label{subsubsec:EPI:FDPS_directives:always_required}常に必要となるFDPS指示文は、以下である：\begin{itemize}[leftmargin=*,itemsep=-1ex]\item 粒子の電荷量(質量)に対応するメンバ変数を指定する指示文\item 粒子の位置に対応するメンバ変数を指定する指示文\item FullParticle型から相互作用計算に必要な粒子データをコピーするための方法を指定する指示文\end{itemize}最初の2つに関しては、第\ref{subsubsec:FDPS_directives}節で説明した方法で記述すればよい。最後のものは、Fortranの場合、次の書式で指示文を記述する必要がある：\begin{screen}\begin{Verbatim}[commandchars=\\\{\}]type, public, bind(c) :: EPI   !\$fdps copyFromFP \vrbit{fp} (\vrbit{src_mbr},\vrbit{dst_mbr}) (\vrbit{src_mbr},\vrbit{dst_mbr}) ...end type EPI\end{Verbatim}\end{screen}書式は、(i) \verb|!$fdps|に続く文字列が\texttt{copyFromFP}である点、(ii)\textit{\texttt{fp}}がコピー元となるFullParticle型の派生データ型名である点、の2つ除き、第\ref{subsubsec:FP:FDPS_directives:always_required}節に記述した\texttt{copyFromForce}指示文と同じである。この場合、\textit{\texttt{src\_mbr}}がFullParticle型のメンバ変数名であることに注意されたい。C言語の場合、次の書式で記述する必要がある：\begin{screen}\begin{Verbatim}[commandchars=\\\{\}]struct epi \{   //\$fdps copyFromFP \vrbit{fp} (\vrbit{src_mbr},\vrbit{dst_mbr}) (\vrbit{src_mbr},\vrbit{dst_mbr}) ...\};\end{Verbatim}\end{screen}Fortranと全く同じ書式なので説明は省略する。%%%\subsubsection{場合によっては必要なFDPS指示文とその記述法}
\label{sec:EPI:FDPS_directives_required_in_specific_cases}
本節では、以下に示す場合に必要となる指示文について記述する：\begin{enumerate}[leftmargin=*,itemsep=-1ex,label=(\roman*)]\item 次の種別の相互作用ツリーオブジェクトを使用する場合：\begin{itemize}
\item Long-MonopoleWithSymmetrySearch 型
\item Long-QuadrupoleWithSymmetrySearch 型\item Short-Gather 型
\item Short-Symmetry 型\end{itemize}\item EssentialParticleI型が他のユーザ定義型を兼ねる場合\end{enumerate}(i)の場合、ユーザは派生データ型(Fortran) 或いは 構造体(C言語)のメンバ変数のどれが探索半径であるかを指定しなければならない(相互作用ツリーの種別に関しては、第\ref{chap:API_spec_list}章で解説する)。これは、第\ref{subsubsec:FDPS_directives}節で説明した方法で記述すればよい。(ii)の場合には、他のユーザ定義型で常に必要となるFDPS指示文のすべてと、場合によっては必要となるFDPS指示文を必要なだけ記述する必要がある。これらに関しては、対応するユーザ定義型の節を参照して頂きたい。%%%%%%%%%%%%%%%%%%%%%%%%%%%\subsection{EssentialParticleJ 型}\label{subsec:EssentialParticleJ}EssentialParticleJ 型は相互作用の計算に必要な$j$粒子の情報を持つ派生データ型(Fortran) 或いは 構造体(C言語)であり、相互作用関数(ユーザ定義関数)の定義に必要となるほか、相互作用ツリーオブジェクトの生成に必要となる。EssentialParticleJ 型は FullParticle 型(第\ref{subsec:FullParticle}節)のサブセットである。ユーザはFDPS指示文を用いて、必須物理量に対応するメンバ変数と、FullParticle型との間のデータ移動の方法を記述する必要がある。以下、常に必要なFDPS指示文と、場合によっては必要なFDPS指示文について記述する。%%%\subsubsection{常に必要なFDPS指示文とその記述法}常に必要となるFDPS指示文は、以下である：\begin{itemize}[leftmargin=*,itemsep=-1ex]\item 粒子の電荷量(質量)に対応するメンバ変数を指定する指示文\item 粒子の位置に対応するメンバ変数を指定する指示文\item FullParticle型から相互作用計算に必要な粒子データをコピーするための方法を指定する指示文\end{itemize}最初の2つに関しては、第\ref{subsubsec:FDPS_directives}節で説明した方法で記述すればよい。最後のものは、第\ref{subsubsec:EPI:FDPS_directives:always_required}節で説明した\texttt{copyFromFP}指示文を記述すればよい。%%%\subsubsection{場合によっては必要なFDPS指示文とその記述法}
\label{sec:EPJ:FDPS_directives_required_in_specific_cases}本節では、以下に示す場合に必要となる指示文について記述する：\begin{enumerate}[leftmargin=*,itemsep=-1ex,label=(\roman*)]\item 次の種別の相互作用ツリーオブジェクトを使用する場合：\begin{itemize}\item Long-MonopoleWithScatterSearch 型\item Long-QuadrupoleWithScatterSearch 型
\item Long-MonopoleWithSymmetrySearch 型
\item Long-QuadrupoleWithSymmetrySearch 型\item Long-MonopoleWithCutoff 型\item Short 型に分類されるすべてのツリー\end{itemize}\item EssentialParticleJ型が他のユーザ定義型を兼ねる場合\item 粒子の識別番号から対応する EPJ を取得したい場合 (API \texttt{(fdps\_)get\_epj\_from\_id} を使用する場合; 接頭辞\texttt{fdps\_}がつくのはC言語用APIのみ)\end{enumerate}(i)の場合、ユーザは派生データ型/構造体のメンバ変数のどれが探索半径であるかを指定しなければならない(相互作用ツリーの種別に関しては、第\ref{chap:API_spec_list}章で解説する)。これは、第\ref{subsubsec:FDPS_directives}節で説明した方法で記述すればよい。(ii)の場合には、他のユーザ定義型で常に必要となるFDPS指示文のすべてと、場合によっては必要となるFDPS指示文を必要なだけ記述する必要がある。これらに関しては、対応するユーザ定義型の節を参照して頂きたい。(iii)の場合には、ユーザは派生データ型/構造体のメンバ変数のどれが粒子の識別番号であるかを指定しなければならない。これは、第\ref{subsubsec:FDPS_directives}節で説明した方法で記述すればよい。%%%%%%%%%%%%%%%%%%%%%%%%%%%\subsection{Force 型}\label{subsec:Force}Force 型は相互作用の結果を保持する派生データ型(Fortran) 或いは 構造体(C言語)であり、相互作用関数の定義に必要となるほか、相互作用ツリーオブジェクトの生成に必要となる。以下、常に必要なFDPS指示文と、場合によっては必要なFDPS指示文について記述する。%%%\subsubsection{常に必要なFDPS指示文とその記述法}常に必要なFDPS指示文は、相互作用の計算結果を初期化する方法を指示する指示文である。この指示文の書式は、初期化の仕方に応じて\uline{3通り}ある。ユーザはいずれか1つの方法で初期化を指示しなければならない。以下、各書式について解説する。\begin{enumerate}[leftmargin=*,label=(\arabic*)]% すべてのメンバ変数をデフォルト初期化する場合  \litem{すべてのメンバ変数をデフォルト初期化する場合} Force型のすべてのメンバ変数に対して、デフォルトの初期化を行う場合には、何も記述しない。ここで、デフォルトの初期化とは、整数と浮動小数点数は0に、論理型は.false.(Fortran)/false(C言語)に、第\ref{chap:data_types}章のベクトル型と対称行列型はその各成分を0にする初期化のことである。% 個別に指定したい場合\litem{メンバ変数の初期化を個別に指定したい場合}Force型のメンバ変数を個別に、ある決まった値に初期化したい場合には、Fortranでは、以下のように記述する:\begin{screen}\begin{Verbatim}[commandchars=\\\{\}]type, public, bind(c) :: Force   !\$fdps clear [\vrbit{mbr}=\vrbit{val}, \vrbit{mbr}=keep, ...] end type Force\end{Verbatim}\end{screen}ここで、\texttt{Force}はForce型の派生データ型名である。見やすさのため、この派生データ型がForce型であることを示す指示文は省略していることに注意されたい。文字列\texttt{!\$fdps}が指示文の開始を示す。その後、1個以上の半角スペースを挟み、キーワード\texttt{clear}が続く。このキーワードによって、このFDPS指示文がForce型の初期化の方法を指示する文であるとみなされる。キーワード\texttt{clear}の後の[]はその中身が省略可能であることを示す記号であり、実際には[]を記述してはならないことに注意して頂きたい。個別指定の内容はキーワード\texttt{clear}の後に記述する。個別指定のないメンバ変数には自動的にデフォルト初期化が適用される。個別指定の方法は2種類あり、以下でそれを説明する。まず、特定のメンバ変数\textit{\texttt{mbr}}を特定の値\textit{\texttt{val}}に初期化したい場合には、\texttt{\textit{mbr}=\textit{val}}と記述する。ここで、記号\texttt{=}の前後に0個以上の半角スペースを入れることが可能である。初期値はメンバ変数の型と矛盾してはならず、Fortranの言語仕様に従って記述されなければならない。例えば、メンバ変数が論理型の場合には\texttt{.true.}か\texttt{.false.}のいずれかでなければならない。メンバ変数がベクトル型や対称行列型の場合、全成分を同じ値に初期化する初期化だけが指定可能であり、\textit{\texttt{val}}はスカラー値である必要がある。各成分を異なる値に初期化したい場合には、次項の初期化方法を使用して頂きたい。次に、特定のメンバ変数\textit{\texttt{mbr}}を初期化したくない場合には、\texttt{\textit{mbr}=keep}と記述する。右辺の\texttt{keep}が初期化しないことを指示するキーワードである。同様、記号\texttt{=}の前後に0個以上の半角スペースを入れることが可能である。複数の個別指定を並べることが可能で、その場合には、それらをカンマで区切って並べる。C言語では、次の書式で記述する：\begin{screen}\begin{Verbatim}[commandchars=\\\{\}]struct force \{   //\$fdps clear [\vrbit{mbr}=\vrbit{val}, \vrbit{mbr}=keep, ...] \};\end{Verbatim}\end{screen}Fortranと全く同じ書式なので説明は省略する。% 複雑な初期化を行いたい場合\litem{複雑な初期化を行いたい場合}より複雑な初期化を行いたい場合には、初期化を Fortran ではサブルーチン、C言語では関数、を用いて行うことができる。この場合には、Fortranでは、以下のように記述する:\begin{screen}\begin{Verbatim}[commandchars=\\\{\}]type, public, bind(c) :: Force   !\$fdps clear subroutine \vrbit{subroutine_name}end type Force\end{Verbatim}\end{screen}ここで、\textit{\texttt{subroutine\_name}}は初期化に使用するサブルーチン名である。このサブルーチンはグローバル領域に定義されていなければならない。言い換えれば、Fortranのモジュール内や他のサブルーチンや関数の内部手続として定義されてはならない。初期化を行うサブルーチンは以下のインターフェースを持たなければならない:\begin{screen}\begin{Verbatim}[commandchars=\\\{\}]subroutine \vrbit{subroutine_name}(f) bind(c)   use, intrinsic :: iso_c_binding   implicit none   type(Force), intent(inout) :: f      ! Initialize Force   end subroutine [\vrbit{subroutine_name}]\end{Verbatim}\end{screen}ここで、\texttt{[]}はその中身が省略可能であることを示す記号である。C言語では、次の書式で記述する：\begin{screen}\begin{Verbatim}[commandchars=\\\{\}]struct force \{   //\$fdps clear function \vrbit{function_name}\};\end{Verbatim}\end{screen}書式はFortranの場合とほぼ同じである。初期化に使用する関数はグローバル領域に定義されていなければならない。初期化を行う関数は以下のインターフェースを持つ必要がある：\begin{screen}\begin{Verbatim}[commandchars=\\\{\}]void \vrbit{function_name}(struct force *f) \{      // Initialize Force   \}\end{Verbatim}\end{screen}\end{enumerate}%%%\subsubsection{場合によっては必要なFDPS指示文とその記述法}なし%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\section{ユーザ定義関数}\label{sec:user_defined_function}まず概要を述べる。関数 calcForceEpEp と calcForceEpSp は、それぞれ $j$粒子から$i$粒子への作用を計算する関数と超粒子から$i$粒子への作用を計算する関数である。これらの関数ポインタは、相互作用ツリー用の API の引数として渡される。相互作用が短距離力の場合には超粒子を必要としない。その場合、関数 calcForceEpSp を定義する必要はない。%%%%%%%%%%%%%%%%%%%%%%%%%%%\subsection{共通規則}まず最初にFortranで関数 calcForceEpEp と calcForceEpSp を定義するための規則について説明を行い、その後、C言語での規則について説明を行う。%%%%\subsubsection{Fortran 文法に関する要請 および FDPS本体の仕様による要請}\label{s2sec:requirements_for_ftn_grammer_for_udt_func}本節では、Fortranのサブルーチンがユーザ定義関数となるために満たすべき最低限のFortran文法について記述する。これを説明するため、FDPS Fortran インターフェースを使って相互作用計算を行うまでにユーザが踏むべき手順について述べる。インターフェースプログラムの生成が成功したと仮定すると、次のようになる：\begin{enumerate}[leftmargin=*,itemsep=-1ex,label=(\Roman*)]\item 相互作用計算の内容をFortran サブルーチンとして実装する。\item ユーザプログラムにおいて、関数のC言語アドレスを格納するための変数を用意する。これはFortran 2003のモジュール\path{iso_c_binding}で提供される派生データ型\path{type(c_funloc)}の変数を用意すればよい。\item ユーザプログラムにおいて、相互作用計算に使用するFortran サブルーチンのC言語アドレスを、モジュール\path{iso_c_binding}で提供される関数\path{c_funloc}によって取得し、前項の変数に代入する。\label{enum:user_defined_func_proc3}\item FDPS APIの引数に関数ポインタが格納された変数を渡して、APIを呼び出す。\item FDPS 本体は受け取ったC言語アドレスをC言語で記述された関数と理解して、実行する。\end{enumerate}上記手順の\ref{enum:user_defined_func_proc3}において、関数\path{c_funloc}でユーザ定義関数のC言語アドレスを取得するためには、ユーザ定義関数がC言語とinteroperableでなければならない。具体的には、ユーザ定義関数となるFortranサブルーチンは次の条件を満たしている必要がある：\begin{enumerate}[leftmargin=*,itemsep=-1ex,label=(\arabic*)]\item 関数は\path{bind(c)}属性を持たなければならない。\item すべての仮引数がinteroperableなデータ型である。interoperableなデータ型に関しては、第\ref{subsec:common_rules_for_user_defined_types}節の記述を参照されたい。\end{enumerate}上に述べた条件に加え、FDPS 本体の仕様に起因する条件がある。それは以下の条件である：\begin{enumerate}[leftmargin=*,itemsep=-1ex,label=(\arabic*),resume]\item ユーザ定義関数の仮引数の内、$i$粒子と$j$粒子の粒子数に対応する仮引数は\path{value}属性が付いていなければならない。\path{value}属性は、いわゆる値渡しであることを指示するものである。 \end{enumerate}以上がユーザ定義関数が満たすべき最低限の条件である。理解を助ける目的で、$N$体計算のサンプルコードの粒子-粒子相互作用に対応したユーザ定義関数の例をリスト\ref{listing:user_defined_func_example}に示しておく。相互作用関数の記述方法の詳細はまだ解説していないので、ここでは、\path{bind(c)}属性と\path{value}属性の位置だけを確認して頂きたい。\begin{lstlisting}[caption=粒子-粒子相互作用に対応したユーザ定義関数の実装例,label=listing:user_defined_func_example]subroutine calc_gravity_pp(ep_i,n_ip,ep_j,n_jp,f) bind(c)   integer(c_int), intent(in), value :: n_ip,n_jp   type(full_particle), dimension(n_ip), intent(in) :: ep_i   type(full_particle), dimension(n_jp), intent(in) :: ep_j   type(full_particle), dimension(n_ip), intent(inout) :: f   !* Local variables   integer(c_int) :: i,j   real(c_double) :: eps2,poti,r3_inv,r_inv   type(fdps_f64vec) :: xi,ai,rij         do i=1,n_ip      eps2 = ep_i(i)%eps * ep_i(i)%eps      xi%x = ep_i(i)%pos%x      xi%y = ep_i(i)%pos%y      xi%z = ep_i(i)%pos%z      ai%x = 0.0d0      ai%y = 0.0d0      ai%z = 0.0d0      poti = 0.0d0      do j=1,n_jp         rij%x  = xi%x - ep_j(j)%pos%x         rij%y  = xi%y - ep_j(j)%pos%y         rij%z  = xi%z - ep_j(j)%pos%z         r3_inv = rij%x*rij%x &                + rij%y*rij%y &                + rij%z*rij%z &                + eps2         r_inv  = 1.0d0/sqrt(r3_inv)         r3_inv = r_inv * r_inv         r_inv  = r_inv * ep_j(j)%mass         r3_inv = r3_inv * r_inv         ai%x   = ai%x - r3_inv * rij%x         ai%y   = ai%y - r3_inv * rij%y         ai%z   = ai%z - r3_inv * rij%z         poti   = poti - r_inv      end do      f(i)%pot   = f(i)%pot   + poti      f(i)%acc%x = f(i)%acc%x + ai%x      f(i)%acc%y = f(i)%acc%y + ai%y      f(i)%acc%z = f(i)%acc%z + ai%z   end doend subroutine calc_gravity_pp\end{lstlisting}%%%%\subsubsection{C言語 文法に関する要請 および FDPS本体の仕様による要請}Fortranの場合と異なり(第\ref{s2sec:requirements_for_ftn_grammer_for_udt_func}節参照)、C言語からFDPSを利用する場合、ユーザは任意の関数のC言語アドレスを自由に取得することが可能である。そのため、\texttt{void}関数を使ってユーザ定義関数を実装する際、C言語文法的な制限は存在しない。しかしながら、FDPS本体ではユーザ定義関数の仮引数仕様が決まっているため、C言語でもそれを満たす必要がある。これについては次節以降に説明する。%%%%%%%%%%%%%%%%%%%%%%%%%%%\subsection{関数 calcForceEpEp}\label{subsec:calcForceEpEp}関数 calcForceEpEp は粒子同士の相互作用を記述するものであり、相互作用の定義に必要となる。関数 calcForceEpEp は、以下の書式で記述しなければならない。\subsubsection*{Fortran 書式}\begin{screen}\begin{Verbatim}[commandchars=\\\{\}]subroutine calc_force_ep_ep(ep_i,n_ip,ep_j,n_jp,f) bind(c)   use, intrinsic :: iso_c_binding   implicit none   integer(kind=c_int), intent(in), value :: n_ip,n_jp   type(essential_particle_i), dimension(n_ip), intent(in) :: ep_i   type(essential_particle_j), dimension(n_jp), intent(in) :: ep_j   type(force), dimension(n_ip), intent(inout) :: f   end subroutine calc_force_ep_ep\end{Verbatim}\end{screen}\subsubsection*{C言語 書式}\begin{screen}\begin{Verbatim}[commandchars=\\\{\}]void calc_force_ep_ep(struct essential_particle_i *ep_i,                      int n_ip,                      struct essential_particle_j *ep_j,                      int n_jp,                      force *f) \{                        \}\end{Verbatim}\end{screen}% 仮引数\subsubsection*{仮引数仕様}\begin{table}[H]\begin{tabularx}{\linewidth}{cccX}\toprule\rowcolor{Snow2}仮引数名 & データ型 & 入出力属性 & 定義 \\\midrule\texttt{n\_ip} & integer(kind=c\_int) または int & 入力 & $i$粒子の粒子数を格納した変数。\\\texttt{n\_jp} & integer(kind=c\_int) または int & 入力 & $j$粒子の粒子数を格納した変数。\\\texttt{ep\_i} & essential\_particle\_i 型$^{\dagger}$ & 入力 & $i$粒子情報を持つ配列。\\\texttt{ep\_j} & essential\_particle\_j 型$^{\dagger}$ & 入力 & $j$粒子情報を持つ配列。\\\texttt{f} & force 型$^{\dagger}$ & 入出力 & $i$粒子の相互作用結果を返す配列。\\\bottomrule\end{tabularx}\begin{flushleft}$^{\ddagger}$ それぞれEssentialParticleI型、EssentialParticleJ型、Force型の派生データ型名(Fortran) または 構造体名(C言語)である。Fortranにおいては、もしこれらが本サブルーチンと別なモジュールで定義されている場合には、そのモジュールを\path{use}する必要がある点に注意されたい。同様に、C言語の場合でも必要なヘッダーファイルをインクルードする必要がある。\end{flushleft}\end{table}% 返り値\subsubsection*{返り値}なし% 機能\subsubsection*{機能}$j$粒子から$i$粒子への作用を計算する。%%%%%%%%%%%%%%%%%%%%%%%%%%%\subsection{関数 calcForceEpSp}\label{subsec:calcForceEpSP}関数 calcForceEpSp は超粒子から粒子への作用を記述するものであり、相互作用の定義に必要となる。関数 calcForceEpEp は以下の書式で記述しなければならない。\subsubsection*{Fortran 書式}\begin{screen}\begin{Verbatim}[commandchars=\\\{\}]subroutine calc_force_ep_sp(ep_i,n_ip,ep_j,n_jp,f) bind(c)   use, intrinsic :: iso_c_binding   use :: fdps_super_particle   implicit none   integer(kind=c_int), intent(in), value :: n_ip,n_jp   type(essential_particle_i), dimension(n_ip), intent(in) :: ep_i   type(super_particle_j), dimension(n_jp), intent(in) :: ep_j   type(force), dimension(n_ip), intent(inout) :: f   end subroutine calc_force_ep_sp\end{Verbatim}\end{screen}\subsubsection*{C言語 書式}\begin{screen}\begin{Verbatim}[commandchars=\\\{\}]void calc_force_ep_sp(struct essential_particle_i *ep_i,                      int n_ip,                      struct super_particle_j *ep_j,                      int n_jp,                      force *f) \{   \}\end{Verbatim}\end{screen}% 仮引数\subsubsection*{仮引数仕様}\begin{table}[H]\begin{tabularx}{\linewidth}{cccX}\toprule\rowcolor{Snow2}仮引数名 & データ型 & 入出力属性 & 定義 \\\midrule\texttt{n\_ip} & integer(kind=c\_int) または int & 入力 & $i$粒子の粒子数を格納した変数。\\\texttt{n\_jp} & integer(kind=c\_int) または int & 入力 & 超粒子の粒子数を格納した変数。\\\texttt{ep\_i} & essential\_particle\_i 型$^{\dagger}$ & 入力 & $i$粒子情報を持つ配列。\\\texttt{ep\_j} & super\_particle\_j 型$^{\ddagger}$ & 入力 & 超粒子情報を持つ配列。\\\texttt{f} & force 型$^{\dagger}$ & 入出力 & $i$粒子の相互作用結果を返す配列。\\\bottomrule\end{tabularx}\begin{flushleft}$^{\dagger}$ それぞれEssentialParticleI型とForce型の派生データ型名(Fortran) または 構造体名(C言語)である。Fortranでは、これらが本サブルーチンと別なモジュールで定義されている場合には、そのモジュールを\path{use}する必要がある点に注意されたい。同様に、C言語でも必要なヘッダーファイルをインクルードする必要がある。\\$^{\ddagger}$ 第\ref{chap:data_types}章\ref{sec:super_particle_types}節で定義されるいずれかの超粒子型でなければならない。\end{flushleft}\end{table}% 返り値\subsubsection*{返り値}なし% 機能\subsubsection*{機能}超粒子から$i$粒子への作用を計算する。