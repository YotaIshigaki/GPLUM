\subsubsection{概要}

{\tt PS::ParticleSystem}から粒子の情報を読み取り、内部でツリーを構築し
相互作用の計算を行い、結果を格納するクラス。{\tt PS::ParticleSystem}に
結果を書き戻す事も出来る。内部には相互作用演算を効率的に行う為の3種類の
粒子型\verb|EssentialParticleI|型、\verb|EssentialParticleJ|型、
\verb|SuperParticleJ|型、また、相互作用の結果を格納する\verb|Force|型、
がありさらに、ツリー構造を実現するための\verb|TreeParticle|型、
\verb|TreeCell|型という、全6種類のクラスを配列として持っている。これら
の配列はprvate空間に存在し、ユーザーが直接アクセスする事は出来ない。

相互作用クラス({\tt TreeForForce})は以下のように記述される。

\begin{lstlisting}[caption=相互作用クラス]
    template<int SEARCH_MODE, class Tforce, class Tepi,
        class Tepj, class Tmomloc, class Tmomglb, class Tspj>
    class TreeForForce{
    public:
        void initialize(const S64 ntot,
                        const F32 theta,
                        const S32 nleafmax,
                        const S32 ngroupmax);

        %void initializeLocalTree(const F32 len_half);

        template<class Tpsys>
        void setParticleLocalTree(const Tpsys & psys,
                                  const bool clear=true);

        void makeLocalTree(const bool cancel=false);

        void makeGlobalTree(const bool cancel=false);

        void exchangeLocalEssentialTree(const DomainInfo & dinfo);

        void setLocalEssentialTreeToGlobalTree();

        Tforce & getForce(const S32 id);

        template<class Tfunc_ep_ep, class Tpsys>
        void calcForceAll(Tfunc_ep_ep pfunc_ep_ep, 
                          Tpsys & psys,
                          DomainInfo & dinfo,
                          const bool clear_force = true);

        template<class Tfunc_ep_ep, class Tpsys>
        void calcForceAllAndWriteBack(Tfunc_ep_ep pfunc_ep_ep, 
                                      Tpsys & psys,
                                      DomainInfo & dinfo,
                                      const bool clear_force = true);

        template<class Tfunc_ep_ep, class Tfunc_ep_sp, class Tpsys>
        void calcForceAll(Tfunc_ep_ep pfunc_ep_ep, 
                          Tfunc_ep_sp pfunc_ep_sp,  
                          Tpsys & psys,
                          DomainInfo & dinfo,
                          const bool clear_force=true);

        template<class Tfunc_ep_ep, class Tfunc_ep_sp, class Tpsys>
        void calcForceAllAndWriteBack(Tfunc_ep_ep pfunc_ep_ep, 
                                      Tfunc_ep_sp pfunc_ep_sp,  
                                      Tpsys & psys,
                                      DomainInfo & dinfo,
                                      const bool clear_force=true);

        template<class Tfunc_ep_ep, class Tpsys>
        void makeTreeAndCalcForce(Tfunc_ep_ep pfunc_ep_ep, 
                                  DomainInfo & dinfo,
                                  const bool clear_force = true);

        template<class Tfunc_ep_ep, class Tfunc_ep_sp, class Tpsys>
        void makeTreeAndCalcForce(Tfunc_ep_ep pfunc_ep_ep, 
                                  Tfunc_ep_sp pfunc_ep_sp,  
                                  DomainInfo & dinfo,
                                  const bool clear_force=true){



        template<class Tfunc_ep_ep, class Tfunc_ep_sp, class Tpsys>
        void calcForceAll(Tfunc_ep_ep pfunc_ep_ep, 
                          Tfunc_ep_sp pfunc_ep_sp,  
                          DomainInfo & dinfo,
                          const bool clear_force=true);
    };
}
\end{lstlisting}

テンプレートパラメータの第一引数である{\tt SEARCH\_MODE}により、ツリー
ウォークの方法を選択できる。

\mbox{}
\begin{table}[h!]
\begin{tabular}{llll}
{\tt SEARCH\_MODE} &=& {\tt PS::SEARCH\_MODE\_LONG} & cutoffなし長距離力モード。　\\
     	          &=& {\tt PS::SEARCH\_MODE\_LONG\_CUTOFF} & cutoffあり長距離力モード。　\\
     	          &=& {\tt PS::SEARCH\_MODE\_GATHER} & 収集モード。　\\
     	          &=& {\tt PS::SEARCH\_MODE\_SCATTER} & 散乱モード。　\\
     	          &=& {\tt PS::SEARCH\_MODE\_SYMMETRY} & 対称モード。
\end{tabular}
\end{table}
\mbox{}

テンプレートパラメータの第二引数は{\tt FORCE}クラス、第三引数は{\tt
EPI}クラス、第四引数は{\tt EPJ}クラス。第五、六引数はそれぞれローカルツ
リー、グローバルツリーの持つ{\tt MOMENT}クラス。第七引数は{\tt SPJ}クラ
スである。

{\tt TreeForForce}はテンプレートパラメータが多いため、以下の様なラッパー
クラスが用意されており、ユーザーはこちらを使う事が推奨される。長距離力
の場合はテンプレート引数が{\tt FORCE}, {\tt EPI}, {\tt EPJ}, {\tt
MOMENT}, {\tt SPJ}の5つ。短距離量の場合はテンプレート引数が{\tt
FORCE}, {\tt EPI}, {\tt EPJ}の3つである。長距離力の場合はさらに、四重極
モーメント迄の計算については{\tt MOMENT}, {\tt SPJ}クラスが用意されてお
り、それに対応したラッパーも存在する。


\begin{lstlisting}

namespace ParticleSimulator{
    template<class Tforce, class Tepi, class Tepj, class Tmom=void, class Tsp=void>
    class TreeForForceLong{
    public:
        typedef TreeForForce
        <SEARCH_MODE_LONG,
         Tforce, Tepi, Tepj,
         Tmom, Tmom, Tsp> Normal; // cutoffなし長距離力モード

        typedef TreeForForce
        <SEARCH_MODE_LONG_CUTOFF,
         Tforce, Tepi, Tepj,
         Tmom, Tmom, Tsp> WithCutoff; // cutoffあり長距離力モード
    };

    template<class Tforce, class Tepi, class Tepj>
    class TreeForForceLong<Tforce, Tepi, Tepj, void, void>{
    public:
        typedef TreeForForce
        <SEARCH_MODE_LONG,
         Tforce, Tepi, Tepj,
         MomentMonopole,
         MomentMonopole,
         SPJMonoPole> Monopole;

        typedef TreeForForce
        <SEARCH_MODE_LONG,
         Tforce, Tepi, Tepj,
         MomentDipole,
         MomentDipole,
         SPJMonoPole> Dipole;

        typedef TreeForForce
        <SEARCH_MODE_LONG,
         Tforce, Tepi, Tepj,
         MomentQuadrupole,
         MomentQuadrupole,
         SPJMonoPole> Quadrupole;
    };

    template<class Tforce, class Tepi, class Tepj>
    class TreeForForceShort{
    public:
        typedef TreeForForce 
        <SEARCH_MODE_SYMMETRY,
         Tforce, Tepi, Tepj,
         MomentSearchInAndOut,
         MomentSearchInAndOut,
         SuperParticleBase> Symmetry; // 短距離、対称モード

        typedef TreeForForce 
        <SEARCH_MODE_GATHER,
         Tforce, Tepi, Tepj,
         MomentSearchInAndOut,
         MomentSearchInOnly,
         SuperParticleBase> Gather; // 短距離、収集モード

        typedef TreeForForce
        <SEARCH_MODE_SCATTER,
         Tforce, Tepi, Tepj,
         MomentSearchInOnly,
         MomentSearchInAndOut,
         SuperParticleBase> Scatter; // 短距離、散乱モード
    };
}
\end{lstlisting}

\subsubsection{API}

%%%%%%%%%%%%%%%%%%%%%%%%%
%%% format
%%%%%%%%%%%%%%%%%%%%%%%%%
%%%  \begin{screen}
%%%  \begin{verbatim}
%%%  function()
%%%  \end{verbatim}
%%%  \end{screen}
%%%
%%%  \begin{itemize}
%%%
%%%  \item{{\bf 引数}}
%%%
%%%  \item{{\bf 返り値}}
%%%
%%%  \item{{\bf 機能}}
%%%
%%%  \end{itemize}
%%%
%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%
\paragraph{初期化}
\mbox{}
%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{screen}
\begin{verbatim}
void PS::TreeForForce::initialize(const PS::S64 ntot,
                                  const PS::F32 theta=0.5,
                                  const PS::S32 nleafmax=8,
                                  const PS::S32 ngroupmax=64)
\end{verbatim}
\end{screen}

\begin{itemize}

\item{{\bf 引数}}

{\tt ntot}: 入力。{\tt const PS::S64}型。相互作用にかかわる全粒子数。

{\tt theta}: 入力。{\tt const PS::F32}型。ツリーのオープニングクライテ
リオン。長距離相互作用において、あるツリーセルからある粒子(実際にはi粒
子グループ)への力を計算する時に見込角が{\tt theta}以下の時はツリーセル
の多重極モーメントを用いて相互作用を評価する。近距離力では任意の値でよ
い。デフォルト0.5。

{\tt nleafmax}: 入力。{\tt const PS::S32}型。ツリーリーフセル内の最大粒
子数。あるセル内にこの数を超える粒子が入っていた場合、そのセルはさらに
分割される。デフォルト8。

{\tt ngroupmax}: 入力。{\tt const PS::S32}型。i粒子グループ内の最大粒子
数。i粒子グループとは相互作用リスト（\verb|EssentialParticleJ|型、
\verb|SuperParticleJ|型の配列）を共有するi粒子のグループである。ツリー
構造にそってグルーピングする為、グループ内の粒子は固まって存在している。
グループの粒子数は{\tt ngroupmax}を超えないようにグルーピングが行われる。
デフォルト64。

\item{{\bf 返り値}}

なし。

\item{{\bf 機能}}

相互作用ツリーの初期設定を行い、\verb|EssentialParticleI|型、
\verb|EssentialParticleJ|型、\verb|SuperParticleJ|型、\verb|Force|型、
\verb|PS::TreeParticle|型、\verb|PS::TreeCell|型のメンバの配列を確保す
る。配列のサイズを推定するのに{\tt ntot}を使う。自クラス内にi粒子グルー
プ内の最大粒子数とツリーリーフセル内の最大粒子数をセットする。{\tt
theta}は長距離力用のツリーのオープニングクライテリオンであり、短距離力
の場合は値は何でもよい。

\end{itemize}
%%%%%%%%%%%%%%%


%\begin{screen}
%\begin{verbatim}
%void PS::TreeForForce::initializeLocalTree(const PS::F32 len_half);
%\end{verbatim}
%\end{screen}

%\begin{itemize}

%\item{{\bf 引数}}

%{\tt len\_half}: 入力。{\tt const PS::F32}型。ツリーのルートセルの一辺の
半分の長さ。

%\item{{\bf 返り値}}

%なし。

%\item{{\bf 機能}}

%ツリーのルートセルの一辺の半分の長さを与える。

%\end{itemize}
%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%
\paragraph{粒子読み込み}
\mbox{}
%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%
\begin{screen}
\begin{verbatim}
void PS::TreeForForce::setParticleLocalTree(
                       const PS::ParticleSystem & psys,
                       const bool clear=true);
\end{verbatim}
\end{screen}

\begin{itemize}

\item{{\bf 引数}}

{\tt psys}: 入力。{\tt const PS::ParticleSystem \&}型。

{\tt clear}: 入力。{\tt const bool clear}型。クリアフラグ。デフォルトtrue。

\item{{\bf 返り値}}

なし。

\item{{\bf 機能}}

{\tt psys}から{\tt FullParticle}を読み込み、メンバの{\tt
PS::TreeParticle}型、{\tt EssentailParticleI}、{\tt
EssentailParticleJ}型の配列にツリー生成や力の計算に必要な情報をコピーす
る。

\end{itemize}



%%%%%%%%%%%%%%%
\begin{screen}
\begin{verbatim}
void PS::TreeForForce::setLocalEssentialTreeToGlobalTree();

\end{verbatim}
\end{screen}

\begin{itemize}

\item{{\bf 引数}}

\item{{\bf 返り値}}

なし。

\item{{\bf 機能}}

{\tt exchangeLocalEssentialTree}で送られて来た粒子を{\tt TreeParticle}
型に変換する。

\end{itemize}

%%%%%%%%%%%%%%%
\paragraph{ツリー生成}
\mbox{}
%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%
\begin{screen}
\begin{verbatim}
void PS::TreeForForce::makeLocalTree(const bool cancel=false);
\end{verbatim}
\end{screen}

\begin{itemize}

\item{{\bf 引数}}

{\tt cancel}: 入力。{\tt const bool}型。キャンセルフラグ。デフォルトfalse。

\item{{\bf 返り値}}

なし。

\item{{\bf 機能}}

LTを作り、モートンソートを行い、モーメント計算まで行う。LTづくりとモー
トンソートは{\tt cancel}が{\tt true}なら行わない。

\end{itemize}



%%%%%%%%%%%%%%%
\begin{screen}
\begin{verbatim}
void PS::TreeForForce::exchangeLocalEssentialTree()

\end{verbatim}
\end{screen}

\begin{itemize}

\item{{\bf 引数}}

なし。

\item{{\bf 返り値}}

なし。

\item{{\bf 機能}}

LocalEssentialTreeを作り、各プロセスに送る。イメージ粒子が存在する場合
は、それらもLocalEssentialTreeの中に組み込まれる。

\end{itemize}


%%%%%%%%%%%%%%%
\begin{screen}
\begin{verbatim}
void PS::TreeForForce::makeGlobalTree(const bool cancel=false);
\end{verbatim}
\end{screen}
\begin{itemize}

\item{{\bf 引数}}

{\tt cancel}: 入力。{\tt const bool}型。キャンセルフラグ。デフォルトfalse。

\item{{\bf 返り値}}

なし。

\item{{\bf 機能}}

GTを作り、モートンソートを行い、モーメント計算まで行う。
GTづくりとモートンソートは{\tt cancel}が{\tt true}なら行わない。

\end{itemize}


%%%%%%%%%%%%%%%
\paragraph{力の計算}
\mbox{}
%%%%%%%%%%%%%%%

以下に述べる6つの関数はテンプレート関数となっており、関数の引数として
{\tt Tfunc\_ep\_ep}型や{\tt Tfunc\_ep\_sp}型を取る。これらはユーザーが定義
した相互作用関数のポインタもしくは相互作用関数オブジェクトを取る。

関数ポインタを使う場合
\begin{lstlisting}[caption=関数ポインタを使う場合]
void CalcForceEpEp(const EssentialPtclI * ep_i,
                   const PS::S32 n_ip,
                   const EssentialPtclJ * ep_j,
                   const PS::S32 n_jp,
                   ResultForce * force){
......
}
\end{lstlisting}

関数オブジェクトを使う場合
\begin{lstlisting}[caption=関数ポインタを使う場合]
class CalcForceEpEp{
public:
    void operator()(const EssentialPtclI * ep_i,
                    const PS::S32 n_ip,
                    const EssentialPtclJ * ep_j,
                    const PS::S32 n_jp,
                    ResultForce * force){
......
    }
}
\end{lstlisting}

関数ポインタ、関数オブジェクトどちらを使う場合も返り値はvoid型とし、引
数は第一引数から順に{\tt const EssentialParticleI *}型、{\tt PS::S32}型、
{\tt const EssentialParticleJ *}型、{\tt PS::S32}型、{\tt Force *}型。


%%%%%%%%%%%%%%%
\begin{screen}
\begin{verbatim}
template<class Tfunc_ep_ep>
void PS::TreeForForce::calcForce( Tfunc_ep_ep func_ep_ep);

\end{verbatim}
\end{screen}

\begin{itemize}

\item{{\bf 引数}}

{\tt (func\_ep\_ep)}: 入力。返り値がvoid型の{EssentialParticleI}と
{EssentialParticleJ}間の相互作用計算用関数ポインタ、もしくは関数オブジェ
クト。関数の引数は第一引数から順に{\tt const EssentialParticleI *}型、
{\tt PS::S32}型、{\tt const EssentialParticleJ *}型、{\tt PS::S32}型、
{\tt Force *}型。

\item{{\bf 返り値}}

なし。

\item{{\bf 機能}}

全粒子に対して、GT内のツリーウォークと相互作用計算を行い、結果を\\
{\tt PS::TreeForForce::setParticleFromFullParticle()}で読み込んだ時の粒
子の並びと同じ順番で格納する。この関数を呼ぶ前に
\verb|PS::TreeForForce::makeIPGroup()|で、i粒子をグルーピングしておく必
要がある。

\end{itemize}

%%%%%%%%%%%%%%%
\begin{screen}
\begin{verbatim}
template<class Tfunc_ep_ep>
void PS::TreeForForce::calcForceAll( Tfunc_ep_ep func_ep_ep,  PS::ParticleSystem & psys) 

\end{verbatim}
\end{screen}

\begin{itemize}

\item{{\bf 引数}}

{\tt (func\_ep\_ep)}: 入力。返り値がvoid型の{EssentialParticleI}と
{EssentialParticleJ}間の相互作用計算用関数ポインタ、もしくは関数オブジェ
クト。関数の引数は第一引数から順に{\tt const EssentialParticleI *}型、
{\tt PS::S32}型、{\tt const EssentialParticleJ *}型、{\tt PS::S32}型、
{\tt Force *}型。

{\tt psys}: 入力。{\tt PS::ParticleSystem \&}型。

\item{{\bf 返り値}}

なし。

\item{{\bf 機能}}

粒子移動、LT作り、LET交換、GT作り、相互作用計算まで行い、結果を\\ {\tt
PS::TreeForForce::setParticleFromFullParticle()}で読み込んだ時の粒子の
並びと同じ順番で格納する。

\end{itemize}

%%%%%%%%%%%%%%%
\begin{screen}
\begin{verbatim}
template<class Tfunc_ep_ep>
void PS::TreeForForce::calcForceAll( Tfunc_ep_ep func_ep_ep,  PS::ParticleSystem & psys) 

\end{verbatim}
\end{screen}

\begin{itemize}

\item{{\bf 引数}}

{\tt (func\_ep\_ep)}: 入力。返り値がvoid型の{EssentialParticleI}と
{EssentialParticleJ}間の相互作用計算用関数ポインタ、もしくは関数オブジェ
クト。関数の引数は第一引数から順に{\tt const EssentialParticleI *}型、
{\tt PS::S32}型、{\tt const EssentialParticleJ *}型、{\tt PS::S32}型、
{\tt Force *}型。

{\tt psys}: 入力。{\tt PS::ParticleSystem \&}型。

\item{{\bf 返り値}}

なし。

\item{{\bf 機能}}

粒子移動、LT作り、LET交換、GT作り、相互作用計算まで行い、結果を\\
{\tt PS::TreeForForce::setParticleFromFullParticle()}で読み込んだ時の粒
子の並びと同じ順番で格納し、さらに{\tt psys}にも書き戻す。

\end{itemize}









%%%%%%%%%%%%%%%
\begin{screen}
\begin{verbatim}
template<class Tfunc_ep_ep, class Tfunc_ep_sp>
void PS::TreeForForce::calcForce( Tfunc_ep_ep func_ep_ep, Tfunc_ep_sp func_epsp);

\end{verbatim}
\end{screen}

\begin{itemize}

\item{{\bf 引数}}

{\tt (func\_ep\_ep)}: 入力。返り値がvoid型の{EssentialParticleI}と
{EssentialParticleJ}間の相互作用計算用関数ポインタ、もしくは関数オブジェ
クト。関数の引数は第一引数から順に{\tt const EssentialParticleI *}型、
{\tt PS::S32}型、{\tt const EssentialParticleJ *}型、{\tt PS::S32}型、
{\tt Force *}型。

{\tt (func\_ep\_sp)}: 入力。返り値がvoid型の{EssentialParticleI}と
{SuperParticleJ}間の相互作用計算用関数ポインタ、もしくは関数オブジェ
クト。関数の引数は第一引数から順に{\tt const EssentialParticleI *}型、
{\tt PS::S32}型、{\tt const SuperParticleJ *}型、{\tt PS::S32}型、
{\tt Force *}型。

\item{{\bf 返り値}}

なし。

\item{{\bf 機能}}

全粒子に対して、GT内のツリーウォークと相互作用計算を行い、結果を\\
{\tt PS::TreeForForce::setParticleFromFullParticle()}で読み込んだ時の粒
子の並びと同じ順番で格納する。この関数を呼ぶ前に
\verb|PS::TreeForForce::makeIPGroup()|で、i粒子をグルーピングしておく必
要がある。

\end{itemize}

%%%%%%%%%%%%%%%
\begin{screen}
\begin{verbatim}
template<class Tfunc_ep_ep, class Tfunc_ep_sp>
void PS::TreeForForce::calcForceAll( Tfunc_ep_ep func_ep_ep,   Tfunc_ep_sp func_ep_sp,  
                                     PS::ParticleSystem & psys) 

\end{verbatim}
\end{screen}

\begin{itemize}

\item{{\bf 引数}}

{\tt (func\_ep\_ep)}: 入力。返り値がvoid型の{EssentialParticleI}と
{EssentialParticleJ}間の相互作用計算用関数ポインタ、もしくは関数オブジェ
クト。関数の引数は第一引数から順に{\tt const EssentialParticleI *}型、
{\tt PS::S32}型、{\tt const EssentialParticleJ *}型、{\tt PS::S32}型、
{\tt Force *}型。

{\tt (func\_ep\_sp)}: 入力。返り値がvoid型の{EssentialParticleI}と
{SuperParticleJ}間の相互作用計算用関数ポインタ、もしくは関数オブジェ
クト。関数の引数は第一引数から順に{\tt const EssentialParticleI *}型、
{\tt PS::S32}型、{\tt const SuperParticleJ *}型、{\tt PS::S32}型、
{\tt Force *}型。

{\tt psys}: 入力。{\tt PS::ParticleSystem \&}型。

\item{{\bf 返り値}}

なし。

\item{{\bf 機能}}

粒子移動、LT作り、LET交換、GT作り、相互作用計算まで行い、結果を\\
{\tt PS::TreeForForce::setParticleFromFullParticle()}で読み込んだ時の粒
子の並びと同じ順番で格納する。

\end{itemize}

%%%%%%%%%%%%%%%
\begin{screen}
\begin{verbatim}
template<class Tfunc_ep_ep, class Tfunc_ep_sp>
void PS::TreeForForce::calcForceAllAndWriteBack( Tfunc_ep_ep func_ep_ep,  Tfunc_ep_sp func_ep_sp, 
                                                 PS::ParticleSystem & psys) 

\end{verbatim}
\end{screen}

\begin{itemize}

\item{{\bf 引数}}

{\tt (func\_ep\_ep)}: 入力。返り値がvoid型の{EssentialParticleI}と
{EssentialParticleJ}間の相互作用計算用関数ポインタ、もしくは関数オブジェ
クト。関数の引数は第一引数から順に{\tt const EssentialParticleI *}型、
{\tt PS::S32}型、{\tt const EssentialParticleJ *}型、{\tt PS::S32}型、
{\tt Force *}型。

{\tt (func\_ep\_sp)}: 入力。返り値がvoid型の{EssentialParticleI}と
{SuperParticleJ}間の相互作用計算用関数ポインタ、もしくは関数オブジェ
クト。関数の引数は第一引数から順に{\tt const EssentialParticleI *}型、
{\tt PS::S32}型、{\tt const SuperParticleJ *}型、{\tt PS::S32}型、
{\tt Force *}型。

{\tt psys}: 入力。{\tt PS::ParticleSystem \&}型。

\item{{\bf 返り値}}

なし。

\item{{\bf 機能}}

粒子移動、LT作り、LET交換、GT作り、相互作用計算まで行い、結果を\\ {\tt
PS::TreeForForce::setParticleFromFullParticle()}で読み込んだ時の粒子の
並びと同じ順番で格納し、さらに{\tt psys}にも書き戻す。

\end{itemize}



%%%%%%%%%%%%%%%
\begin{screen}
\begin{verbatim}
void PS::TreeForForce::makeIPGroup()
\end{verbatim}
\end{screen}
\begin{itemize}

\item{{\bf 引数}}

なし。

\item{{\bf 返り値}}

なし。

\item{{\bf 機能}}

i粒子をツリー構造にしたがってグルーピングする。グループ内の最大粒子数は
\\{\tt PS::TreeForForce::initialize()}の第四引数でセットされた値である。

\end{itemize}

%%%%%%%%%%%%%%%
\begin{screen}
\begin{verbatim}
PS::S32 & PS::TreeForForce::getNumberOfIPG()
\end{verbatim}
\end{screen}

\begin{itemize}

\item{{\bf 引数}}

なし。

\item{{\bf 返り値}}

{PS::S32}型。i粒子グループの数を返す。

\end{itemize}

%%%%%%%%%%%%%%%
%\begin{screen}
%\begin{verbatim}
%void PS::TreeForForce::calcForce(
%                       void (*pfunc)(const EssentialParticleI * , 
%                                     const PS::S32 , 
%                                     const EssentialParticleJ *, 
%                                     const PS::S32, 
%                                     Force *) )
%\end{verbatim}
%\end{screen}
%
%\begin{itemize}
%
%\item{{\bf 引数}}
%
%{\tt (*pfunc)}: 入力。返り値はvoid型の相互作用計算用関数ポインタ。関数の引数
%は第一引数から順に{\tt const EssentialParticleI *}型、{\tt PS::S32}型、
%{\tt const EssentialParticleJ *}型、{\tt PS::S32}型、{\tt Force *}型。
%
%\item{{\bf 返り値}}
%
%なし。
%
%\item{{\bf 機能}}
%
%関数ポインタを用いて全粒子に及ぼされる力を計算し、結果を\\ {\tt
%PS::TreeForForce::setParticleFromFullParticle()}で読み込んだ時の粒子の
%並びと同じ順番で格納する。
%
%\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%
\paragraph{ネイバーリスト}
\mbox{}
%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%
\begin{screen}
\begin{verbatim}
template<class Tsearchmode,
         class Tptcl>
void PS::TreeForForce::getNeighborListOneParticle
             (const Tptcl & ptcl,
              PS::S32 & nnp,
              Tepj * (& epj));
\end{verbatim}
\end{screen}

\begin{itemize}

\item{{\bf テンプレート引数}}

{\tt Tsearchmode}: 入力。{\tt SEARCH\_MODE}型。

{\tt Tptcl}: 入力。{\tt Tptcl}型。入力しなくてOK。

\item{{\bf 引数}}

{\tt ptcl}: 入力。{\tt const Tptcl \&}型。

{\tt nnp}: 出力。{\tt PS::S32 \&}型。

{\tt epj}: 出力。{\tt Tepj * (\&)}型。

\item{{\bf 返り値}}

なし

\item 機能

ある１つの粒子のネイバーリストを返す。ネイバーリストの探し方をテンプレー
ト第１引数{\tt Tsearchmode}で指定する。この相互作用ツリークラスの{\tt
SEARCH\_MODE}型が収集モードである場合に、{\tt Tsearchmode}に散乱モード
や対称モードを選んだら、コンパイルエラーとなる。テンプレート第２引数
{\tt Tptcl}には入力の必要はないが、もし入力する場合は第１引数の型と同じ
でないと、コンパイルエラーとなる。粒子の指定を第１引数{\tt ptcl}で行う。
この型はメンバ関数に{\tt getPos}を含む必要がある。第２引数{\tt nnp}にネ
イバー粒子の数を返す。第３引数{\tt epj}にネイバーリストを返す。{\tt
epj}の型はこの相互作用ツリークラスのEssentialParticleJ型と同じ型でなけ
ればならず、そうでない場合はコンパイルエラーとなる。{\tt epj}のメモリの
確保はこの関数内で行う。このリストの寿命は、次にネイバーリストを作る関
数を呼ぶまでとする。

\end{itemize}

%%%%%%%%%%%%%%%
\begin{screen}
\begin{verbatim}
void PS::TreeForForce::getNeighborListOneIPGroup
              (const PS::S32 iipg,
               PS::S32 & nip,
               const Tepi * epi,
               PS::S32 & nnp,
               Tepj * (& epj));
\end{verbatim}
\end{screen}

\begin{itemize}

\item{{\bf 引数}}

{\tt iipg}: 入力。{\tt const PS::S32}型。

{\tt nip}: 出力。{\tt PS::S32 \&}型。

{\tt epi}: 出力。{\tt const epi *}型。

{\tt nnp}: 出力。{\tt PS::S32 \&}型。

{\tt epj}: 出力。{\tt Tepj * (\&)}型。

\item{{\bf 返り値}}

なし

\item 機能

この相互作用ツリークラスのある１つのiグループのネイバーリストの和集合
(以下ネイバーリストと省略)を返す。iグループの指定を第１引数{\tt iipg}で
行う。ユーザーはiグループの数を{\tt PS::TreeForForce::getNumberOfIPG}で
知ることはできるので、{\tt for}ループでまわせば、全iグループのネイバー
リストを得ることができる。第２引数{\tt nip}に指定したiグループの粒子の
数を返す。第３引数{\tt epi}にこのi グループの粒子リストを返す。この型は
この相互作用ツリークラスのEssentialParticleI型と同じである必要があり、
そうでないとコンパイルエラーとなる。第４引数{\tt nnp}にこのiグループの
ネイバー粒子の数を返す。第５引数{\tt epj}にこのiグループのネイバーリス
トを返す。{\tt epj}の型はこの相互作用ツリークラスのEssentialParticleJ型
と同じ型でなければならず、そうでない場合はコンパイルエラーとなる。{\tt
epi}と{\tt epj}のメモリの確保は、この関数内で行う。これらの寿命は{\tt
getNeighborListOneParticle}のネイバーリストの寿命と同じ。

\end{itemize}

%%%%%%%%%%%%%%%
\begin{screen}
\begin{verbatim}
template <class Tsearchmode,
          class TTreeForForce,
          class Tepi2>
void PS::TreeForForce::getNeighborListOneIPGroup
              (const PS::S32 iipg,
               const TTreeForForce & ttf,
               PS::S32 & nip,
               const Tepi2 * epi,
               PS::S32 & nnp,
               Tepj * (& epj));
\end{verbatim}
\end{screen}

\begin{itemize}

\item{{\bf テンプレート引数}}

{\tt Tsearchmode}: 入力。{\tt Tsearchmode}型。

{\tt TTreeForForce}: 入力。{\tt TTreeForForce}型。入力しなくてもOK。

{\tt Tepi2}: 入力。{\tt Tepi2}型。入力しなくてもOK。

\item{{\bf 引数}}

{\tt iipg}: 入力。{\tt const PS::S32}型。

{\tt ttf}: 入力。{\tt const TTreeForForce \&}型。

{\tt nip}: 出力。{\tt PS::S32 \&}型。

{\tt epi}: 出力。{\tt const epi2 *}型。

{\tt nnp}: 出力。{\tt PS::S32 \&}型。

{\tt epj}: 出力。{\tt Tepj * (\&)}型。

\item{{\bf 返り値}}

なし

\item 機能

相互作用クラスのインスタンス{\tt ttf}に属すある１つのiグループのネイバー
リストの和集合(以下ネイバーリストと省略)を返す。ネイバーリストの探し方
をテンプレート第１引数{\tt Tsearchmode}で指定する。ネイバーリストを返す
側の相互作用クラスの{\tt SEARCH\_MODE}型が収集モードである場合に、テン
プレート第１引数に散乱モードや対称モードを選んだら、コンパイルエラーと
なる。テンプレート第２({\tt TTreeForForce})、３引数({\tt Tepi2})に入力
の必要はないが、入力する場合、それぞれ第２引数{\tt ttf}と第４引数{\tt
epi}と同じでなければ、コンパイルエラーとなる。iグループの指定を第１引数
{\tt iipg} で行う。ユーザーはiグループの数を{\tt ttf.getNumberOfIPG}で
知ることはできるので、{\tt for}ループでまわせば、全iグループのネイバー
リストを得ることができる。第２引数{\tt ttf}でこのiグループの属す相互作
用ツリークラスのインスタンスを指定する。第３引数{\tt nip}にiグループの
粒子の数を返す。第４引数{\tt epi}にこのi グループの粒子リストを返す。
{\tt epi}の型は{\tt ttf}のEssentialParticleI型と同じである必要があり、
そうでないとコンパイルエラーとなる。第５引数{\tt nnp}にこのiグループの
ネイバー粒子の数を返す。第６引数{\tt epj}にこのiグループのネイバーリス
トを返す。{\tt epj}の型はネイバーリストを返す側の相互作用ツリークラスの
EssentialParticleJ 型と同じ型でなければならず、そうでない場合はコンパイ
ルエラーとなる。{\tt epi}と{\tt epj}のメモリの確保は、この関数内で行う。
これらの寿命は{\tt getNeighborListOneParticle}のネイバーリストの寿命と
同じ。

\end{itemize}

%%%%%%%%%%%%%%%
\begin{screen}
\begin{verbatim}
void PS::TreeForForce::getNeighborListOneIPGroupEachParticle
              (const PS::S32 iipg,
               PS::S32 & nip,
               const Tepi * epi,
               PS::S32 * (& nnp),
               Tepj * (& epj));
\end{verbatim}
\end{screen}

\begin{itemize}

\item{{\bf 引数}}

{\tt iipg}: 入力。{\tt const PS::S32}型。

{\tt nip}: 出力。{\tt PS::S32 \&}型。

{\tt epi}: 出力。{\tt const epi *}型。

{\tt nnp}: 出力。{\tt PS::S32 * (\&)}型。

{\tt epj}: 出力。{\tt Tepj * (\&)}型。

\item{{\bf 返り値}}

なし

\item 機能

この相互作用ツリークラスのある１つのiグループの粒子それぞれのネイバーリ
ストを返す。iグループの指定を第１引数{\tt iipg}で行う。ユーザーはiグルー
プの数を{\tt PS::TreeForForce::getNumberOfIPG}で知ることはできるので、
{\tt for}ループでまわせば、全iグループのネイバーリストを得ることができ
る。第２引数{\tt nip}に指定したiグループの粒子の数を返す。第３引数{\tt
epi}にこのiグループの粒子リストを返す。この型はこの相互作用ツリークラス
のEssentialParticleI型と同じである必要があり、そうでないとコンパイルエ
ラーとなる。第４引数{\tt nnp}と第５引数{\tt epj}に返すものは以下の通り
である。{\tt epj}には、リスト{\tt epi}の粒子順にネイバーリストを返す。
ネイバーリスト内の変位を第４引数{\tt nnp}に返す。{\tt epj}の型はこの相
互作用ツリークラスのEssentialParticleJ型と同じ型でなければならず、そう
でない場合はコンパイルエラーとなる。{\tt epi}、{\tt nnp}、{\tt epj}のメ
モリの確保は、この関数内で行う。これらのリストの寿命は{\tt
getNeighborListOneParticle}のネイバーリストの寿命と同じ。

\end{itemize}

%%%%%%%%%%%%%%%
\begin{screen}
\begin{verbatim}
template <class Tsearchmode,
          class TTreeForForce,
          class Tepi2>
void PS::TreeForForce::getNeighborListOneIPGroupEachParticle
              (const PS::S32 iipg,
               const TTreeForForce & ttf,
               PS::S32 & nip,
               const Tepi2 * epi,
               PS::S32 * (& nnp),
               Tepj * (& epj));
\end{verbatim}
\end{screen}

\begin{itemize}

\item{{\bf テンプレート引数}}

{\tt Tsearchmode}: 入力。{\tt Tsearchmode}型。

{\tt TTreeForForce}: 入力。{\tt TTreeForForce}型。入力しなくてもOK。

{\tt Tepi2}: 入力。{\tt Tepi2}型。入力しなくてもOK。

\item{{\bf 引数}}

{\tt iipg}: 入力。{\tt const PS::S32}型。

{\tt ttf}: 入力。{\tt const TTreeForForce \&}型。

{\tt nip}: 出力。{\tt PS::S32 \&}型。

{\tt epi}: 出力。{\tt const epi2 *}型。

{\tt nnp}: 出力。{\tt PS::S32 * (\&)}型。

{\tt epj}: 出力。{\tt Tepj * (\&)}型。

\item{{\bf 返り値}}

なし

\item 機能

相互作用クラスのインスタンス{\tt ttf}に属すある１つのiグループの粒子そ
れぞれのネイバーリストを返す。ネイバーリストの探し方をテンプレート第１
引数{\tt Tsearchmode}で指定する。ネイバーリストを返す側の相互作用クラス
の{\tt SEARCH\_MODE}型が収集モードである場合に、{\tt Tsearchmode}に散乱
モードや対称モードを選んだら、コンパイルエラーとなる。テンプレート第２
({\tt TTreeForForce})、３引数({\tt Tepi2})に入力の必要はないが、入力す
る場合、それぞれ第２引数{\tt ttf}と第４引数{\tt epi}と同じでなければ、
コンパイルエラーとなる。iグループの指定を第１引数{\tt iipg} で行う。ユー
ザーはiグループの数を{\tt ttf.getNumberOfIPG}で知ることはできるので、
{\tt for}ループでまわせば、全iグループのネイバーリストを得ることができ
る。第２引数{\tt ttf}でこのiグループの属す相互作用ツリークラスのインス
タンスを指定する。第３引数{\tt nip}にiグループの粒子の数を返す。第４引
数{\tt epi}にこのi グループの粒子リストを返す。{\tt epi}の型は{\tt
ttf}のEssentialParticleI型と同じである必要があり、そうでないとコンパイ
ルエラーとなる。第５引数{\tt nnp}と第６引数{\tt epj}に返すものは以下の
通りである。{\tt epj}には、リスト{\tt epi}の粒子順にネイバーリストを返
す。ネイバーリスト内の変位を{\tt nnp}に返す。{\tt epj}の型はこの相互作
用ツリークラスのEssentialParticleJ型と同じ型でなければならず、そうでな
い場合はコンパイルエラーとなる。{\tt epi}、{\tt nnp}、{\tt epj}のメモリ
の確保は、この関数内で行う。これらの寿命は{\tt
getNeighborListOneParticle}のネイバーリストの寿命と同じ。

\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%
\paragraph{その他}
\mbox{}
%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%
\begin{screen}
\begin{verbatim}
FORCE & PS::TreeForForce::getForce(const PS::S32 id)
\end{verbatim}
\end{screen}

\begin{itemize}

\item{{\bf 引数}}

{\tt id}: 入力。{\tt const PS::S32}。粒子インデクス。

\item{{\bf 返り値}}

{\tt Force \&}型。{\tt id}番目に挿入した粒子にかかる力を返す。

\end{itemize}

%%%%%%%%%%%%%%%
\begin{screen}
\begin{verbatim}
template<class TTreeForForce>
void PS::TreeForForce::copyLocalTreeStructure(const TTreeForForce & tff)
\end{verbatim}
\end{screen}

\begin{itemize}

\item{{\bf 引数}}

{\tt tff}: 入力。すでにローカルツリーを持っている相互作用ツリークラスの
インスタンス。

\item{{\bf 返り値}}

なし。

\item 機能

{\tt tff}の中にあるローカルツリーを\redtext{自分に}コピーする。

\end{itemize}

%%%%%%%%%%%%%%%
\begin{screen}
\begin{verbatim}
bool PS::TreeForForce::repeatLocalCalcForce()
\end{verbatim}
\end{screen}

\begin{itemize}

\item{{\bf 引数}}

なし。

\item{{\bf 返り値}}

{\tt bool}型。

\item 機能

ユーザーが相互作用計算カーネル内で{\tt EssentialParticleI}型のサーチ半
径を変更した後、もう一度ローカルだけで相互作用の計算が可能かどうかを判
定する。可能な場合は{\tt true}を返し、不可能な場合は{\tt false}を返す。

\end{itemize}


%%%%%%%%%%%%%%%
